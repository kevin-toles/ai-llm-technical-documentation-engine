[
  {
    "chapter_number": 1,
    "title": "Domain Modeling",
    "start_page": 1,
    "end_page": 24,
    "summary": "Introduces domain modeling and Domain-Driven Design (DDD) concepts including entities, value objects, and aggregates. Focuses on modeling business logic and domain concepts in Python with proper encapsulation and invariants.",
    "keywords": [
      "domain modeling",
      "entities",
      "value objects",
      "aggregates",
      "domain-driven design",
      "DDD",
      "repositories",
      "services",
      "domain events",
      "bounded context",
      "ubiquitous language",
      "domain logic",
      "anemic model",
      "rich model",
      "business logic"
    ],
    "concepts": [
      "domain modeling",
      "entities",
      "value objects",
      "aggregates",
      "domain-driven design",
      "business logic",
      "domain models",
      "invariants",
      "encapsulation",
      "ubiquitous language"
    ]
  },
  {
    "chapter_number": 2,
    "title": "Repository Pattern",
    "start_page": 25,
    "end_page": 46,
    "summary": "Explores the Repository pattern for abstracting data persistence and database access. Covers implementing repositories with SQLAlchemy, the ports and adapters (hexagonal) architecture, and separating domain logic from infrastructure concerns.",
    "keywords": [
      "repository pattern",
      "abstractions",
      "ORM",
      "SQLAlchemy",
      "database",
      "persistence",
      "unit of work",
      "data access",
      "queries",
      "CRUD",
      "repository interface",
      "data layer",
      "database abstraction",
      "SQL",
      "transactions"
    ],
    "concepts": [
      "repository pattern",
      "persistence",
      "data access",
      "ORM",
      "SQLAlchemy",
      "database abstraction",
      "ports and adapters",
      "repository interface",
      "persistence layer",
      "data mapping"
    ]
  },
  {
    "chapter_number": 3,
    "title": "A Brief Interlude: On Coupling and Abstractions",
    "start_page": 47,
    "end_page": 58,
    "summary": "Discusses software coupling and abstractions as fundamental architectural concepts. Examines the tradeoffs between loose and tight coupling, dependency inversion principle, and designing clean interfaces and boundaries.",
    "keywords": [
      "service layer",
      "use cases",
      "orchestration",
      "domain services",
      "application services",
      "business logic",
      "transaction management",
      "error handling",
      "service interfaces",
      "command handlers",
      "service design",
      "layer architecture",
      "separation of concerns",
      "facades",
      "coordinators"
    ],
    "concepts": [
      "coupling",
      "abstractions",
      "dependencies",
      "architecture",
      "loose coupling",
      "dependency inversion",
      "layered architecture",
      "separation of concerns",
      "interfaces",
      "modularity"
    ]
  },
  {
    "chapter_number": 4,
    "title": "Our First Use Case: Flask API and Service Layer",
    "start_page": 59,
    "end_page": 86,
    "summary": "Demonstrates building a Flask API with a service layer to orchestrate use cases. Shows how to separate API concerns from business logic, implement application services, and structure REST endpoints properly.",
    "keywords": [
      "unit of work",
      "transactions",
      "atomic operations",
      "database commits",
      "rollback",
      "consistency",
      "ACID",
      "session management",
      "change tracking",
      "persistence",
      "transaction boundaries",
      "database sessions",
      "commit",
      "flush",
      "isolation"
    ],
    "concepts": [
      "Flask API",
      "service layer",
      "use cases",
      "orchestration",
      "REST API",
      "application services",
      "API endpoints",
      "web framework",
      "HTTP handlers",
      "service orchestration"
    ]
  },
  {
    "chapter_number": 5,
    "title": "TDD in High Gear and Low Gear",
    "start_page": 87,
    "end_page": 104,
    "summary": "Explores test-driven development practices at different levels (high gear vs low gear). Covers the test pyramid, balancing unit tests vs integration tests, and using pytest effectively with mocks and fixtures.",
    "keywords": [
      "aggregates",
      "consistency boundaries",
      "invariants",
      "root entities",
      "aggregate design",
      "transactional boundaries",
      "domain rules",
      "business rules",
      "entity relationships",
      "aggregate patterns",
      "aggregate root",
      "invariant enforcement",
      "consistency",
      "boundaries",
      "encapsulation"
    ],
    "concepts": [
      "test-driven development",
      "TDD",
      "unit testing",
      "integration testing",
      "test pyramid",
      "pytest",
      "mocking",
      "test fixtures",
      "test doubles",
      "acceptance testing"
    ]
  },
  {
    "chapter_number": 6,
    "title": "Unit of Work Pattern",
    "start_page": 105,
    "end_page": 132,
    "summary": "Introduces the Unit of Work pattern for managing database transactions and ensuring atomic operations. Covers transaction boundaries, commit/rollback semantics, session management, and implementing UoW as a context manager.",
    "keywords": [
      "events",
      "domain events",
      "message bus",
      "event handlers",
      "event-driven",
      "decoupling",
      "pub-sub",
      "event sourcing",
      "event publishing",
      "subscribers",
      "event architecture",
      "messaging",
      "event handling",
      "asynchronous",
      "notifications"
    ],
    "concepts": [
      "unit of work pattern",
      "transactions",
      "database transactions",
      "commit",
      "rollback",
      "ACID",
      "session management",
      "transactional consistency",
      "context managers",
      "atomic operations"
    ]
  },
  {
    "chapter_number": 7,
    "title": "Aggregates and Consistency Boundaries",
    "start_page": 133,
    "end_page": 154,
    "summary": "Examines aggregates as consistency boundaries in domain-driven design. Discusses aggregate roots, enforcing invariants, transactional boundaries, and designing for consistency vs eventual consistency in distributed systems.",
    "keywords": [
      "event-driven architecture",
      "message broker",
      "Redis",
      "event processing",
      "asynchronous",
      "pub-sub",
      "message patterns",
      "event bus",
      "message queue",
      "event streaming",
      "event propagation",
      "messaging infrastructure",
      "event dispatch",
      "handlers",
      "subscribers"
    ],
    "concepts": [
      "aggregates",
      "consistency boundaries",
      "aggregate roots",
      "invariants",
      "transactional boundaries",
      "domain model design",
      "eventual consistency",
      "entity relationships",
      "bounded contexts",
      "domain integrity"
    ]
  },
  {
    "chapter_number": 8,
    "title": "Events and the Message Bus",
    "start_page": 155,
    "end_page": 188,
    "summary": "Introduces domain events and the message bus pattern for decoupling components. Covers event publishing and subscribing, implementing an event-driven architecture, and using events to communicate domain state changes asynchronously.",
    "keywords": [
      "commands",
      "command handlers",
      "CQRS",
      "command pattern",
      "command processing",
      "command bus",
      "write operations",
      "command validation",
      "command dispatching",
      "command objects",
      "command segregation",
      "write model",
      "command execution",
      "handlers",
      "command architecture"
    ],
    "concepts": [
      "domain events",
      "message bus",
      "event handlers",
      "publish-subscribe",
      "event-driven architecture",
      "asynchronous messaging",
      "event publishing",
      "event subscribers",
      "decoupling",
      "observer pattern"
    ]
  },
  {
    "chapter_number": 9,
    "title": "Going to Town on the Message Bus",
    "start_page": 189,
    "end_page": 214,
    "summary": "Expands on the message bus implementation with advanced event handling patterns. Covers event dispatching, handler registration, message routing, and building robust event processing pipelines.",
    "keywords": [
      "CQRS",
      "read models",
      "write models",
      "query optimization",
      "command query separation",
      "eventual consistency",
      "projections",
      "query side",
      "command side",
      "segregation",
      "read optimization",
      "denormalization",
      "query handlers",
      "view models",
      "materialized views"
    ],
    "concepts": [
      "message bus implementation",
      "event dispatching",
      "handler registration",
      "message routing",
      "event processing",
      "subscriber management",
      "notification patterns",
      "event handling",
      "message queuing",
      "async processing"
    ]
  },
  {
    "chapter_number": 10,
    "title": "Commands and Command Handler",
    "start_page": 215,
    "end_page": 234,
    "summary": "Introduces the Command pattern and command handlers as part of CQRS. Distinguishes commands (write operations) from queries, covers command validation, intent capture, and implementing a command bus for orchestrating business operations.",
    "keywords": [
      "dependency injection",
      "inversion of control",
      "IoC",
      "dependency inversion",
      "SOLID",
      "composition root",
      "service locator",
      "constructor injection",
      "dependency container",
      "DI container",
      "abstractions",
      "loose coupling",
      "dependency management",
      "injection patterns",
      "bootstrapping"
    ],
    "concepts": [
      "commands",
      "command handlers",
      "command pattern",
      "CQRS",
      "write operations",
      "command validation",
      "intent capture",
      "command bus",
      "business operations",
      "state mutations"
    ]
  },
  {
    "chapter_number": 11,
    "title": "Event-Driven Architecture: Using Events to Integrate Microservices",
    "start_page": 235,
    "end_page": 264,
    "summary": "Explores event-driven architecture for integrating microservices. Covers distributed system patterns, async communication between services, eventual consistency, service choreography vs orchestration, and bounded contexts with anti-corruption layers.",
    "keywords": [
      "adapters",
      "hexagonal architecture",
      "ports",
      "driven adapters",
      "driving adapters",
      "external systems",
      "infrastructure",
      "API adapters",
      "database adapters",
      "clean architecture",
      "plugin architecture",
      "boundary",
      "interfaces",
      "decoupling",
      "abstraction layers"
    ],
    "concepts": [
      "microservices architecture",
      "event-driven integration",
      "distributed systems",
      "service integration",
      "async communication",
      "eventual consistency",
      "service choreography",
      "bounded contexts",
      "anti-corruption layer",
      "integration events"
    ]
  },
  {
    "chapter_number": 12,
    "title": "Command-Query Responsibility Segregation (CQRS)",
    "start_page": 265,
    "end_page": 288,
    "summary": "Details Command-Query Responsibility Segregation (CQRS) pattern. Covers separating read and write models, building projections and materialized views, denormalization strategies, and optimizing for scalability with separate query and command sides.",
    "keywords": [
      "testing",
      "unit tests",
      "integration tests",
      "test doubles",
      "mocking",
      "fixtures",
      "pytest",
      "test-driven development",
      "TDD",
      "test pyramid",
      "test coverage",
      "assertions",
      "test isolation",
      "test fixtures",
      "test automation"
    ],
    "concepts": [
      "CQRS pattern",
      "read models",
      "write models",
      "query optimization",
      "command-query separation",
      "projections",
      "denormalization",
      "materialized views",
      "scalability patterns",
      "eventual consistency"
    ]
  },
  {
    "chapter_number": 13,
    "title": "Dependency Injection (and Bootstrapping)",
    "start_page": 289,
    "end_page": 497,
    "summary": "Covers dependency injection and application bootstrapping. Discusses composition root pattern, IoC containers, factory patterns, managing dependencies for testability, and properly wiring up application components during initialization.",
    "keywords": [
      "microservices",
      "distributed systems",
      "service boundaries",
      "API design",
      "REST",
      "HTTP",
      "service integration",
      "inter-service communication",
      "API versioning",
      "service mesh",
      "distributed architecture",
      "service decomposition",
      "network communication",
      "service coordination",
      "service patterns"
    ],
    "concepts": [
      "dependency injection",
      "bootstrapping",
      "composition root",
      "IoC container",
      "dependency management",
      "factory patterns",
      "configuration",
      "testability",
      "loose coupling",
      "dependency wiring"
    ]
  }
]