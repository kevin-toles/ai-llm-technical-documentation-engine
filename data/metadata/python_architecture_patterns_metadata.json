[
  {
    "chapter_number": 1,
    "title": "Introduction to Software Architecture",
    "start_page": 1,
    "end_page": 13,
    "summary": "Introduces software architecture fundamentals, defining system structure and division into smaller units. Covers Conway's Law effects on architecture, in-process communication, and security aspects. Presents application example overview for the book.",
    "keywords": [
      "software architecture",
      "system structure",
      "Conway's Law",
      "single-responsibility",
      "abstractions",
      "LAMP architecture",
      "division of units",
      "communication patterns",
      "security design",
      "application structure",
      "monolithic architecture",
      "in-process communication",
      "team organization",
      "software complexity",
      "architectural patterns"
    ],
    "concepts": [
      "software architecture definition",
      "system complexity management",
      "Conway's Law",
      "division into units",
      "LAMP stack",
      "single responsibility",
      "in-process communication",
      "team structure impact",
      "security architecture",
      "monolithic design"
    ]
  },
  {
    "chapter_number": 2,
    "title": "API Design",
    "start_page": 17,
    "end_page": 73,
    "summary": "Covers API design principles including abstractions, resource and action patterns, and RESTful interfaces. Details authentication methods, API versioning strategies, and frontend/backend architecture. Designs the example API with complete endpoint specifications.",
    "keywords": [
      "API design",
      "RESTful interfaces",
      "abstractions",
      "resources",
      "CRUD operations",
      "authentication",
      "OAuth",
      "JWT tokens",
      "API versioning",
      "semantic versioning",
      "frontend backend",
      "MVC pattern",
      "HTML interfaces",
      "single-page apps",
      "OpenAPI specification"
    ],
    "concepts": [
      "API abstraction layers",
      "RESTful design principles",
      "resource modeling",
      "authentication mechanisms",
      "OAuth workflow",
      "JWT implementation",
      "API versioning strategies",
      "MVC architecture",
      "frontend backend separation",
      "OpenAPI specification"
    ]
  },
  {
    "chapter_number": 3,
    "title": "Data Modeling",
    "start_page": 75,
    "end_page": 110,
    "summary": "Explores different database types including relational, non-relational (key-value, document, wide-column, graph), and small databases. Discusses database transactions, ACID properties, and distributed relational database strategies including primary/replica and sharding.",
    "keywords": [
      "databases",
      "relational databases",
      "SQL",
      "non-relational databases",
      "NoSQL",
      "key-value stores",
      "document stores",
      "graph databases",
      "database transactions",
      "ACID properties",
      "sharding",
      "primary replica",
      "eventual consistency",
      "MongoDB",
      "PostgreSQL"
    ],
    "concepts": [
      "database types",
      "relational model",
      "ACID transactions",
      "NoSQL paradigms",
      "database sharding",
      "replication strategies",
      "eventual consistency",
      "transaction isolation",
      "database scalability",
      "distributed databases"
    ]
  },
  {
    "chapter_number": 4,
    "title": "The Data Layer",
    "start_page": 111,
    "end_page": 143,
    "summary": "Examines the Model layer and Domain-Driven Design, using ORMs for database independence. Covers Repository pattern, Unit of Work pattern, CQRS, and database migrations. Addresses legacy database challenges and schema synchronization.",
    "keywords": [
      "data layer",
      "ORM",
      "Domain-Driven Design",
      "Repository pattern",
      "Unit of Work",
      "CQRS",
      "database migrations",
      "SQLAlchemy",
      "backward compatibility",
      "schema changes",
      "legacy databases",
      "data encapsulation",
      "read write models",
      "database independence",
      "SQL composition"
    ],
    "concepts": [
      "ORM patterns",
      "Domain-Driven Design",
      "Repository pattern",
      "Unit of Work pattern",
      "CQRS architecture",
      "database migration strategies",
      "schema evolution",
      "legacy system integration",
      "data encapsulation",
      "read-write separation"
    ]
  },
  {
    "chapter_number": 5,
    "title": "The Twelve-Factor App Methodology",
    "start_page": 147,
    "end_page": 171,
    "summary": "Introduces the Twelve-Factor App methodology for building modern web services. Covers continuous integration, scalability, configuration management, and containerization. Explains how to build once and run multiple times with proper dependencies.",
    "keywords": [
      "Twelve-Factor App",
      "continuous integration",
      "scalability",
      "configuration",
      "stateless",
      "build process",
      "dependencies",
      "containerization",
      "Docker",
      "environment variables",
      "monitoring",
      "admin processes",
      "cloud native",
      "disposability",
      "dev prod parity"
    ],
    "concepts": [
      "Twelve-Factor methodology",
      "continuous integration",
      "configuration externalization",
      "stateless processes",
      "containerization principles",
      "build deployment separation",
      "scalability patterns",
      "cloud-native design",
      "disposable infrastructure",
      "environment parity"
    ]
  },
  {
    "chapter_number": 6,
    "title": "Web Server Structures",
    "start_page": 173,
    "end_page": 217,
    "summary": "Details web server structures including request-response patterns, web architecture with reverse proxies, and serving static content. Covers uWSGI, WSGI applications, process management, and Django MVT architecture with REST framework integration.",
    "keywords": [
      "web servers",
      "request response",
      "reverse proxy",
      "uWSGI",
      "WSGI",
      "Nginx",
      "static content",
      "process lifecycle",
      "Django",
      "MVT architecture",
      "middleware",
      "Django REST framework",
      "URL routing",
      "views",
      "serializers"
    ],
    "concepts": [
      "web server architecture",
      "request-response cycle",
      "reverse proxy patterns",
      "WSGI protocol",
      "process management",
      "Django architecture",
      "middleware layers",
      "REST framework",
      "URL routing",
      "view serialization"
    ]
  },
  {
    "chapter_number": 7,
    "title": "Event-Driven Structures",
    "start_page": 219,
    "end_page": 254,
    "summary": "Covers event-driven architectures with asynchronous tasks, scheduled tasks, and queue effects. Introduces Celery for task management, worker configuration, and task triggering. Explains cloud queues, workers, and Celery Flower for monitoring.",
    "keywords": [
      "event-driven",
      "asynchronous tasks",
      "message queues",
      "Celery",
      "task scheduling",
      "workers",
      "RabbitMQ",
      "Redis",
      "task subdivision",
      "queue effects",
      "Celery Flower",
      "background processing",
      "task monitoring",
      "distributed tasks",
      "event processing"
    ],
    "concepts": [
      "event-driven architecture",
      "asynchronous processing",
      "message queues",
      "Celery framework",
      "task scheduling",
      "worker processes",
      "distributed tasks",
      "background jobs",
      "task monitoring",
      "queue management"
    ]
  },
  {
    "chapter_number": 8,
    "title": "Advanced Event-Driven Structures",
    "start_page": 255,
    "end_page": 280,
    "summary": "Explores advanced event-driven patterns including streaming events, pipelines for processing tasks, and defining message buses. Covers complex event systems and testing strategies for event-driven architectures.",
    "keywords": [
      "streaming events",
      "pipelines",
      "message bus",
      "complex events",
      "event testing",
      "task chaining",
      "event workflows",
      "asynchronous patterns",
      "event propagation",
      "distributed events",
      "event handlers",
      "task coordination",
      "event architecture",
      "pipeline processing",
      "event systems"
    ],
    "concepts": [
      "event streaming",
      "pipeline architecture",
      "message bus design",
      "complex event processing",
      "event testing",
      "task orchestration",
      "event workflows",
      "distributed events",
      "event handlers",
      "pipeline processing"
    ]
  },
  {
    "chapter_number": 9,
    "title": "Microservices vs Monolith",
    "start_page": 281,
    "end_page": 322,
    "summary": "Compares monolithic and microservices architectures, discussing when to choose each approach. Covers migration strategies from monolith to microservices, containerization with Docker, and Kubernetes orchestration for deployment.",
    "keywords": [
      "microservices",
      "monolith",
      "architecture patterns",
      "migration strategies",
      "containerization",
      "Docker",
      "Kubernetes",
      "service decomposition",
      "team communication",
      "deployment strategies",
      "service boundaries",
      "strangler pattern",
      "orchestration",
      "service mesh",
      "distributed systems"
    ],
    "concepts": [
      "microservices architecture",
      "monolithic systems",
      "service decomposition",
      "migration patterns",
      "Docker containerization",
      "Kubernetes orchestration",
      "service boundaries",
      "team organization",
      "deployment patterns",
      "distributed system design"
    ]
  },
  {
    "chapter_number": 10,
    "title": "Testing and TDD",
    "start_page": 327,
    "end_page": 379,
    "summary": "Introduces testing philosophy with unit, integration, and system tests. Covers Test-Driven Development (TDD) process, Python unittest and pytest frameworks. Explains mocking, dependency injection, fixtures, and grouping tests.",
    "keywords": [
      "testing",
      "TDD",
      "unit tests",
      "integration tests",
      "pytest",
      "unittest",
      "mocking",
      "dependency injection",
      "fixtures",
      "test structure",
      "test design",
      "test philosophy",
      "test coverage",
      "test automation",
      "test driven development"
    ],
    "concepts": [
      "testing philosophy",
      "TDD workflow",
      "test levels",
      "pytest framework",
      "mocking strategies",
      "dependency injection",
      "test fixtures",
      "test organization",
      "test automation",
      "test-driven design"
    ]
  },
  {
    "chapter_number": 11,
    "title": "Package Management",
    "start_page": 381,
    "end_page": 419,
    "summary": "Covers Python package creation and management, from trivial packaging to the Python packaging ecosystem. Discusses PyPI, virtual environments, pure Python and Cython packages. Explains uploading to PyPI and creating private package indexes.",
    "keywords": [
      "package management",
      "PyPI",
      "virtual environments",
      "Python packaging",
      "pip",
      "setuptools",
      "wheel",
      "Cython",
      "binary packages",
      "private index",
      "package distribution",
      "dependencies",
      "package creation",
      "venv",
      "conda"
    ],
    "concepts": [
      "Python packaging",
      "PyPI ecosystem",
      "virtual environments",
      "package distribution",
      "dependency management",
      "binary extensions",
      "Cython integration",
      "private repositories",
      "package versioning",
      "environment isolation"
    ]
  },
  {
    "chapter_number": 12,
    "title": "Logging",
    "start_page": 423,
    "end_page": 439,
    "summary": "Introduces logging basics and producing logs in Python. Covers detecting expected and unexpected errors through logs, log strategies during development, and log limitations for debugging and monitoring.",
    "keywords": [
      "logging",
      "log basics",
      "error detection",
      "log strategies",
      "Python logging",
      "log levels",
      "exception handling",
      "structured logging",
      "log analysis",
      "debugging logs",
      "application monitoring",
      "log aggregation",
      "error tracking",
      "log limitations",
      "production logs"
    ],
    "concepts": [
      "logging fundamentals",
      "log levels",
      "error detection",
      "structured logging",
      "log strategies",
      "exception handling",
      "production logging",
      "log analysis",
      "debugging with logs",
      "logging limitations"
    ]
  },
  {
    "chapter_number": 13,
    "title": "Metrics",
    "start_page": 441,
    "end_page": 461,
    "summary": "Compares metrics versus logs, explaining different metric types. Covers generating metrics with Prometheus, Django Prometheus configuration, querying Prometheus data, and proactive work with metrics including alerting.",
    "keywords": [
      "metrics",
      "Prometheus",
      "monitoring",
      "alerting",
      "metric types",
      "counters",
      "gauges",
      "histograms",
      "time series",
      "Django Prometheus",
      "metric collection",
      "queries",
      "proactive monitoring",
      "SLOs",
      "observability"
    ],
    "concepts": [
      "metrics collection",
      "Prometheus ecosystem",
      "metric types",
      "time series data",
      "monitoring strategies",
      "alerting rules",
      "metric queries",
      "observability",
      "SLO tracking",
      "proactive monitoring"
    ]
  },
  {
    "chapter_number": 14,
    "title": "Profiling",
    "start_page": 463,
    "end_page": 498,
    "summary": "Covers profiling basics and types of profilers for time and memory analysis. Details using cProfile, line profiler, partial profiling techniques. Explains profiling web servers and memory optimization strategies.",
    "keywords": [
      "profiling",
      "performance analysis",
      "cProfile",
      "line profiler",
      "memory profiling",
      "optimization",
      "bottlenecks",
      "execution time",
      "memory usage",
      "profiler types",
      "performance testing",
      "code optimization",
      "memory leaks",
      "profiling tools",
      "performance metrics"
    ],
    "concepts": [
      "performance profiling",
      "execution analysis",
      "cProfile usage",
      "line-level profiling",
      "memory profiling",
      "bottleneck identification",
      "optimization techniques",
      "profiling strategies",
      "performance metrics",
      "resource usage analysis"
    ]
  },
  {
    "chapter_number": 15,
    "title": "Debugging",
    "start_page": 501,
    "end_page": 528,
    "summary": "Addresses detecting and processing defects, investigation in production environments. Covers logging request IDs, analyzing data, increasing logging strategically. Details Python introspection tools, debugging with logs and breakpoints.",
    "keywords": [
      "debugging",
      "defect detection",
      "production debugging",
      "request tracing",
      "log analysis",
      "Python debugger",
      "breakpoints",
      "introspection",
      "error investigation",
      "debugging tools",
      "pdb",
      "debugging strategies",
      "root cause analysis",
      "debugging workflow",
      "issue resolution"
    ],
    "concepts": [
      "debugging techniques",
      "defect investigation",
      "production debugging",
      "request tracing",
      "log-based debugging",
      "Python debugger",
      "breakpoint debugging",
      "error analysis",
      "debugging tools",
      "root cause analysis"
    ]
  },
  {
    "chapter_number": 16,
    "title": "Ongoing Architecture",
    "start_page": 531,
    "end_page": 557,
    "summary": "Covers adjusting architecture over time, handling scheduled downtime and maintenance windows. Discusses incident management, postmortem and premortem analysis, load testing. Explains versioning, backward compatibility, deploying without interruption, and feature flags.",
    "keywords": [
      "ongoing architecture",
      "architectural changes",
      "incident management",
      "postmortem",
      "premortem",
      "load testing",
      "versioning",
      "backward compatibility",
      "zero downtime",
      "feature flags",
      "deployment strategies",
      "maintenance windows",
      "continuous deployment",
      "incremental changes",
      "production operations"
    ],
    "concepts": [
      "architecture evolution",
      "change management",
      "incident response",
      "postmortem analysis",
      "load testing",
      "version management",
      "backward compatibility",
      "zero-downtime deployment",
      "feature flags",
      "continuous operations"
    ]
  }
]