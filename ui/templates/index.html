<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Document Enhancer</title>
    <link rel="stylesheet" href="/static/css/style.css">
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
</head>
<body>
    <div class="window">
        <div class="window-controls">
            <span class="control-button close"></span>
            <span class="control-button minimize"></span>
            <span class="control-button maximize"></span>
        </div>

        <div class="window-title">LLM Document Enhancer</div>

        <div class="content">
            <h1>Workflow Runner</h1>
            
            <!-- Tab Navigation -->
            <div class="tabs">
                <button class="tab active" data-tab="tab1">1. PDF ‚Üí JSON</button>
                <button class="tab" data-tab="tab2">2. Metadata Extract</button>
                <button class="tab" data-tab="tab3">3. Metadata Enrich</button>
                <button class="tab" data-tab="tab4">4. Taxonomy Setup</button>
                <button class="tab" data-tab="tab5">5. Base Guideline</button>
                <button class="tab" data-tab="tab6">6. LLM Enhancement</button>
            </div>

            <!-- Tab Content -->
            {% for tab_id, workflow in workflows.items() %}
            <div class="tab-content {{ 'active' if tab_id == 'tab1' else '' }}" id="{{ tab_id }}">
                <h2>{{ workflow.name }}</h2>
                
                <div class="workflow-info">
                    <div class="path-info">
                        <strong>Input:</strong> <span id="{{ tab_id }}-input-dir">Loading...</span>
                    </div>
                    <div class="path-info">
                        <strong>Found:</strong> <span id="{{ tab_id }}-file-count">0 files</span>
                    </div>
                </div>

                <div class="file-selector">
                    <div class="file-list" id="{{ tab_id }}-files">
                        <p>Loading files...</p>
                    </div>
                </div>

                <div class="button-row">
                    <button class="btn btn-secondary" onclick="clearSelection('{{ tab_id }}')">Clear</button>
                    <button class="btn btn-primary" onclick="runWorkflow('{{ tab_id }}')">Run Workflow ‚ñ∂</button>
                </div>

                <div class="status-panel" id="{{ tab_id }}-status" style="display: none;">
                    <div class="status-header">Workflow Status</div>
                    <div class="status-content" id="{{ tab_id }}-status-content"></div>
                </div>
            </div>
            {% endfor %}
        </div>
    </div>

    <script>
        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabId = tab.dataset.tab;
                
                // Update active tab
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Update active content
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                document.getElementById(tabId).classList.add('active');
                
                // Load files for this tab
                loadFiles(tabId);
            });
        });

        // Load files for a workflow
        async function loadFiles(tabId) {
            const response = await fetch(`/files/${tabId}`);
            const data = await response.json();
            
            const container = document.getElementById(`${tabId}-files`);
            const inputDir = document.getElementById(`${tabId}-input-dir`);
            const fileCount = document.getElementById(`${tabId}-file-count`);
            
            inputDir.textContent = data.input_dir;
            
            if (data.files && data.files.length > 0) {
                fileCount.textContent = `${data.files.length} files`;
                
                // Special handling for Base Guideline tab (requires taxonomy selection)
                if (tabId === 'tab6' && data.taxonomy_files) {
                    container.innerHTML = `
                        <div class="config-section" style="margin-bottom: 20px;">
                            <label class="config-label">Select Taxonomy (for cross-referencing):</label>
                            <select id="${tabId}-taxonomy" class="config-select">
                                <option value="">-- Optional: Select Taxonomy --</option>
                                ${data.taxonomy_files.map(file => `<option value="${file}">${file}</option>`).join('')}
                            </select>
                            <p style="font-size: 11px; color: #666; margin-top: 5px;">
                                Taxonomy defines concepts for cross-book referencing. Leave empty to use defaults.
                            </p>
                        </div>
                        <div class="config-section" style="margin-bottom: 20px;">
                            <label class="config-label">Select Book to Create Guideline From:</label>
                            <select id="${tabId}-book" class="config-select">
                                <option value="">-- Select Book --</option>
                                ${data.files.map(file => `<option value="${file}">${file}</option>`).join('')}
                            </select>
                        </div>
                    `;
                } 
                // Special handling for LLM tab
                else if (data.llm_providers) {
                    container.innerHTML = `
                        <div class="llm-config">
                            <div class="config-section">
                                <label class="config-label">Select Base Guideline:</label>
                                <select id="${tabId}-guideline" class="config-select">
                                    <option value="">-- Select Guideline --</option>
                                    ${data.files.map(file => `<option value="${file}">${file}</option>`).join('')}
                                </select>
                            </div>
                            
                            <div class="config-section">
                                <label class="config-label">Select Taxonomy:</label>
                                <select id="${tabId}-taxonomy" class="config-select">
                                    <option value="">-- Select Taxonomy --</option>
                                    ${data.taxonomy_files.map(file => `<option value="${file}">${file}</option>`).join('')}
                                </select>
                            </div>
                            
                            <div class="config-section">
                                <label class="config-label">LLM Provider:</label>
                                <select id="${tabId}-provider" class="config-select" onchange="updateModelList('${tabId}', this.value)">
                                    <option value="">-- Select Provider --</option>
                                    ${Object.entries(data.llm_providers).map(([id, provider]) => 
                                        `<option value="${id}">${provider.name}</option>`
                                    ).join('')}
                                </select>
                            </div>
                            
                            <div class="config-section">
                                <label class="config-label">Model:</label>
                                <select id="${tabId}-model" class="config-select">
                                    <option value="">-- Select Provider First --</option>
                                </select>
                            </div>
                        </div>
                    `;
                    
                    // Store provider data for model selection
                    window.llmProviders = data.llm_providers;
                    
                } else if (data.supports_tiers && data.tiers) {
                    // Taxonomy tab with tier builder (Trello-style drag & drop)
                    container.innerHTML = `
                        <div class="taxonomy-guide">
                            <h3>üìö Understanding the Three-Tier Taxonomy</h3>
                            <div class="tier-descriptions">
                                <div class="tier-desc">
                                    <strong>üèõÔ∏è Architecture Spine (Priority 1) - Required</strong>
                                    <p>Foundational concepts that form the structural backbone of the domain. These are high-level patterns, principles, and architectural decisions that guide everything else. Think: "What are the core mental models needed to understand this topic?"</p>
                                    <em>Examples: Design patterns, system architecture, core paradigms</em>
                                </div>
                                <div class="tier-desc">
                                    <strong>‚öôÔ∏è Implementation (Priority 2) - Required</strong>
                                    <p>Practical techniques and concrete implementations that build upon architectural concepts. These are the "how-to" specifics: APIs, algorithms, data structures, and coding techniques that developers use daily.</p>
                                    <em>Examples: Language syntax, standard libraries, common algorithms</em>
                                </div>
                                <div class="tier-desc tier-optional">
                                    <strong>‚ú® Engineering Practices (Priority 3) - Optional</strong>
                                    <p>Professional methodologies, workflows, and best practices for building quality software. These are the soft skills and processes that separate hobbyists from professionals.</p>
                                    <em>Examples: Testing strategies, code review, refactoring, team collaboration</em>
                                </div>
                            </div>
                            <div class="tier-relationship">
                                <p><strong>How they relate:</strong> Architecture provides the "why," Implementation provides the "how," and Practices provide the "right way." The first two tiers are required; Engineering Practices can be omitted if not relevant to your taxonomy.</p>
                            </div>
                        </div>
                        <div class="tier-builder">
                            <div class="available-files">
                                <h3>Available Files</h3>
                                <div class="file-pool" id="${tabId}-pool" data-tier="pool">
                                    ${data.files.map(file => `
                                        <div class="pool-file draggable" draggable="true" data-file="${file}">
                                            ${file}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                            <div class="tier-columns">
                                ${data.tiers.map(tier => `
                                    <div class="tier-column">
                                        <h3>${tier.name} <span class="tier-priority">(Priority ${tier.priority})</span></h3>
                                        <div class="tier-list drop-zone" id="${tabId}-${tier.id}" data-tier="${tier.id}" data-priority="${tier.priority}">
                                            <p class="empty-tier">Drag files here</p>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                    initTierBuilder(tabId, data.files);
                } else {
                    // Regular file list
                    container.innerHTML = data.files.map(file => `
                        <label class="file-item">
                            <input type="checkbox" name="${tabId}-file" value="${file}">
                            ${file}
                        </label>
                    `).join('');
                }
            } else {
                fileCount.textContent = '0 files';
                container.innerHTML = '<p class="no-files">No files found</p>';
            }
        }

        // Update model list when provider changes
        function updateModelList(tabId, providerId) {
            const modelSelect = document.getElementById(`${tabId}-model`);
            
            if (!providerId || !window.llmProviders || !window.llmProviders[providerId]) {
                modelSelect.innerHTML = '<option value="">-- Select Provider First --</option>';
                return;
            }
            
            const provider = window.llmProviders[providerId];
            modelSelect.innerHTML = `
                <option value="">-- Select Model --</option>
                ${provider.models.map(model => `<option value="${model}">${model}</option>`).join('')}
            `;
        }

        // Initialize tier builder with Trello-style drag & drop
        function initTierBuilder(tabId, allFiles) {
            let draggedElement = null;
            
            // Add drag event listeners to all draggable items
            document.addEventListener('dragstart', (e) => {
                if (e.target.classList.contains('draggable')) {
                    draggedElement = e.target;
                    e.target.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                }
            });
            
            document.addEventListener('dragend', (e) => {
                if (e.target.classList.contains('draggable')) {
                    e.target.classList.remove('dragging');
                    // Remove all drag-over effects
                    document.querySelectorAll('.drag-over').forEach(el => {
                        el.classList.remove('drag-over');
                    });
                }
            });
            
            // Add drop zone event listeners
            document.querySelectorAll('.drop-zone, .file-pool').forEach(dropZone => {
                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    
                    if (!dropZone.classList.contains('dragging')) {
                        dropZone.classList.add('drag-over');
                    }
                    
                    // Get the draggable element being dragged over
                    const afterElement = getDragAfterElement(dropZone, e.clientY);
                    if (afterElement == null) {
                        // Append at the end, but before empty message
                        const emptyMsg = dropZone.querySelector('.empty-tier');
                        if (draggedElement && draggedElement !== afterElement) {
                            if (emptyMsg) {
                                dropZone.insertBefore(draggedElement, emptyMsg);
                            } else {
                                dropZone.appendChild(draggedElement);
                            }
                        }
                    } else {
                        if (draggedElement && draggedElement !== afterElement) {
                            dropZone.insertBefore(draggedElement, afterElement);
                        }
                    }
                });
                
                dropZone.addEventListener('dragleave', (e) => {
                    if (e.target === dropZone) {
                        dropZone.classList.remove('drag-over');
                    }
                });
                
                dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('drag-over');
                    
                    if (!draggedElement) return;
                    
                    const file = draggedElement.dataset.file;
                    const fromTier = draggedElement.parentElement.dataset.tier;
                    const toTier = dropZone.dataset.tier;
                    
                    // Remove empty message if present
                    const emptyMsg = dropZone.querySelector('.empty-tier');
                    if (emptyMsg) {
                        emptyMsg.remove();
                    }
                    
                    // If moving between different containers, transform the element
                    if (fromTier !== toTier) {
                        if (toTier === 'pool') {
                            // Moving back to pool - convert to pool-file
                            draggedElement.className = 'pool-file draggable';
                            draggedElement.draggable = true;
                            draggedElement.innerHTML = file;
                        } else if (fromTier === 'pool') {
                            // Moving from pool to tier - convert to tier-item
                            draggedElement.className = 'tier-item draggable';
                            draggedElement.draggable = true;
                            draggedElement.innerHTML = `
                                <span class="drag-handle">‚ãÆ‚ãÆ</span>
                                <span class="tier-file-name">${file}</span>
                                <button onclick="removeTierItem('${tabId}', this)" class="tier-btn-remove">‚úï</button>
                            `;
                        }
                    }
                    
                    // Check if origin tier is now empty
                    const originTier = document.querySelector(`[data-tier="${fromTier}"]`);
                    if (originTier && originTier !== dropZone && fromTier !== 'pool') {
                        const items = originTier.querySelectorAll('.tier-item');
                        if (items.length === 0) {
                            originTier.innerHTML = '<p class="empty-tier">Drag files here</p>';
                        }
                    }
                });
            });
        }
        
        // Get the element to insert after during drag
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.draggable:not(.dragging)')];
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        function removeTierItem(tabId, btn) {
            const item = btn.closest('.tier-item');
            const file = item.dataset.file;
            const tierList = item.parentNode;
            
            // Remove from tier
            item.remove();
            
            // Add back to pool
            const pool = document.getElementById(`${tabId}-pool`);
            const poolFile = document.createElement('div');
            poolFile.className = 'pool-file draggable';
            poolFile.draggable = true;
            poolFile.dataset.file = file;
            poolFile.textContent = file;
            pool.appendChild(poolFile);
            
            // Show empty message if no files left
            const items = tierList.querySelectorAll('.tier-item');
            if (items.length === 0) {
                tierList.innerHTML = '<p class="empty-tier">Drag files here</p>';
            }
        }

        // Clear selection
        function clearSelection(tabId) {
            // For LLM tab, clear all dropdowns
            const guideline = document.getElementById(`${tabId}-guideline`);
            
            if (guideline) {
                const taxonomy = document.getElementById(`${tabId}-taxonomy`);
                const provider = document.getElementById(`${tabId}-provider`);
                const model = document.getElementById(`${tabId}-model`);
                
                guideline.value = '';
                taxonomy.value = '';
                provider.value = '';
                model.innerHTML = '<option value="">-- Select Provider First --</option>';
                return;
            }
            
            // For Base Guideline tab (tab6), clear dropdowns
            const bookSelect = document.getElementById(`${tabId}-book`);
            if (bookSelect) {
                bookSelect.value = '';
                const taxonomySelect = document.getElementById(`${tabId}-taxonomy`);
                if (taxonomySelect) taxonomySelect.value = '';
                return;
            }
            
            // For taxonomy tab, move all files back to pool
            const pool = document.getElementById(`${tabId}-pool`);
            if (pool) {
                const allFiles = [];
                ['architecture', 'implementation', 'practices'].forEach(tier => {
                    const tierList = document.getElementById(`${tabId}-${tier}`);
                    if (tierList) {
                        const items = tierList.querySelectorAll('.tier-item');
                        items.forEach(item => {
                            allFiles.push(item.dataset.file);
                            item.remove();
                        });
                        tierList.innerHTML = '<p class="empty-tier">Drop files here or click ‚Üí to add</p>';
                    }
                });
                
                // Re-add all files to pool
                allFiles.forEach(file => {
                    const poolFile = document.createElement('div');
                    poolFile.className = 'pool-file';
                    poolFile.dataset.file = file;
                    poolFile.textContent = file;
                    pool.appendChild(poolFile);
                });
            } else {
                // Regular checkboxes
                document.querySelectorAll(`input[name="${tabId}-file"]`).forEach(cb => {
                    cb.checked = false;
                });
            }
        }

        // Run workflow
        async function runWorkflow(tabId) {
            let selectedFiles = [];
            let tierData = {};
            let llmConfig = {};
            let taxonomyFile = null;
            
            // Check if this is LLM tab
            const guidelineSelect = document.getElementById(`${tabId}-guideline`);
            if (guidelineSelect) {
                const guideline = guidelineSelect.value;
                const taxonomy = document.getElementById(`${tabId}-taxonomy`).value;
                const provider = document.getElementById(`${tabId}-provider`).value;
                const model = document.getElementById(`${tabId}-model`).value;
                
                if (!guideline || !taxonomy || !provider || !model) {
                    alert('Please select all required fields:\n- Base Guideline\n- Taxonomy\n- LLM Provider\n- Model');
                    return;
                }
                
                llmConfig = { guideline, taxonomy, provider, model };
            } 
            // Check if this is Base Guideline tab (tab6)
            else if (tabId === 'tab6') {
                const bookSelect = document.getElementById(`${tabId}-book`);
                const taxonomySelect = document.getElementById(`${tabId}-taxonomy`);
                
                if (!bookSelect || !bookSelect.value) {
                    alert('Please select a book to create guideline from');
                    return;
                }
                
                selectedFiles = [bookSelect.value];
                taxonomyFile = taxonomySelect ? taxonomySelect.value : null;
            }
            else {
                // Check if this is taxonomy tab with tiers
                const pool = document.getElementById(`${tabId}-pool`);
                
                if (pool) {
                    // Collect files by tier with priority order
                    ['architecture', 'implementation', 'practices'].forEach(tier => {
                        const tierList = document.getElementById(`${tabId}-${tier}`);
                        const items = tierList.querySelectorAll('.tier-item');
                        const tierFiles = Array.from(items).map(item => item.dataset.file);
                        if (tierFiles.length > 0) {
                            tierData[tier] = tierFiles;
                        }
                    });
                    
                    // Count total files
                    selectedFiles = Object.values(tierData).flat();
                } else {
                    // Regular file selection with checkboxes
                    selectedFiles = Array.from(
                        document.querySelectorAll(`input[name="${tabId}-file"]:checked`)
                    ).map(cb => cb.value);
                }
                
                if (selectedFiles.length === 0 && Object.keys(tierData).length === 0) {
                    alert('Please select at least one file');
                    return;
                }
            }
            
            // Build payload
            let payload;
            if (llmConfig.guideline) {
                payload = { llm_config: llmConfig };
            } else if (Object.keys(tierData).length > 0) {
                payload = { tiers: tierData };
            } else {
                payload = { files: selectedFiles };
                // Add taxonomy if selected (for tab6)
                if (taxonomyFile) {
                    payload.taxonomy = taxonomyFile;
                }
            }
            
            // Show status panel
            const statusPanel = document.getElementById(`${tabId}-status`);
            const statusContent = document.getElementById(`${tabId}-status-content`);
            statusPanel.style.display = 'block';
            statusContent.innerHTML = '<p>Starting workflow...</p>';
            
            try {
                const response = await fetch(`/run/${tabId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();
                
                if (result.error) {
                    statusContent.innerHTML = `<p class="error">Error: ${result.error}</p>`;
                    return;
                }
                
                // Start polling for status updates
                if (result.workflow_id) {
                    pollWorkflowStatus(tabId, result.workflow_id);
                    statusContent.innerHTML = `<p>‚úì ${result.message}</p><p>Monitoring progress...</p>`;
                }
            } catch (error) {
                statusContent.innerHTML = `<p class="error">Failed to start workflow: ${error.message}</p>`;
            }
        }

        // Poll workflow status
        async function pollWorkflowStatus(tabId, workflowId) {
            const statusContent = document.getElementById(`${tabId}-status-content`);
            
            const interval = setInterval(async () => {
                try {
                    const response = await fetch(`/status/${workflowId}`);
                    const status = await response.json();
                    
                    if (status.error) {
                        clearInterval(interval);
                        statusContent.innerHTML = `<p class="error">Error: ${status.error}</p>`;
                        return;
                    }
                    
                    // Build status display
                    let html = `<p><strong>Status:</strong> ${status.status}</p>`;
                    
                    if (status.progress && status.progress.length > 0) {
                        html += '<div class="progress-log">';
                        status.progress.forEach(msg => {
                            const isError = msg.includes('‚úó');
                            const isSuccess = msg.includes('‚úì');
                            const className = isError ? 'error' : (isSuccess ? 'success' : '');
                            html += `<p class="${className}">${msg}</p>`;
                        });
                        html += '</div>';
                    }
                    
                    if (status.summary) {
                        html += `<p><strong>${status.summary}</strong></p>`;
                    }
                    
                    if (status.output_file) {
                        html += `<p>Output: ${status.output_file}</p>`;
                    }
                    
                    statusContent.innerHTML = html;
                    
                    // Stop polling if completed or error
                    if (status.status === 'completed' || status.status === 'error') {
                        clearInterval(interval);
                    }
                    
                } catch (error) {
                    clearInterval(interval);
                    statusContent.innerHTML += `<p class="error">Status check failed: ${error.message}</p>`;
                }
            }, 1000); // Poll every second
        }

        // Load initial files
        loadFiles('tab1');
    </script>
</body>
</html>
