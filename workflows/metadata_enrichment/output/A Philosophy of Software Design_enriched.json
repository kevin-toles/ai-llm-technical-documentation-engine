{
  "book": "A Philosophy of Software Design",
  "enrichment_metadata": {
    "generated": "2025-11-28T17:48:18.414759",
    "method": "statistical",
    "libraries": {
      "yake": "0.4.8",
      "summa": "1.2.0",
      "scikit-learn": "1.3.2"
    },
    "corpus_size": 25,
    "total_chapters_analyzed": 656
  },
  "chapters": [
    {
      "chapter_number": 1,
      "title": "Segment 1 (pages 2-9)",
      "start_page": 2,
      "end_page": 9,
      "summary": "A Philosophy of Software Design by John Ousterhout\n4.3 Abstractions 4.4 Deep modules 4.5 Shallow modules 4.6 Classitis 4.7 Examples: Java and Unix I/O 4.8 Conclusion\n5.1 Information hiding 5.2 Information leakage 5.3 Temporal decomposition 5.4 Example: HTTP server 5.5 Example: too many classes 5.6 Example: HTTP parameter handling 5.7 Example: defaults in HTTP responses 5.8 Information hiding within a class 5.9 Taking it too far 5.10 Conclusion\n6.1 Make classes somewhat general-purpose 6.2 Example: storing text for an editor 6.3 A more general-purpose API 6.4 Generality leads to better information hiding 6.5 Questions to ask yourself 6.6 Conclusion\n8.1 Example: editor text class 8.2 Example: configuration parameters 8.3 Taking it too far 8.4 Conclusion\n9.1 Bring together if information is shared 9.2 Bring together if it will simplify the interface 9.3 Bring together to eliminate duplication 9.4 Separate general-purpose and special-purpose code 9.5 Example: insertion cursor and selection 9.6 Example: separate class for logging 9.7 Example: editor undo mechanism 9.8 Splitting and joining methods 9.9 Conclusion\n10.9 Design special cases out of existence 10.10 Taking it too far 10.11 Conclusion\n13.1 Pick conventions 13.2 Don’t repeat the code 13.3 Lower-level comments add precision 13.4 Higher-level comments enhance intuition 13.5 Interface documentation 13.6 Implementation comments: what and why, not how 13.7 Cross-module design decisions 13.8 Conclusion 13.9 Answers to questions from Section 13.5\n14.1 Example: bad names cause bugs 14.2 Create an image 14.3 Names should be precise 14.4 Use names consistently 14.5 A different opinion: Go style guide 14.6 Conclusion\n17.1 Examples of consistency 17.2 Ensuring consistency 17.3 Taking it too far 17.4 Conclusion\n19.1 Object-oriented programming and inheritance 19.2 Agile development 19.3 Unit tests 19.4 Test-driven development 19.5 Design patterns 19.6 Getters and setters 19.7 Conclusion\n20 Designing for Performance\n20.1 How to think about performance 20.2 Measure before modifying 20.3 Design around the critical path 20.4 An example: RAMCloud Buffers 20.5 Conclusion\nWe teach for loops and object-oriented programming, but not software design.\nMany people assume that software design skill is an innate talent that cannot be taught.",
      "keywords": [
        "John Ousterhout Copyright",
        "John Ousterhout",
        "Ousterhout Copyright",
        "Conclusion",
        "Comments",
        "John K. Ousterhout",
        "Design",
        "John",
        "Ousterhout",
        "Code",
        "Software Design",
        "Maintaining comments",
        "Information Hiding",
        "Conclusion Index Summary",
        "Complexity"
      ],
      "concepts": [
        "conclusion",
        "examples",
        "comments",
        "design",
        "designing",
        "code",
        "modules",
        "programming",
        "programs",
        "interface"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 1,
          "title": "Segment 1 (pages 2-9)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "John Ousterhout Ousterhout",
          "score": 0.001,
          "source": "cross_book_yake"
        },
        {
          "term": "Ousterhout Design John",
          "score": 0.001,
          "source": "cross_book_yake"
        },
        {
          "term": "Design John Ousterhout",
          "score": 0.001,
          "source": "cross_book_yake"
        },
        {
          "term": "Ousterhout Copyright Conclusion",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "Ousterhout Ousterhout Copyright",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "John Ousterhout Copyright",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "Ousterhout Copyright John",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "Copyright John Ousterhout",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "John Ousterhout",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "Information Hiding Conclusion",
          "score": 0.002,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "examples",
          "source": "cross_book_summa"
        },
        {
          "concept": "conclusion",
          "source": "cross_book_summa"
        },
        {
          "concept": "design",
          "source": "cross_book_summa"
        },
        {
          "concept": "designing",
          "source": "cross_book_summa"
        },
        {
          "concept": "comments",
          "source": "cross_book_summa"
        },
        {
          "concept": "modules",
          "source": "cross_book_summa"
        },
        {
          "concept": "information",
          "source": "cross_book_summa"
        },
        {
          "concept": "names",
          "source": "cross_book_summa"
        },
        {
          "concept": "classes",
          "source": "cross_book_summa"
        },
        {
          "concept": "code",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 2,
      "title": "Segment 2 (pages 10-17)",
      "start_page": 10,
      "end_page": 17,
      "summary": "In this class I put forth a set of principles of software design.\nThis allows students to see how their code can be improved by applying design principles.\nI have now taught the software design class three times, and this book is based on the design principles that emerged from the class.\nThere were no classes on software design when I learned to program, and I never had a mentor to teach me design principles.\nMy ideas about software design come from personal experience writing and reading code.\nI don’t expect this book to be the final word on software design; I’m sure there are valuable techniques that I’ve missed, and some of my suggestions may turn out to be bad ideas in the long run.\nHowever, I hope that the book will start a conversation about software design.\nCompare the ideas in this book with your own experiences and decide for yourself whether the approaches described here really do reduce software complexity.\nI’m interested in hearing about things that work for you, things that don’t work, and any other ideas you may have about software design.\nsoftware-design-book@googlegroups.com\nI’m interested in hearing specific feedback about the book, such as bugs or suggestions for improvement, as well as general thoughts and experiences related to software design.\nIf you would like to see what other people are saying on the email address and participate in discussions, you can join the Google Group software-design-book.\nIf for some reason the software-design-book Google Group should disappear in the future, search on the Web for my home page; it will contain\nIn modular design, a software system is divided up into modules, such as classes in an object-oriented language.\nHowever, software design has not always been viewed this way.\nSoftware systems are intrinsically more complex than physical systems; it isn’t possible to visualize the design for a large software system well enough to understand all of its implications before building anything.\nBecause of these issues, most software development projects today use an incremental approach such as agile development, in which the initial design focuses on a small subset of the overall functionality.\nThe incremental approach works for software because software is malleable enough to allow significant design changes partway through implementation.\nIncremental development means that software design is never done.\nAs a software developer, you should always be on the lookout for opportunities to improve the design of the system you are working on, and you should plan on spending some fraction of your time on design improvements.\nIf software developers should always be thinking about design issues, and reducing complexity is the most important element of software design, then software developers should always be thinking about complexity.\nThis book is about how to use complexity to guide the design of software throughout its lifetime.\nThe book’s second, and more challenging, goal is to present techniques you can use during the software development process to minimize complexity.\nReviewing code will also expose you to new design approaches and programming techniques.\nOne of the best ways to improve your design skills is to learn to recognize red flags: signs that a piece of code is probably more complicated than it needs to be.\nOver the course of this book I will point out red flags that suggest problems related to each major design issue; the most important ones are summarized at the back of the book.\nYou can then use these when you are coding: when you see a red flag, stop and look for an alternate design that eliminates the problem.\nAlmost all of the examples in this book are in Java or C++, and much of the discussion is in terms of designing classes in an object-oriented language.",
      "keywords": [
        "design",
        "software design",
        "software",
        "book",
        "complexity",
        "code",
        "design principles",
        "problems",
        "systems",
        "system",
        "software system",
        "design problems",
        "n’t",
        "software design class",
        "ideas"
      ],
      "concepts": [
        "designs",
        "designed",
        "designers",
        "designing",
        "complexity",
        "complex",
        "code",
        "coding",
        "systems",
        "develop"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 2,
          "title": "Segment 2 (pages 10-17)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "software design",
          "score": 0.004,
          "source": "cross_book_yake"
        },
        {
          "term": "design",
          "score": 0.005,
          "source": "cross_book_yake"
        },
        {
          "term": "software",
          "score": 0.006,
          "source": "cross_book_yake"
        },
        {
          "term": "software design software",
          "score": 0.019,
          "source": "cross_book_yake"
        },
        {
          "term": "book",
          "score": 0.019,
          "source": "cross_book_yake"
        },
        {
          "term": "design software design",
          "score": 0.02,
          "source": "cross_book_yake"
        },
        {
          "term": "software design class",
          "score": 0.025,
          "source": "cross_book_yake"
        },
        {
          "term": "design software",
          "score": 0.027,
          "source": "cross_book_yake"
        },
        {
          "term": "design principles",
          "score": 0.029,
          "source": "cross_book_yake"
        },
        {
          "term": "design software book",
          "score": 0.029,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "design",
          "source": "cross_book_summa"
        },
        {
          "concept": "designing",
          "source": "cross_book_summa"
        },
        {
          "concept": "development",
          "source": "cross_book_summa"
        },
        {
          "concept": "developer",
          "source": "cross_book_summa"
        },
        {
          "concept": "developers",
          "source": "cross_book_summa"
        },
        {
          "concept": "develop",
          "source": "cross_book_summa"
        },
        {
          "concept": "software",
          "source": "cross_book_summa"
        },
        {
          "concept": "complexity",
          "source": "cross_book_summa"
        },
        {
          "concept": "complex",
          "source": "cross_book_summa"
        },
        {
          "concept": "problems",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 3,
      "title": "Segment 3 (pages 18-26)",
      "start_page": 18,
      "end_page": 26,
      "summary": "This book is about how to design software systems to minimize their complexity.\nOver time, you will notice that certain techniques tend to result in simpler designs, while others correlate with complexity.\nComplexity is anything related to the structure of a software system that makes it hard to understand and modify the system.\nComplexity\nFor example, it might be hard to understand how a piece of code works; it might take a lot of effort to implement a small improvement, or it might not be clear which parts of the system must be modified to make the improvement; it might be difficult to fix one bug without introducing another.\nOf course, almost all large and sophisticated software systems are in fact hard to work on, so they also meet my definition of complexity, but this need not necessarily be the case.\nThe overall complexity of a system (C) is determined by the complexity of each part p (cp) weighted by the fraction of time developers spend working on that part (tp).\nWhen you find yourself in situations like this, it’s worth probing the other developers to find out why the code seems complex to\nChange amplification: The first symptom of complexity is that a seemingly simple change requires code modifications in many different places.\nIn order to change the background for such a Web site, a developer might have to modify every existing page by hand; this would be nearly impossible for a large site with thousands of pages.\nFortunately, modern Web sites use an approach like that in Figure 2.1(b), where the banner color is specified once in a central place, and all of the individual pages reference that shared value.\nCognitive load: The second symptom of complexity is cognitive load, which refers to how much a developer needs to know in order to complete a task.\nSystem designers sometimes assume that complexity can be measured by lines of code.\nUnknown unknowns: The third symptom of complexity is that it is not obvious which pieces of code must be modified to complete a task, or what information a developer must have to carry out the task successfully.\nThe Web site uses a central variable to determine the banner background color, so it appears to be easy to change.\nEven if a developer is aware of the problem, it won’t be obvious which pages use the emphasis color, so the developer may have to search every page in the Web site.\nIn an obvious system, a developer can quickly understand how the existing code works and what is required to make a change.\nNow that you know the high-level symptoms of complexity and why complexity makes software development difficult, the next step is to understand what causes complexity, so that we can design systems to avoid the problems.\nComplexity is caused by two things: dependencies and obscurity.\nFor the purposes of this book, a dependency exists when a given piece of code cannot be understood and modified in isolation; the code relates in some way to other code, and the other code must be considered and/or modified if the given code is changed.\nIn the Web site example of Figure 2.1(a), the background color creates dependencies between all of the pages.\nHowever, one of the goals of software design is to reduce the number of dependencies and to make the dependencies that remain as simple and obvious as possible.\nThe new Web site fixed this problem by specifying the background color in a central place and providing an API that individual pages use to retrieve that color when they are rendered.\nThe new Web site eliminated the dependency between the pages, but it created a new the background color.\ndependency around Fortunately, the new dependency is more obvious: it is clear that each individual Web page depends on the bannerBg color, and a developer can easily find all the places where the variable is used by searching for its name.\nIf we can find design techniques that minimize dependencies and obscurity, then we can reduce the complexity of software.\nComplexity comes about because hundreds or thousands of small dependencies and obscurities build up over time.\nHowever, if every developer takes this approach for every change, complexity accumulates rapidly.\nOnce complexity has accumulated, it is hard to eliminate, since fixing a single dependency or obscurity will not, by itself, make a big difference.\nComplexity comes from an accumulation of dependencies and obscurities.\nAs complexity increases, it leads to change amplification, a high cognitive load, and unknown unknowns.\nThe bottom line is that complexity makes it difficult and risky to modify an existing code base.",
      "keywords": [
        "Complexity",
        "Web site",
        "code",
        "system",
        "Web",
        "design",
        "Change",
        "color",
        "background color",
        "Cognitive load",
        "background",
        "dependencies",
        "n’t",
        "developer",
        "pages"
      ],
      "concepts": [
        "complexity",
        "complex",
        "designs",
        "designers",
        "dependencies",
        "depend",
        "dependency",
        "dependent",
        "depends",
        "change"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 3,
          "title": "Segment 3 (pages 18-26)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "Web site",
          "score": 0.006,
          "source": "cross_book_yake"
        },
        {
          "term": "complexity",
          "score": 0.006,
          "source": "cross_book_yake"
        },
        {
          "term": "Web",
          "score": 0.009,
          "source": "cross_book_yake"
        },
        {
          "term": "Complexity Web site",
          "score": 0.014,
          "source": "cross_book_yake"
        },
        {
          "term": "code",
          "score": 0.015,
          "source": "cross_book_yake"
        },
        {
          "term": "code system Web",
          "score": 0.02,
          "source": "cross_book_yake"
        },
        {
          "term": "Web site code",
          "score": 0.02,
          "source": "cross_book_yake"
        },
        {
          "term": "Change",
          "score": 0.023,
          "source": "cross_book_yake"
        },
        {
          "term": "color",
          "score": 0.023,
          "source": "cross_book_yake"
        },
        {
          "term": "developer",
          "score": 0.024,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "complexity",
          "source": "cross_book_summa"
        },
        {
          "concept": "complex",
          "source": "cross_book_summa"
        },
        {
          "concept": "dependencies",
          "source": "cross_book_summa"
        },
        {
          "concept": "dependency",
          "source": "cross_book_summa"
        },
        {
          "concept": "depends",
          "source": "cross_book_summa"
        },
        {
          "concept": "depend",
          "source": "cross_book_summa"
        },
        {
          "concept": "dependent",
          "source": "cross_book_summa"
        },
        {
          "concept": "pages",
          "source": "cross_book_summa"
        },
        {
          "concept": "code",
          "source": "cross_book_summa"
        },
        {
          "concept": "developers",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 4,
      "title": "Segment 4 (pages 27-35)",
      "start_page": 27,
      "end_page": 35,
      "summary": "There’s no way your schedule can tolerate that kind of delay, and fixing one or two of the problems doesn’t seem like it will make much difference, so you just keep programming tactically.\nIf you have worked on a large software project for very long, I suspect you have seen tactical programming at work and have experienced the problems that result.\nThe first step towards becoming a good software designer is to realize that working code isn’t enough.\nRather than taking the fastest path to finish your current project, you must invest time to improve the design of the system.\nFor example, it’s worth taking a little extra time to find a simple design for each new class; rather than implementing the first idea that comes to mind, try a couple of alternative designs and pick the cleanest one.\nIf you program strategically, you will continually make small improvements to the system design.\nThis is the opposite of tactical programming, where you are continually adding small bits of complexity that cause problems in the future.\nIt won’t be long before you’re developing at least 10–20% faster than you would if you had programmed tactically.\nFigure 3.1: At the beginning, a tactical approach to programming will make progress more quickly than a strategic approach.\nConversely, if you program tactically, you will finish your first projects 10–20% faster, but over time your development speed will slow as complexity accumulates.\nAs a result, many startups take a tactical approach, spending little effort on design and even less on cleanup when problems pop up.\nFurthermore, the payoff for good (or bad) design comes pretty quickly, so there’s a good chance that the tactical approach won’t even speed up your first product release.\nFacebook has been spectacularly successful as a company, but its code base suffered because of the company’s tactical approach; much of the code\nEventually, Facebook changed its motto to “Move fast with solid infrastructure” to encourage its engineers to invest more in good design.\nIt remains to be seen whether Facebook can successfully clean up the problems that accumulated over years of tactical programming.\nBoth companies placed a heavy emphasis on high quality code and good design, and both companies built sophisticated products that solved complex problems with reliable software systems.\nHowever, it’s a lot more fun to work in a company that cares about software design and has a clean code base.\nOnce you start delaying design improvements, it’s easy for the delays to become permanent and for your culture to slip into the tactical approach.\nThe most effective approach is one where every engineer makes continuous small investments in good design.\nOne of the most important techniques for managing software complexity is to design systems so that developers only need to face a small fraction of the overall complexity at any given time.\nIn modular design, a software system is decomposed into a collection of modules that are relatively independent.\nIn an ideal world, each module would be completely independent of the others: a developer could work in any of the modules without knowing anything about any of the other modules.\nThe goal of modular design is to minimize the dependencies between modules.\nIn order to manage dependencies, we think of each module in two parts: an interface and an implementation.\nThe interface consists of everything that a developer working in a different module must know in order to use\nA developer working in a particular module must understand the interface and implementation of that module, plus the interfaces of any other modules invoked by the given module.\nA developer should not need to understand the implementations of modules other than the one he or she is working in.\nFor the purposes of this book, a module is any unit of code that has an interface and an implementation.\nMethods within a class, or functions in a language that isn’t object-oriented, can also be thought of as modules: each of these has an interface and an implementation, and modular design techniques can be applied to them.\nThe best modules are those whose interfaces are much simpler than their implementations.\nFirst, a simple interface minimizes the complexity that a module imposes on the rest of the system.\nIn general, if a developer needs to know a particular piece of information in order to use a module, then that information is part of the module’s interface.\nOne of the benefits of a clearly specified interface is that it indicates exactly what developers need to know in order to use the associated module.",
      "keywords": [
        "design",
        "module",
        "code",
        "tactical",
        "interface",
        "Modules",
        "tactical approach",
        "programming",
        "tactical programming",
        "approach",
        "n’t",
        "strategic approach",
        "good design",
        "modular design",
        "time"
      ],
      "concepts": [
        "modules",
        "module",
        "designer",
        "design",
        "designs",
        "designing",
        "tactically",
        "tactical",
        "development",
        "developer"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 4,
          "title": "Segment 4 (pages 27-35)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "design",
          "score": 0.01,
          "source": "cross_book_yake"
        },
        {
          "term": "module",
          "score": 0.013,
          "source": "cross_book_yake"
        },
        {
          "term": "tactical",
          "score": 0.016,
          "source": "cross_book_yake"
        },
        {
          "term": "modules",
          "score": 0.017,
          "source": "cross_book_yake"
        },
        {
          "term": "tactical approach",
          "score": 0.017,
          "source": "cross_book_yake"
        },
        {
          "term": "approach",
          "score": 0.022,
          "source": "cross_book_yake"
        },
        {
          "term": "interface",
          "score": 0.024,
          "source": "cross_book_yake"
        },
        {
          "term": "good design",
          "score": 0.026,
          "source": "cross_book_yake"
        },
        {
          "term": "tactical programming",
          "score": 0.03,
          "source": "cross_book_yake"
        },
        {
          "term": "modular design",
          "score": 0.034,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "designer",
          "source": "cross_book_summa"
        },
        {
          "concept": "design",
          "source": "cross_book_summa"
        },
        {
          "concept": "designs",
          "source": "cross_book_summa"
        },
        {
          "concept": "designing",
          "source": "cross_book_summa"
        },
        {
          "concept": "modules",
          "source": "cross_book_summa"
        },
        {
          "concept": "module",
          "source": "cross_book_summa"
        },
        {
          "concept": "approach",
          "source": "cross_book_summa"
        },
        {
          "concept": "code",
          "source": "cross_book_summa"
        },
        {
          "concept": "tactically",
          "source": "cross_book_summa"
        },
        {
          "concept": "tactical",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 5,
      "title": "Segment 5 (pages 36-43)",
      "start_page": 36,
      "end_page": 43,
      "summary": "In modular programming, each module provides an abstraction in form of its interface.\nThe interface presents a simplified view of the module’s functionality; the details of the implementation are unimportant from the standpoint of the module’s abstraction, so they are omitted from the interface.\nThe abstraction provided by a file system omits many details, such as the mechanism for choosing which blocks on a storage device to use for the data in a given file.\nThe best modules are those that provide powerful functionality yet have simple interfaces.\nThe top edge of a rectangle represents the module’s interface; the length of that edge indicates the complexity of the interface.\nThe best modules are deep: they have a lot of functionality hidden behind a simple interface.\nA deep module is a good abstraction because only a small fraction of its internal complexity is visible to its users.\nThe best modules are deep: they allow a lot of functionality to be accessed through a simple interface.\nA shallow module is one with a relatively complex interface, but not much functionality: it doesn’t hide much complexity.\nThe benefit provided by a module is its functionality.\nThe cost of a module (in terms of system complexity) is its interface.\nA module’s interface represents the complexity that the module imposes on the rest of the system: the smaller and simpler the interface, the less complexity that it introduces.\nThe mechanism for file I/O provided by the Unix operating system and its descendants, such as Linux, is a beautiful example of a deep interface.\nThe other arguments for open provide optional information such as whether the file is being opened for reading or writing, whether a new file should be created if there is no existing file, and access permissions for the file, if a new file is created.\nDeep modules such as Unix I/O and garbage collectors provide powerful abstractions because they are easy to use, yet they hide significant implementation complexity.\nOn the other hand, a shallow module is one whose interface is relatively complex in comparison to the functionality that it provides.\nThe method offers no abstraction, since all of its functionality is visible through its interface.\nThe method adds complexity (in the form of a new interface for developers to learn) but provides no compensating benefit.\nA shallow module is one whose interface is complicated relative to the functionality it provides.\nShallow modules don’t help much in the battle against complexity, because the benefit they provide (not having to learn about how they work internally) is negated by the cost of learning and using their interfaces.\nAlmost every user of file I/O will want buffering, so it should be provided by default.\nseparated in the interface (for example, by providing a different constructor for FileInputStream, or through a method that disables or replaces the buffering mechanism), so that most developers do not even need to be aware of its existence.\nBy separating the interface of a module from its implementation, we can hide the complexity of the implementation from the rest of the system.\nUsers of a module need only understand the abstraction provided by its interface.\nThe most important issue in designing classes and other modules is to make them deep, so that they have simple interfaces for the common use cases, yet still provide significant functionality.\nThe most important technique for achieving deep modules is information hiding.\nThe knowledge is embedded in the module’s implementation but does not appear in its interface, so it is not visible to other modules.\nThe information hidden within a module usually consists of details about how to implement some mechanism.\nHere are some examples of information that might be hidden within a module:\nFirst, it simplifies the interface to a module.\nThe interface reflects a simpler, more abstract view of the module’s functionality and hides the details; this reduces the",
      "keywords": [
        "interface",
        "module",
        "file",
        "system",
        "file system",
        "abstraction",
        "modules",
        "complexity",
        "Deep modules",
        "shallow module",
        "Deep",
        "functionality",
        "Unix file system",
        "details",
        "classes"
      ],
      "concepts": [
        "interface",
        "interfaces",
        "file",
        "files",
        "complex",
        "complexity",
        "provided",
        "provide",
        "providing",
        "accessed"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 5,
          "title": "Segment 5 (pages 36-43)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "module",
          "score": 0.006,
          "source": "cross_book_yake"
        },
        {
          "term": "interface",
          "score": 0.006,
          "source": "cross_book_yake"
        },
        {
          "term": "modules",
          "score": 0.012,
          "source": "cross_book_yake"
        },
        {
          "term": "Deep modules",
          "score": 0.016,
          "source": "cross_book_yake"
        },
        {
          "term": "file",
          "score": 0.016,
          "source": "cross_book_yake"
        },
        {
          "term": "functionality",
          "score": 0.018,
          "source": "cross_book_yake"
        },
        {
          "term": "complexity",
          "score": 0.018,
          "source": "cross_book_yake"
        },
        {
          "term": "deep",
          "score": 0.02,
          "source": "cross_book_yake"
        },
        {
          "term": "interface module file",
          "score": 0.021,
          "source": "cross_book_yake"
        },
        {
          "term": "shallow module",
          "score": 0.022,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "provided",
          "source": "cross_book_summa"
        },
        {
          "concept": "provide",
          "source": "cross_book_summa"
        },
        {
          "concept": "providing",
          "source": "cross_book_summa"
        },
        {
          "concept": "modules",
          "source": "cross_book_summa"
        },
        {
          "concept": "interface",
          "source": "cross_book_summa"
        },
        {
          "concept": "interfaces",
          "source": "cross_book_summa"
        },
        {
          "concept": "complexity",
          "source": "cross_book_summa"
        },
        {
          "concept": "complex",
          "source": "cross_book_summa"
        },
        {
          "concept": "file",
          "source": "cross_book_summa"
        },
        {
          "concept": "files",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 6,
      "title": "Segment 6 (pages 44-51)",
      "start_page": 44,
      "end_page": 51,
      "summary": "Note: hiding variables and methods in a class by declaring them private isn’t the same thing as information hiding.\nPrivate elements can help with information hiding, since they make it impossible for the items to be accessed directly from outside the class.\nFor example, if a particular feature or piece of information is only needed by a few of a class’s users, and it is accessed through separate methods so that it isn’t visible in the most common use cases, then that information is mostly hidden.\nEven if neither class exposes that information in its interface, they both depend on the file format: if the format changes, both classes will need to be modified.\nIf you encounter information leakage between classes, ask yourself “How can I reorganize these classes so that this particular piece of knowledge only affects a single class?” If the affected classes are relatively small and closely tied to the leaked information, it may make sense to merge them into a single class.\nInformation leakage occurs when the same knowledge is used in multiple places, such as two different classes that both understand the format of a particular type of file.\nHowever, most design decisions manifest themselves at several different times over the life of the application; as a result, temporal decomposition often results in information leakage.\nTo illustrate the issues in information hiding, let’s consider the design decisions made by students implementing the HTTP protocol in a software\nThe students in the course were asked to implement one or more classes to make it easy for Web servers to receive incoming HTTP requests and send responses.\nThe initial line contains the request type (POST is used for submitting form data), a URL indicating an operation (/comments/create) and optional parameters (photo_id has the value 246), and the HTTP protocol version used by the sender.\nThe most common mistake made by students was to divide their code into a large number of shallow classes, which led to information leakage between the classes.\nOne team used two different classes for receiving HTTP requests; the first class read the request from the network connection into a string, and the second class parsed the string.\nInformation leakage occurred because an HTTP request can’t be read without parsing much of the message; for example, the Content-Length\nAs a result, both classes needed to understand most of the structure of HTTP requests, and parsing code was duplicated in both classes.\nThis approach also created extra complexity for callers, who had to invoke two methods in different classes, in a particular order, to receive a request.\nBecause the classes shared so much information, it would have been better to merge them into a single class that handles both request reading and parsing.\nThis provides better information hiding, since it isolates all knowledge of the request format in one class, and it also provides a simpler interface to callers (just one method to invoke).\nin software design: information hiding can often be improved by making a class slightly larger.\nOne reason for doing this is to bring together all of the code related to a particular capability (such as parsing an HTTP request), so that the resulting class contains everything related to that capability.\nBoth of these benefits apply in the example of the previous paragraph: combining the classes brings together all of the code related to parsing an HTTP request, and it replaces two externally-visible methods with one.\nAfter an HTTP request has been received by a server, the server needs to access some of the information from the request.\nIn both of these cases, information hiding resulted in simpler APIs for the code using the HTTP module.\nHowever, most of the students used an interface for returning parameters that was too shallow, and this resulted in lost opportunities for information hiding.\nMost projects used an object of type HTTPRequest to hold the parsed HTTP request, and the HTTPRequest class had a single method like the following one to return parameters: public Map<String, String> getParams() { return this.params; }\nThe caller is unlikely to know what version to specify, and if the caller does specify a value, it probably results in information leakage between the HTTP library and the caller.\n5.8 Information hiding within a class\nThe examples in this chapter focused on information hiding as it relates to the externally visible APIs for classes, but information hiding can also be applied at other levels in the system, such as within a class.\nTry to design the private methods within a class so that each method encapsulates some information or capability and hides it from the rest of the class.",
      "keywords": [
        "information",
        "information hiding",
        "Information leakage",
        "HTTP request",
        "Information Leakage Information",
        "request",
        "classes",
        "leakage",
        "HTTP protocol",
        "hiding",
        "Leakage Information leakage",
        "HTTP responses",
        "module",
        "parameter",
        "Information leakage occurs"
      ],
      "concepts": [
        "classes",
        "parameters",
        "parameter",
        "methods",
        "method",
        "request",
        "requests",
        "requested",
        "interface",
        "interfaces"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 6,
          "title": "Segment 6 (pages 44-51)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "Information leakage HTTP",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "information leakage",
          "score": 0.003,
          "source": "cross_book_yake"
        },
        {
          "term": "information",
          "score": 0.003,
          "source": "cross_book_yake"
        },
        {
          "term": "information hiding",
          "score": 0.003,
          "source": "cross_book_yake"
        },
        {
          "term": "HTTP request",
          "score": 0.004,
          "source": "cross_book_yake"
        },
        {
          "term": "HTTP request Information",
          "score": 0.005,
          "source": "cross_book_yake"
        },
        {
          "term": "Information Leakage Information",
          "score": 0.006,
          "source": "cross_book_yake"
        },
        {
          "term": "leakage HTTP",
          "score": 0.007,
          "source": "cross_book_yake"
        },
        {
          "term": "information information hiding",
          "score": 0.007,
          "source": "cross_book_yake"
        },
        {
          "term": "information hiding Information",
          "score": 0.007,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "classes",
          "source": "cross_book_summa"
        },
        {
          "concept": "information",
          "source": "cross_book_summa"
        },
        {
          "concept": "hiding",
          "source": "cross_book_summa"
        },
        {
          "concept": "hides",
          "source": "cross_book_summa"
        },
        {
          "concept": "methods",
          "source": "cross_book_summa"
        },
        {
          "concept": "method",
          "source": "cross_book_summa"
        },
        {
          "concept": "parameters",
          "source": "cross_book_summa"
        },
        {
          "concept": "parameter",
          "source": "cross_book_summa"
        },
        {
          "concept": "particular",
          "source": "cross_book_summa"
        },
        {
          "concept": "requests",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 7,
      "title": "Segment 7 (pages 52-59)",
      "start_page": 52,
      "end_page": 59,
      "summary": "Many of the student teams implemented special-purpose APIs for the text class.\nKnowing this, some of the teams created one method in the text class to support each of these specific features: void backspace(Cursor cursor);\nThe students probably thought that it would be easier to implement the user interface if the methods of the text class corresponded to the features visible to users.\nIn reality, however, this specialization provided little benefit for the user interface code, and it created a high cognitive load for developers working on either the user interface or the text class.\nThe text class ended up with a large number of shallow methods, each of which was only suitable for one user interface operation.\nAs a result, a developer working on the user interface had to learn about a large number of methods for the text class.\nThis approach created information leakage between the user interface and the text class.\nAbstractions related to the user interface, such as the selection or the backspace key, were reflected in the text class; this increased the cognitive load for developers working on the text class.\nEach new user interface operation required a new method to be defined in the text class, so a developer working on the user interface was likely to end up working on the text class as well.\nOne of the goals in class design is to allow each class to be developed independently, but the specialized approach tied the user interface and text classes together.\nThe text class should also provide general-purpose facilities for manipulating positions within the text, such as the following: Position changePosition(Position position, int numChars);\nWith the general-purpose text API, the code to implement user interface functions such as delete and backspace is a bit longer than with the original approach using a specialized text API.\nFurthermore, the general-purpose approach has less code overall than the specialized approach, since it replaces a large number of special-purpose methods in the text class with a smaller number of general-purpose ones.\nA text class implemented with the general-purpose interface could potentially be used for other purposes besides an interactive editor.\nMethods from the specialized text class, such as backspace and delete, would have little value for this application.\nHowever, the general- purpose text class would already have most of the functionality needed for the new application.\nThe general-purpose approach provides a cleaner separation between the text and user interface classes, which results in better information hiding.\nThe text class need not be aware of specifics of the user interface, such as how the backspace key is handled; these details are now encapsulated in the user interface class.\nNew user interface features can be added without creating new supporting functions in the text class.\nThe general-purpose interface also reduces cognitive load: a developer working on the user interface only needs to learn a few simple methods, which can be reused for a variety of purposes.\nIt purported to hide information about which characters are deleted, but the user interface module really needs to know this; user interface developers are likely to read the code of the backspace method in order to confirm its precise behavior.\nPutting the method in the text class just makes it harder for user interface developers to get the information they need.\nThe special-purpose text API had at least three methods for deleting text: backspace, delete, and deleteSelection.\nThe more general-purpose API had only one method for deleting text, which served all three purposes.",
      "keywords": [
        "text class",
        "text",
        "user interface",
        "interface",
        "General-Purpose",
        "module",
        "position",
        "user",
        "user interface module",
        "methods",
        "method",
        "API",
        "text API",
        "general-purpose text API",
        "cursor"
      ],
      "concepts": [
        "methods",
        "method",
        "purpose",
        "purposes",
        "text",
        "position",
        "positions",
        "positive",
        "module",
        "modules"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 7,
          "title": "Segment 7 (pages 52-59)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        },
        {
          "book": "A Philosophy of Software Design",
          "chapter": 10,
          "title": "Segment 10 (pages 77-87)",
          "relevance_score": 0.75,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "text class",
          "score": 0.001,
          "source": "cross_book_yake"
        },
        {
          "term": "user interface",
          "score": 0.001,
          "source": "cross_book_yake"
        },
        {
          "term": "text",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "text API",
          "score": 0.004,
          "source": "cross_book_yake"
        },
        {
          "term": "interface",
          "score": 0.005,
          "source": "cross_book_yake"
        },
        {
          "term": "user",
          "score": 0.005,
          "source": "cross_book_yake"
        },
        {
          "term": "API text API",
          "score": 0.005,
          "source": "cross_book_yake"
        },
        {
          "term": "general-purpose text API",
          "score": 0.005,
          "source": "cross_book_yake"
        },
        {
          "term": "text class text",
          "score": 0.006,
          "source": "cross_book_yake"
        },
        {
          "term": "user interface code",
          "score": 0.006,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "method",
          "source": "cross_book_summa"
        },
        {
          "concept": "methods",
          "source": "cross_book_summa"
        },
        {
          "concept": "classes",
          "source": "cross_book_summa"
        },
        {
          "concept": "undo",
          "source": "cross_book_summa"
        },
        {
          "concept": "undos",
          "source": "cross_book_summa"
        },
        {
          "concept": "undoing",
          "source": "cross_book_summa"
        },
        {
          "concept": "text",
          "source": "cross_book_summa"
        },
        {
          "concept": "code",
          "source": "cross_book_summa"
        },
        {
          "concept": "purposes",
          "source": "cross_book_summa"
        },
        {
          "concept": "purpose",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 8,
      "title": "Segment 8 (pages 60-67)",
      "start_page": 60,
      "end_page": 67,
      "summary": "7.1 Pass-through methods\nWhen adjacent layers have similar abstractions, the problem often manifests itself in the form of pass-through methods.\nFor example, a student project implementing a GUI text editor contained a class consisting almost entirely of pass-through methods.\n13 of the 15 public methods in that class were pass-through methods.\nPass-through methods make classes shallower: they increase the interface complexity of the class, which adds complexity, but they don’t increase the total functionality of the system.\nPass-through methods also create dependencies between classes: if the signature changes for the insertString method in TextArea, then the insertString method in TextDocument will have to change to match.\nPass-through methods indicate that there is confusion over the division of responsibility between classes.\nIn the example above, the TextDocument class offers an insertString method, but the functionality for inserting text is implemented entirely in TextArea.\nWhen you see pass-through methods from one class to another, consider the two classes and ask yourself “Exactly which features and abstractions is each of these classes responsible for?” You will probably notice that there is an overlap in responsibility between the classes.\nThe student eliminated the pass-through methods by moving methods between classes and collapsing the three classes into just two, whose responsibilities were more clearly differentiated.\nPass-through methods are bad because they contribute no new functionality.\nA dispatcher is a method that uses its arguments to select one of several other methods to invoke; then it passes most or all of its arguments to the chosen method.\nFigure 7.1: Pass-through methods.\nIn (a), class C1 contains three pass-through methods, which do nothing but invoke methods with the same signature in C2 (each symbol represents a particular method signature).\nThe pass-through methods can be eliminated by having C1’s callers invoke C2 directly as in (b), by redistributing functionality between C1 and C2 to avoid calls between the classes as in (c), or by combining the classes as in (d).\nA decorator object takes an existing object and extends its functionality; it provides an API similar or identical to the underlying object, and its methods invoke the methods of the the underlying object.\nDecorator classes often contain many pass-through\nThe text classes were much easier to use when they provided a character-oriented interface, such as an insert method that inserts an arbitrary string of text (which may include newlines) at an arbitrary position in the text and a delete method that deletes the text between two arbitrary positions in the text.\nAnother form of API duplication across layers is a pass-through variable, which is a variable that is passed down through a long chain of methods.\nPass-through variables add complexity because they force all of the intermediate methods to be aware of their existence, even though the methods have no use for the variables.\nFurthermore, if a new variable comes into existence (for example, a system is initially built without support for certificates, but you later decide to add that support), you may have to modify a large number of interfaces and methods to pass the variable through all of the relevant paths.\nIf so, main can store the certificate information in that object, so it needn’t be passed through all of the intervening methods on the path to m3 (see Figure 7.2(b)).\nThis avoids the need to pass the information from method to method, but global variables almost always create other problems.\nIn the example of Figure 7.2(d), the class containing m3 stores a reference to the context as an instance variable in its objects.\nWhen a new object is created, the creating method retrieves the context reference from its object and passes it to the constructor for the new object.",
      "keywords": [
        "Pass-through methods",
        "methods",
        "erent Abstraction Software",
        "method",
        "Pass-through",
        "Abstraction Software systems",
        "functionality",
        "classes",
        "text",
        "Abstraction Software",
        "text class",
        "interface",
        "pass-through variable",
        "layers",
        "object"
      ],
      "concepts": [
        "methods",
        "method",
        "classes",
        "variable",
        "variables",
        "layer",
        "layers",
        "functionality",
        "interface",
        "interfaces"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 8,
          "title": "Segment 8 (pages 60-67)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "Pass-through methods",
          "score": 0.003,
          "source": "cross_book_yake"
        },
        {
          "term": "methods",
          "score": 0.005,
          "source": "cross_book_yake"
        },
        {
          "term": "Pass-through",
          "score": 0.007,
          "source": "cross_book_yake"
        },
        {
          "term": "method",
          "score": 0.011,
          "source": "cross_book_yake"
        },
        {
          "term": "Pass-through methods methods",
          "score": 0.014,
          "source": "cross_book_yake"
        },
        {
          "term": "classes",
          "score": 0.015,
          "source": "cross_book_yake"
        },
        {
          "term": "method Pass-through Abstraction",
          "score": 0.016,
          "source": "cross_book_yake"
        },
        {
          "term": "Software method Pass-through",
          "score": 0.016,
          "source": "cross_book_yake"
        },
        {
          "term": "Pass-through Abstraction Software",
          "score": 0.019,
          "source": "cross_book_yake"
        },
        {
          "term": "Abstraction Software",
          "score": 0.022,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "method",
          "source": "cross_book_summa"
        },
        {
          "concept": "classes",
          "source": "cross_book_summa"
        },
        {
          "concept": "object",
          "source": "cross_book_summa"
        },
        {
          "concept": "objects",
          "source": "cross_book_summa"
        },
        {
          "concept": "variable",
          "source": "cross_book_summa"
        },
        {
          "concept": "variables",
          "source": "cross_book_summa"
        },
        {
          "concept": "passes",
          "source": "cross_book_summa"
        },
        {
          "concept": "passed",
          "source": "cross_book_summa"
        },
        {
          "concept": "functionality",
          "source": "cross_book_summa"
        },
        {
          "concept": "text",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 9,
      "title": "Segment 9 (pages 68-76)",
      "start_page": 68,
      "end_page": 76,
      "summary": "Each piece of design infrastructure added to a system, such as an interface, argument, function, class, or definition, adds complexity, since developers must learn about this element.\nFor example, a class can reduce complexity by encapsulating functionality so that users of the class needn’t be aware of it.\nSimilarly, pass-through arguments require each of several methods to be aware of their existence (which adds to complexity) without contributing additional functionality.\nWhich is better: should you let users of the module deal with the complexity, or should you handle the complexity internally within the module?\nWhen students had to implement this class, many of them chose a line-oriented interface, with methods to read, insert, and delete whole lines of text.\nThis resulted in a simple implementation for the class, but it created complexity for higher level software.\nWith the line-oriented text interface, higher-level software had to split and join lines in order to implement the user interface.\nThe implementation of the text class probably becomes more complex: if it represents the text internally as a collection of lines, it will have to split and merge lines to implement the character-oriented operations.\nThis approach is better because it encapsulates the complexity of splitting and merging within the text class, which reduces the overall complexity of the system.\nConfiguration parameters are an example of moving complexity upwards instead of down.\nRather than determining a particular behavior internally, a class can export a few parameters that control its behavior, such as the size of a cache or the number of times to retry a request before giving up.\nUsers of the class must then specify appropriate values for the parameters.\nThis approach pulls complexity downward and saves users from having to figure out the right retry interval.\nBefore exporting a configuration parameter, ask yourself: “will users (or higher-level modules) be able to determine a better value than we can determine here?” When you do create configuration parameters, see if you can compute reasonable defaults automatically, so users will only need to provide values under exceptional conditions.\nIdeally, each module should solve a problem completely; configuration parameters result in an incomplete solution, which adds to system complexity.\nPulling complexity down makes the most sense if (a) the complexity being pulled down is closely related to the class’s existing functionality, (b) pulling the complexity down will result in many simplifications elsewhere in the application, and (c) pulling the complexity down simplifies the class’s interface.\nChapter 6 described how some students defined methods in the text class that reflected the user interface, such as a method that implements the functionality of the backspace key.\nHowever, adding knowledge of the user interface to the text class doesn’t simplify higher-level code very much, and the user-interface knowledge doesn’t relate to the core functions of the text class.\nFor example, should buffering be included in the class that provides stream- oriented file I/O, or should it be in a separate class?\nShould the parsing of an HTTP request be implemented entirely in one method, or should it be divided among multiple methods (or even multiple classes)?\nThe rest of this chapter uses more specific rules as well as examples to show when it makes sense to bring pieces of code together and when it makes sense to separate them.\nIn its first implementation, the project used two different methods in different classes to read in and parse HTTP requests.\nBecause of this shared information, it is better to both read and parse the request in the same place; when the two classes were combined into one, the code got shorter and simpler.\nIn the HTTP server example from the preceding section, the original methods required an interface to return the HTTP request string from the first method and pass it to the second.\nIn addition, when the functionality of two or more classes is combined, it may be possible to perform some functions automatically, so that most users need not be aware of them.\nIf the FileInputStream and BufferedInputStream classes were combined and buffering were provided by default, the vast majority of users would never even need to be aware of the existence of buffering.\nA combined FileInputStream class might provide methods to disable or replace the default buffering mechanism, but most users would not need to learn about them.",
      "keywords": [
        "complexity",
        "configuration parameters",
        "users",
        "text class",
        "methods",
        "parameters",
        "system",
        "context",
        "interface",
        "user interface",
        "configuration",
        "code",
        "text",
        "components",
        "module"
      ],
      "concepts": [
        "complexity",
        "complex",
        "classes",
        "methods",
        "method",
        "interface",
        "interfaces",
        "function",
        "functionality",
        "functions"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 9,
          "title": "Segment 9 (pages 68-76)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "complexity",
          "score": 0.009,
          "source": "cross_book_yake"
        },
        {
          "term": "text class",
          "score": 0.01,
          "source": "cross_book_yake"
        },
        {
          "term": "users",
          "score": 0.016,
          "source": "cross_book_yake"
        },
        {
          "term": "interface",
          "score": 0.017,
          "source": "cross_book_yake"
        },
        {
          "term": "user interface",
          "score": 0.017,
          "source": "cross_book_yake"
        },
        {
          "term": "text",
          "score": 0.019,
          "source": "cross_book_yake"
        },
        {
          "term": "methods",
          "score": 0.021,
          "source": "cross_book_yake"
        },
        {
          "term": "users text class",
          "score": 0.024,
          "source": "cross_book_yake"
        },
        {
          "term": "text class methods",
          "score": 0.028,
          "source": "cross_book_yake"
        },
        {
          "term": "parameters",
          "score": 0.032,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "complexity",
          "source": "cross_book_summa"
        },
        {
          "concept": "complex",
          "source": "cross_book_summa"
        },
        {
          "concept": "classes",
          "source": "cross_book_summa"
        },
        {
          "concept": "interface",
          "source": "cross_book_summa"
        },
        {
          "concept": "interfaces",
          "source": "cross_book_summa"
        },
        {
          "concept": "function",
          "source": "cross_book_summa"
        },
        {
          "concept": "functionality",
          "source": "cross_book_summa"
        },
        {
          "concept": "functions",
          "source": "cross_book_summa"
        },
        {
          "concept": "methods",
          "source": "cross_book_summa"
        },
        {
          "concept": "method",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 10,
      "title": "Segment 10 (pages 77-87)",
      "start_page": 77,
      "end_page": 87,
      "summary": "It should not include code that specializes the mechanism for a particular use, nor should it contain other general-purpose mechanisms.\nThe GUI editor discussion in Chapter 6 illustrated this principle: the best design was one where the text class provided general-purpose text operations, while operations particular to the user interface (such as deleting the\nThis approach eliminated information leakage and additional interfaces that were present in an earlier design where the specialized user interface operations were implemented in the text class.\nIt provided no benefit for higher-level code, since the higher-level code still needed to be aware of the selection and cursor as distinct entities, and it manipulated them separately (during text insertion, it first invoked a method on the combined object to delete the selected text; then it invoked another method to retrieve the cursor position in order to insert new text).\nThis red flag occurs when a general-purpose mechanism also contains code specialized for a particular use of that mechanism.\nWhen the code was revised to separate the selection and the cursor, both the usage and the implementation became simpler.\nRather than logging the error at the point where it was detected, a separate method in a special error logging class was invoked.\nThis would make the code easier to read and eliminate the interfaces required for the logging methods.\nIn the GUI editor project from Section 6.2, one of the requirements was to support multi-level undo/redo, not just for changes to the text itself, but also for changes in the selection, insertion cursor, and view.\nFor example, if a user selected some text, deleted it, scrolled to a different place in the file, and then invoked undo, the editor had to restore its state to what it was just before the deletion.\nFor changes to the selection, insertion cursor, and view, the user interface code invoked additional methods in the text class, which then added entries for those changes to the undo list.\nWhen undo or redo was requested by the user, the user interface code invoked a method in the text class, which then processed the entries in the undo list.\nFor entries related to text, it updated the internals of the text class; for entries related to other things, such as the selection, the text class called back to the user interface code to carry out the undo or redo.\nThe core was located in the text class along with special-purpose handlers that implemented undo and redo for specific things such as text and the selection.\nhandlers for the selection and the cursor had nothing to do with anything else in the text class; they resulted in information leakage between the text class and the user interface, as well as extra methods in each module to pass undo information back and forth.\nIf a new sort of undoable entity were added to the system in the future, it would require changes to the text class, including new methods specific to that entity.\nIn addition, the general- purpose undo core had little to do with the general-purpose text facilities in the class.\nthe undo/redo mechanism and placing it in a separate class: public class History { public interface Action { public void redo(); public void undo(); }\nEach History.Action describes a single operation, such as a text insertion or a change in the cursor location, and it provides methods that can undo or redo the operation.\nThe History class knows nothing about the information stored in the actions or how they implement their undo and redo methods.\nHistory maintains a history list describing all of the actions executed over the lifetime of an application, and it provides undo and redo methods that walk backwards and forwards through the list in response to user-requested undos and redos, calling undo and redo methods in the History.Actions.\nWhenever it inserts text, the text class creates a new UndoableInsert object describing the insertion and invokes History.addAction to add it to the history list.\nThe interface code might create UndoableSelection and editor’s user UndoableCursor objects that describe changes to the selection and insertion cursor.\nThe History class also allows actions to be grouped so that, for example, a single undo request from the user can restore deleted text, reselect the deleted text, and reposition the insertion cursor.\nA general-purpose mechanism for managing and grouping actions and invoking undo/redo operations (implemented by the History class).\nNote: the suggestion to separate general-purpose code from special- purpose code refers to code related to a particular mechanism.\nFor example, special-purpose undo code (such as code to undo a text insertion) should be separated from general-purpose undo code (such as code to manage the history list).\nHowever, it often makes sense to combine special-purpose code for one mechanism with general-purpose code for another.\nThe text class is an example of this: it implements a general-purpose mechanism for managing text, but it includes special-purpose code related to undoing.\nThe undo code is special-purpose because it only handles undo operations for text modifications.\nIt doesn’t make sense to combine this code with the general-purpose undo infrastructure in the History class, but it does make sense to put it in the text class, since it is closely related to other text functions.\nIt also separates the pieces of the original method, which makes the code harder to read if the pieces are actually related.\nFor example, suppose a method contains five 20-line blocks of code that are executed in order.",
      "keywords": [
        "code",
        "text class",
        "method",
        "text",
        "History class",
        "methods",
        "undo",
        "cursor",
        "selection",
        "History",
        "insertion cursor",
        "user interface code",
        "general-purpose",
        "separate method",
        "separate"
      ],
      "concepts": [
        "methods",
        "code",
        "undo",
        "undos",
        "undoing",
        "classes",
        "actions",
        "action",
        "purposes",
        "purpose"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 10,
          "title": "Segment 10 (pages 77-87)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        },
        {
          "book": "A Philosophy of Software Design",
          "chapter": 7,
          "title": "Segment 7 (pages 52-59)",
          "relevance_score": 0.75,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "text class",
          "score": 0.001,
          "source": "cross_book_yake"
        },
        {
          "term": "text",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "user interface",
          "score": 0.004,
          "source": "cross_book_yake"
        },
        {
          "term": "code",
          "score": 0.005,
          "source": "cross_book_yake"
        },
        {
          "term": "user interface code",
          "score": 0.005,
          "source": "cross_book_yake"
        },
        {
          "term": "undo",
          "score": 0.006,
          "source": "cross_book_yake"
        },
        {
          "term": "History class",
          "score": 0.007,
          "source": "cross_book_yake"
        },
        {
          "term": "user",
          "score": 0.008,
          "source": "cross_book_yake"
        },
        {
          "term": "text History class",
          "score": 0.008,
          "source": "cross_book_yake"
        },
        {
          "term": "interface",
          "score": 0.008,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "classes",
          "source": "cross_book_summa"
        },
        {
          "concept": "method",
          "source": "cross_book_summa"
        },
        {
          "concept": "methods",
          "source": "cross_book_summa"
        },
        {
          "concept": "undo",
          "source": "cross_book_summa"
        },
        {
          "concept": "undos",
          "source": "cross_book_summa"
        },
        {
          "concept": "undoing",
          "source": "cross_book_summa"
        },
        {
          "concept": "code",
          "source": "cross_book_summa"
        },
        {
          "concept": "purpose",
          "source": "cross_book_summa"
        },
        {
          "concept": "purposes",
          "source": "cross_book_summa"
        },
        {
          "concept": "interfaces",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 11,
      "title": "Segment 11 (pages 88-95)",
      "start_page": 88,
      "end_page": 95,
      "summary": "Exception handling is one of the worst sources of complexity in software systems.\nCode that deals with special conditions is inherently harder to write than code that deals with normal cases, and developers often define exceptions without considering how they will be handled.\nThe key overall lesson from this chapter is to reduce the number of places where exceptions must be handled; in many cases the semantics of operations can be modified so that the normal behavior handles all situations and there is no exceptional condition to report (hence the title of this chapter).\nException handling can account for a significant fraction of all the code in a system.\nException handling code is inherently more difficult to write than normal-case code.\nHowever, aborting can be complicated because the exception may have occurred at a point where system state is inconsistent (a data structure might have been partially initialized); the exception handling code must restore consistency, such as by unwinding any changes made before the exception occurred.\nFurthermore, exception handling code creates opportunities for more exceptions.\nIn this case, resending the packet will result in duplicate packets arriving at the peer; this introduces a new exceptional condition that the peer must handle.\nIf an exception is handled by aborting the operation in progress, then this must be reported to the caller as another exception.\nLanguage support for exceptions tends to be verbose and clunky, which makes exception handling code hard to read.\nJust the basic try-catch boilerplate accounts for more lines of code than the code for normal-case operation, without even considering the code that actually handles the exceptions.\nIt is hard to relate the exception handling\ncode to the normal-case code: for example, it’s not obvious where each exception is generated.\nThis would make it clear where exceptions occur, but the try blocks themselves break up the flow of the code and make it harder to read; in addition, some exception handling code might end up duplicated in multiple try blocks.\nIt’s difficult to ensure that exception handling code really works.\nSome exceptions, such as I/O errors, can’t easily be generated in a test environment, so it’s hard to test the code that handles them.\nExceptions don’t occur very often in running systems, so exception handling code rarely executes.\nBugs can go undetected for a long time, and when the exception handling code is finally needed, there’s a good chance that it won’t work (one of my favorite sayings: “code that hasn’t been executed doesn’t work”).\nWhen exception handling code fails, it’s difficult to debug the problem, since it occurs so infrequently.\nIt’s tempting to use exceptions to avoid dealing with difficult situations: rather than figuring out a clean way to handle it, just throw an exception and punt the problem to the caller.\nSome might argue that this approach empowers callers, since it allows each caller to handle the exception in a different way.\nThus, the complexity of exceptions comes from the exception handling code.\nThe best way to reduce the complexity damage caused by exception handling is to reduce the number of places where exceptions have to be handled.\nThe best way to eliminate exception handling complexity is to define your APIs so that there are no exceptions to handle: define errors out of existence.\nWith the first definition, unset can’t do its job if the variable doesn’t exist, so generating an exception makes sense.\nSecond, deleting a file that’s in use does not create exceptions for the processes using the file.",
      "keywords": [
        "Exception handling code",
        "Exception handling",
        "Exception",
        "exceptions",
        "code",
        "handling code",
        "method",
        "methods",
        "file",
        "handling",
        "original method",
        "n’t",
        "unset",
        "Errors",
        "parent method"
      ],
      "concepts": [
        "exceptional",
        "method",
        "methods",
        "code",
        "errors",
        "error",
        "catch",
        "file",
        "files",
        "handled"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 11,
          "title": "Segment 11 (pages 88-95)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "Exception handling code",
          "score": 0.001,
          "source": "cross_book_yake"
        },
        {
          "term": "Exception handling",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "handling code",
          "score": 0.004,
          "source": "cross_book_yake"
        },
        {
          "term": "Exception",
          "score": 0.005,
          "source": "cross_book_yake"
        },
        {
          "term": "Code",
          "score": 0.006,
          "source": "cross_book_yake"
        },
        {
          "term": "handling",
          "score": 0.008,
          "source": "cross_book_yake"
        },
        {
          "term": "exceptions",
          "score": 0.009,
          "source": "cross_book_yake"
        },
        {
          "term": "Exception handling Exception",
          "score": 0.011,
          "source": "cross_book_yake"
        },
        {
          "term": "handling Exception exceptions",
          "score": 0.011,
          "source": "cross_book_yake"
        },
        {
          "term": "Exception exceptions code",
          "score": 0.012,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "exceptions",
          "source": "cross_book_summa"
        },
        {
          "concept": "exceptional",
          "source": "cross_book_summa"
        },
        {
          "concept": "code",
          "source": "cross_book_summa"
        },
        {
          "concept": "handled",
          "source": "cross_book_summa"
        },
        {
          "concept": "handles",
          "source": "cross_book_summa"
        },
        {
          "concept": "handle",
          "source": "cross_book_summa"
        },
        {
          "concept": "way",
          "source": "cross_book_summa"
        },
        {
          "concept": "errors",
          "source": "cross_book_summa"
        },
        {
          "concept": "try",
          "source": "cross_book_summa"
        },
        {
          "concept": "cases",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 12,
      "title": "Segment 12 (pages 96-104)",
      "start_page": 96,
      "end_page": 104,
      "summary": "The Java substring method would be easier to use if it performed this adjustment automatically, so that it implemented the following API: “returns the characters of the string (if any) with index greater than or equal to beginIndex and less than endIndex.” This is a simple and natural API, and it defines the IndexOutOfBoundsException exception out of existence.\nWith this approach, an exceptional condition is detected and handled at a low level in the system, so that higher levels of software need not be aware of the condition.\nThe low-level file system code on the client does not report any exceptions to the invoking application.\nThus, the best alternative is for NFS to mask the errors and hang applications.\nIt results in deeper classes, since it reduces the class’s interface (fewer exceptions for users to be aware of) and adds functionality in the form of the code that masks the exception.\nThe idea behind exception aggregation is to handle many exceptions with a single piece of code; rather than writing distinct handlers for many individual exceptions, handle them all in one place with a single handler.\nWhen students in a software design class implemented such a server, many of them wrapped each distinct call to getParameter in a separate exception handler to catch NoSuchParameter exceptions, as in Figure 10.1.\nIn this figure, there is a separate exception handler for each call to getParameter; this results in duplicated code.\nInstead of catching the exceptions in the individual service methods, let them propagate up to the top-level dispatch method for the Web server, as in Figure 10.2.\nA single handler in this method can catch all of the exceptions and generate an appropriate error response for missing parameters.\nThere are many other errors besides missing parameters that can occur while processing a Web page; for example, a parameter might not have the right syntax (the service method expected an integer, but the value was “xyz”), or the user might not have permission for the requested operation.\nThus, all conditions resulting in an error response can be handled with a single top-level exception handler.\nThe error message can be generated at the time the exception is thrown and included as a variable in the exception record; for example, getParameter will generate the “parameter 'quantity' not present in URL” message.\nThe top-level handler extracts the message from the exception and incorporates it into the error response.\nFigure 10.2: This code is functionally equivalent to Figure 10.1, but exception handling has been aggregated: a single exception handler in the dispatcher catches all of the NoSuchParameter exceptions from all of the URL-specific methods.\nThe top-level exception handler encapsulates knowledge about how to generate error responses, but it knows nothing about specific errors; it just uses the error message provided in the exception.\nAs new functionality is added to the Web server, new methods like getParameter may be created with their own errors.\nsuperclass and including an error message in each exception), they can plug into the existing system with no other changes: the top-level handler will automatically generate error responses for them.\nThis example illustrates a generally-useful design pattern for exception handling.\nException aggregation works best if an exception propagates several levels up the stack before it is handled; this allows more exceptions from more methods to be handled in the same place.\nThis is the opposite of exception masking: masking usually works best if an exception is handled in a low-level method.\nFor masking, the low-level method is typically a library method used by many other methods, so allowing the exception to propagate would increase the number of places where it is handled.\nMasking and aggregation are similar in that both approaches position an exception handler where it can catch the most exceptions, eliminating many handlers that would otherwise need to be created.\nAnother example of exception aggregation occurs in the RAMCloud storage system for crash recovery.\nOne way of thinking about exception aggregation is that it replaces several special-purpose mechanisms, each tailored for a particular situation, with a single general-purpose mechanism that can handle multiple situations.\nThe fourth technique for reducing complexity related to exception handling is to crash the application.\nA better approach is to define a new method ckalloc, which calls malloc, checks the result, and aborts the application with an error message if memory is exhausted.\nDynamically allocated memory is such a fundamental element of any modern application that it doesn’t make sense for the application to continue if memory is exhausted; it’s better to crash as soon as the error is detected.\nThere are many other examples of errors where crashing the application makes sense.\nFor most programs, if an I/O error occurs while reading or writing an open file (such as a disk hard error), or if a network socket cannot be opened, there’s not much the application can do to recover, so aborting with a clear error message is a sensible approach.",
      "keywords": [
        "exception",
        "error",
        "exceptions",
        "errors",
        "exception handler",
        "application",
        "server",
        "method",
        "selection",
        "Exception aggregation",
        "error message",
        "code",
        "error response",
        "Web server",
        "exception masking"
      ],
      "concepts": [
        "error",
        "errors",
        "exception",
        "exceptions",
        "exceptional",
        "method",
        "methods",
        "server",
        "servers",
        "approach"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 12,
          "title": "Segment 12 (pages 96-104)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "exception",
          "score": 0.004,
          "source": "cross_book_yake"
        },
        {
          "term": "exception handler",
          "score": 0.007,
          "source": "cross_book_yake"
        },
        {
          "term": "error",
          "score": 0.009,
          "source": "cross_book_yake"
        },
        {
          "term": "exception error exceptions",
          "score": 0.009,
          "source": "cross_book_yake"
        },
        {
          "term": "exceptions errors exception",
          "score": 0.009,
          "source": "cross_book_yake"
        },
        {
          "term": "errors exception exceptions",
          "score": 0.009,
          "source": "cross_book_yake"
        },
        {
          "term": "exceptions",
          "score": 0.009,
          "source": "cross_book_yake"
        },
        {
          "term": "error exceptions errors",
          "score": 0.012,
          "source": "cross_book_yake"
        },
        {
          "term": "error errors exception",
          "score": 0.012,
          "source": "cross_book_yake"
        },
        {
          "term": "exception aggregation",
          "score": 0.014,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "exception",
          "source": "cross_book_summa"
        },
        {
          "concept": "exceptional",
          "source": "cross_book_summa"
        },
        {
          "concept": "exceptions",
          "source": "cross_book_summa"
        },
        {
          "concept": "errors",
          "source": "cross_book_summa"
        },
        {
          "concept": "error",
          "source": "cross_book_summa"
        },
        {
          "concept": "method",
          "source": "cross_book_summa"
        },
        {
          "concept": "methods",
          "source": "cross_book_summa"
        },
        {
          "concept": "handlers",
          "source": "cross_book_summa"
        },
        {
          "concept": "handler",
          "source": "cross_book_summa"
        },
        {
          "concept": "level",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 13,
      "title": "Segment 13 (pages 105-116)",
      "start_page": 105,
      "end_page": 116,
      "summary": "In the example above, both the line-oriented interface and the character-oriented interface will require extra work in software that uses the text class.\nIf you were designing the text class and considered only the line-oriented and character-oriented approaches, you might notice that each of the alternatives is awkward because it requires higher level software to perform additional text manipulations.\nThen you can apply it again when you are designing the implementation: for the text class, you might consider implementations such as a linked list of lines, fixed-size blocks of characters, or a “gap buffer.” The goals will be different for the implementation than for the interface: for the things are simplicity and performance.\nIn-code documentation plays a crucial role in software design.\nDocumentation also plays an important role in abstraction; without comments, you can’t hide complexity.\nFinally, the process of writing comments, if done correctly, will actually improve a system’s design.\nConversely, a good software design loses much of its value if it is poorly documented.\nMany developers think that comments are a waste of time; others see the value in comments, but somehow never get around to writing them.\nHowever, even in teams that encourage documentation, comments are often viewed as drudge work and many developers don’t understand how to write them, so the resulting documentation is often mediocre.\nIn this chapter I will discuss the excuses developers use to avoid writing comments, and the reasons why comments really do matter.\nChapter 13 will then describe how to write good comments and the next few chapters after that will discuss related issues such as choosing variable names and how to use documentation to improve a system’s design.\nI hope these chapters will convince you of three things: good comments can make a big difference in the overall quality of software; it isn’t hard to write good comments; and (this may be hard to believe) writing comments can actually be fun.\n“Good code is self-documenting.” “I don’t have time to write comments.” “Comments get out of date and become misleading.” “The comments I have seen are all worthless; why bother?” In the sections below I will address each of these excuses in turn.\nTo be sure, there are things you can do when writing code to reduce the need for comments, such as choosing good variable names (see Chapter 14).\nThe informal aspects of an interface, such as a high- level description of what each method does or the meaning of its result, can only be described in comments.\nThere are many other examples of things that can’t be described in the code, such as the rationale for a particular design decision, or the conditions under which it makes sense to call a particular method.\nSome developers argue that if others want to know what a method does, they should just read the code of the method: this will be more accurate than any comment.\nIt’s possible that a reader could deduce the abstract interface of the method by reading its code, but it would be time-consuming and painful.\nIn addition, if you write code with the expectation that users will read method implementations, you will try to make each method as short as possible, so that it’s easy to read.\nFurthermore, it doesn’t really make the code easier to read: in order to understand the behavior of the top-level method, readers will probably need to understand the behaviors of the nested\nIt’s also important that comments are written in a human language such as English; this makes them less precise than code, but it provides more expressive power, so we can create simple, intuitive descriptions.\n12.2 I don’t have time to write comments\nHowever, software projects are almost always under time pressure, and there will always be things that seem higher priority than writing comments.\nGood comments make a huge difference in the maintainability of software, so the effort spent on them\nAsk yourself how much of your development time you spend typing in code (as opposed to designing, compiling, testing, etc.), assuming you don’t include any comments; I doubt that the answer is more than 10%.\nWith these assumptions, writing good comments won’t add more than about 10% to your development time.\nFurthermore, many of the most important comments are those related to abstractions, such as the top-level documentation for classes and methods.\nChapter 15 will argue that these comments should be written as part of the design process, and that the act of writing the documentation serves as an important design tool that improves the overall design.\nEvery software developer has seen comments that provide no useful information, and most existing documentation is so-so at best.\nThe next chapters will lay out a framework for how to write good documentation and maintain it over time.\nNow that I have discussed (and, hopefully, debunked) the arguments against writing comments, let’s consider the benefits that you will get from good comments.\nThe overall idea behind comments is to capture information that was in the mind of the designer but couldn’t be represented in the code.\nComments are valuable even when the original designer is the one making the changes: if it has been more than a few weeks since you last worked in a piece of code, you will have forgotten many of the details of the original design.\nWithout adequate documentation, developers may have to read large amounts of code to reconstruct what was in the designer’s mind.\nThe next few chapters will show you how to write good documentation.\nThey will also discuss how to integrate documentation-writing into the design process so that it improves the design of your software.",
      "keywords": [
        "Comments",
        "design",
        "code",
        "documentation",
        "good comments",
        "n’t",
        "interface",
        "good",
        "software",
        "writing comments",
        "time",
        "text",
        "write good comments",
        "good documentation",
        "method"
      ],
      "concepts": [
        "design",
        "designing",
        "designs",
        "designer",
        "documentation",
        "documented",
        "documenting",
        "comments",
        "comment",
        "develop"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 13,
          "title": "Segment 13 (pages 105-116)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        },
        {
          "book": "A Philosophy of Software Design",
          "chapter": 18,
          "title": "Segment 18 (pages 152-159)",
          "relevance_score": 0.79,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "comments",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "good comments",
          "score": 0.005,
          "source": "cross_book_yake"
        },
        {
          "term": "writing comments",
          "score": 0.006,
          "source": "cross_book_yake"
        },
        {
          "term": "write good comments",
          "score": 0.007,
          "source": "cross_book_yake"
        },
        {
          "term": "code",
          "score": 0.007,
          "source": "cross_book_yake"
        },
        {
          "term": "good",
          "score": 0.01,
          "source": "cross_book_yake"
        },
        {
          "term": "design",
          "score": 0.011,
          "source": "cross_book_yake"
        },
        {
          "term": "method",
          "score": 0.011,
          "source": "cross_book_yake"
        },
        {
          "term": "comment",
          "score": 0.012,
          "source": "cross_book_yake"
        },
        {
          "term": "comments comments comment",
          "score": 0.013,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "comments",
          "source": "cross_book_summa"
        },
        {
          "concept": "comment",
          "source": "cross_book_summa"
        },
        {
          "concept": "designing",
          "source": "cross_book_summa"
        },
        {
          "concept": "design",
          "source": "cross_book_summa"
        },
        {
          "concept": "designer",
          "source": "cross_book_summa"
        },
        {
          "concept": "designs",
          "source": "cross_book_summa"
        },
        {
          "concept": "designed",
          "source": "cross_book_summa"
        },
        {
          "concept": "documentation",
          "source": "cross_book_summa"
        },
        {
          "concept": "documented",
          "source": "cross_book_summa"
        },
        {
          "concept": "documenting",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 14,
      "title": "Segment 14 (pages 117-124)",
      "start_page": 117,
      "end_page": 124,
      "summary": "Comments Should Describe Things that Aren’t Obvious from the Code\nThe reason for writing comments is that statements in a programming language can’t capture all of the important information that was in the mind of the developer when the code was written.\nComments record this information so that developers who come along later can easily understand and modify the code.\nThe guiding principle for comments is that comments should describe things that aren’t obvious from the code.\nOne of the most important reasons for comments is abstractions, which include a lot of information that isn’t obvious from the code.\nAs you will see, good comments typically explain things at a different level of detail than the code, which is more detailed in some situations and less detailed (more abstract) in others.\nImplementation comment: a comment inside the code of a method or function, which describes how the code works internally.\nOccasionally, the declaration for a variable or method is so obvious that there is nothing useful to add in a comment (getters and setters sometimes fall in this category), but this is rare; it is easier to comment everything rather than spend energy worrying about whether a comment is needed.\nHere is a code sample that appeared in a recent research paper: ptr_copy = get_copy(obj) if is_unlocked(ptr_copy): return obj if is_copy(ptr_copy): return obj thread_id = get_thread_id(ptr_copy) if thread_id == ctx.thread_id: return ptr_copy There is no useful information in any of these comments except for the “Locked by” comment, which suggests something about the thread that might not be obvious from the code.\nNotice that these comments are at roughly the same level of detail as the code: there is one comment per line of code, which describes that line.\nHere are more examples of comments that repeat the code:\nNone of these comments provide any value.\nFor the first two comments, the code is already clear enough that it doesn’t really need comments; in the third case, a comment might be useful, but the current comment doesn’t provide enough detail to be helpful.\nIf the answer is yes, as in the examples above, then the comment doesn’t make the code any easier to understand.\nThese comments just take the words from the method or variable name, perhaps add a few words from argument names and types, and form them into a sentence.\nFor example, the only thing in the second comment that isn’t in the code is the word “to”!\nOnce again, these comments could be written just by looking at the declarations, without any understanding the methods of variables; as a result, they have no value.\nRed Flag: Comment Repeats Code\nIf the information in a comment is already obvious from the code next to the comment, then the comment isn’t helpful.\nOne example of this is when the comment uses the same words that make up the name of the thing it is describing.\nPick words for the comment that provide additional information about the meaning of the entity, rather than just repeating its name.\nThis comment provides additional information that is not obvious from the declaration itself, such as the units (pixels) and the fact that padding applies to both sides of each line.\nComments augment the code by providing information at a different level of detail.\nSome comments provide information at a lower, more detailed, level than the code; these comments add precision by clarifying the exact meaning of the code.\nOther comments provide information at a higher, more abstract, level than the code; these comments offer intuition, such as the reasoning behind the code, or a simpler and more abstract way of thinking about the code.\nComments at the same level as the code are likely to repeat the code.\nPrecision is most useful when commenting variable declarations such as class instance variables, method arguments, and return values.\nThe comment will be both shorter and more useful if it describes what the variable represents rather than mirroring the code structure: /* True means that a heartbeat has been received since the last\nThe second way in which comments can augment code is by providing intuition.\nThese comments are written at a higher level than the code.",
      "keywords": [
        "Comments",
        "comment",
        "Code",
        "n’t",
        "variable",
        "information",
        "n’t Obvious",
        "Obvious",
        "Comment Repeats Code",
        "comments provide information",
        "comments provide",
        "comment describes",
        "comments add",
        "good comments",
        "declaration"
      ],
      "concepts": [
        "comments",
        "comment",
        "commenting",
        "private",
        "variable",
        "variables",
        "code",
        "level",
        "returned",
        "followed"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 14,
          "title": "Segment 14 (pages 117-124)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        },
        {
          "book": "A Philosophy of Software Design",
          "chapter": 18,
          "title": "Segment 18 (pages 152-159)",
          "relevance_score": 0.81,
          "method": "cosine_similarity"
        },
        {
          "book": "A Philosophy of Software Design",
          "chapter": 15,
          "title": "Segment 15 (pages 125-135)",
          "relevance_score": 0.72,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "Comments",
          "score": 0.001,
          "source": "cross_book_yake"
        },
        {
          "term": "Comments comment Code",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "comment",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "Code",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "Comment Repeats Code",
          "score": 0.004,
          "source": "cross_book_yake"
        },
        {
          "term": "comments comments comment",
          "score": 0.004,
          "source": "cross_book_yake"
        },
        {
          "term": "interface comment",
          "score": 0.005,
          "source": "cross_book_yake"
        },
        {
          "term": "Comments comment",
          "score": 0.005,
          "source": "cross_book_yake"
        },
        {
          "term": "comments code comment",
          "score": 0.005,
          "source": "cross_book_yake"
        },
        {
          "term": "comments provide information",
          "score": 0.005,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "comments",
          "source": "cross_book_summa"
        },
        {
          "concept": "comment",
          "source": "cross_book_summa"
        },
        {
          "concept": "commenting",
          "source": "cross_book_summa"
        },
        {
          "concept": "code",
          "source": "cross_book_summa"
        },
        {
          "concept": "coding",
          "source": "cross_book_summa"
        },
        {
          "concept": "method",
          "source": "cross_book_summa"
        },
        {
          "concept": "methods",
          "source": "cross_book_summa"
        },
        {
          "concept": "level",
          "source": "cross_book_summa"
        },
        {
          "concept": "designing",
          "source": "cross_book_summa"
        },
        {
          "concept": "design",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 15,
      "title": "Segment 15 (pages 125-135)",
      "start_page": 125,
      "end_page": 135,
      "summary": "This comment doesn’t contain any details; instead, it describes the code’s overall function at a higher level.\nWith this high-level information, a reader can explain almost everything that happens in the code: the loop must be iterating over all the existing remote procedure calls (RPCs); the session test is probably used to see if a particular RPC is destined for the right server; the LOADING test suggests that RPCs can have multiple states, and in some states it isn’t safe to add more hashes; the MAX - PKHASHES_PERRPC test suggests that there is a limit to how many hashes can be sent in a single RPC.\nFurthermore, the new comment provides a basis for readers to judge the code: does it do everything that is needed to add the key hash to an existing\nA good higher-level comment expresses one or a few simple ideas that provide a conceptual framework, such as “append to an existing RPC.” Given the framework, it becomes easy to see how specific code statements relate to the overall goal.\nThe first step in documenting abstractions is to separate interface comments from implementation comments.\nInterface comments provide information that someone needs to know in order to use a class or method; they define the abstraction.\nImplementation comments describe how a class or method works internally in order to implement the abstraction.\nIt’s important to separate these two kinds of comments, so that users of an interface are not exposed to implementation details.\nIf interface comments must also describe the implementation, then the class or method is shallow.\nThe interface comment for a class provides a high-level description of\nthe abstraction provided by the class, such as the following: /** * This class implements a simple server-side interface to the HTTP * protocol: by using this class, an application can receive HTTP * requests, process them, and return responses.\nThis comment describes the overall capabilities of the class, without any implementation details or even the specifics of particular methods.\nThe interface comment for a method includes both higher-level\nThe comment usually starts with a sentence or two describing the behavior of the method as perceived by callers; this is the higher-level abstraction.\nIf the method has any side effects, these must be documented in the interface comment.\nHere is the interface comment for a method that copies data out of a\nThe goal of the comment is to provide all the information a developer needs in order to invoke the method, including how special cases are handled (note how this method follows the advice of\nThe developer should not need to read the body of the method in order to invoke it, and the interface comment provides no information about how the method is implemented, such as how it scans its internal data structures to find the desired data.\nThe application first constructs an object of type IndexLookup, providing arguments that select a table, an index, and a range within the index (for example, if the index is based on an age field, key1 and key2 might be specified as 21 and 65 to select all objects with ages between those values).\neach index may also be distributed across a different set of servers; the code in the IndexLookup class must first communicate with all of the relevant index servers to collect information about the objects in the range, then it must communicate with the servers that actually store the objects in order to retrieve their values.\nNow let’s consider what information needs to be included in the interface comment for this class.\nHere is the original version of the interface comment for the IndexLookup class; the excerpt also includes a few lines from the class’s definition, which are referred to in the comment: /* * This class implements the client side framework for index range * lookups.\nin the config below: * - The number of concurrent indexedRead RPCs * - The max number of PKHashes a indexedRead RPC can hold at a time * - The size of the active PKHashes * * To use IndexLookup, the client creates an object of this class by * providing all necessary information.\nThis comment is not intended to document every detail of each method; it just provides high level information to help readers understand how the methods work together and when each method might be invoked.\nFor details, readers can refer to the interface comments for individual methods.\nThis red flag occurs when interface documentation, such as that for a method, describes implementation details that aren’t needed in order to use the thing being documented.\nHere is a better version of the comment: /* * Indicates whether an indexed read has made enough progress for * getNext to return immediately without blocking.\n*/ This version of the comment provides more precise information about what “ready” means, and it provides the important information that this method must eventually be invoked if the indexed retrieval is to move forward.\n13.6 Implementation comments: what and why, not how\nImplementation comments are the comments that appear inside methods to help readers understand how they work internally.\nMost methods are so short and simple that they don’t need any implementation comments: given the code and the interface comments, it’s easy to figure out how a method works.\nThe main goal of implementation comments is to help readers understand what the code is doing (not how it does it).\nFor short methods, the code only does one thing, which is already described in its interface comment, so no implementation comments are needed.\nNotice how this comment describes the loop at a more abstract and intuitive level; it doesn’t go into any details about how a request is extracted from the request message or how the object is incremented.",
      "keywords": [
        "comment",
        "comments",
        "interface comment",
        "method",
        "implementation comments",
        "code",
        "Interface",
        "object",
        "RPC",
        "implementation",
        "information",
        "put assigning PKHash",
        "objects",
        "RPCs",
        "methods"
      ],
      "concepts": [
        "comment",
        "comments",
        "method",
        "methods",
        "object",
        "objects",
        "information",
        "index",
        "indexes",
        "indexed"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 15,
          "title": "Segment 15 (pages 125-135)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        },
        {
          "book": "A Philosophy of Software Design",
          "chapter": 14,
          "title": "Segment 14 (pages 117-124)",
          "relevance_score": 0.72,
          "method": "cosine_similarity"
        },
        {
          "book": "A Philosophy of Software Design",
          "chapter": 18,
          "title": "Segment 18 (pages 152-159)",
          "relevance_score": 0.72,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "comments",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "comment",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "interface comment",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "code",
          "score": 0.003,
          "source": "cross_book_yake"
        },
        {
          "term": "methods comment comments",
          "score": 0.004,
          "source": "cross_book_yake"
        },
        {
          "term": "comment comments method",
          "score": 0.004,
          "source": "cross_book_yake"
        },
        {
          "term": "Comments comment Code",
          "score": 0.004,
          "source": "cross_book_yake"
        },
        {
          "term": "implementation comments",
          "score": 0.004,
          "source": "cross_book_yake"
        },
        {
          "term": "comment comments interface",
          "score": 0.005,
          "source": "cross_book_yake"
        },
        {
          "term": "comments interface comment",
          "score": 0.005,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "comment",
          "source": "cross_book_summa"
        },
        {
          "concept": "commenting",
          "source": "cross_book_summa"
        },
        {
          "concept": "coding",
          "source": "cross_book_summa"
        },
        {
          "concept": "method",
          "source": "cross_book_summa"
        },
        {
          "concept": "methods",
          "source": "cross_book_summa"
        },
        {
          "concept": "information",
          "source": "cross_book_summa"
        },
        {
          "concept": "level",
          "source": "cross_book_summa"
        },
        {
          "concept": "designing",
          "source": "cross_book_summa"
        },
        {
          "concept": "design",
          "source": "cross_book_summa"
        },
        {
          "concept": "designs",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 16,
      "title": "Segment 16 (pages 136-143)",
      "start_page": 136,
      "end_page": 143,
      "summary": "If there are tricky aspects to the code that won’t be obvious from reading it, you should document them.\nFor example, if a bug fix requires the addition of code whose purpose isn’t totally obvious, add a comment describing why the code is needed.\nHowever, most local variables don’t need documentation if they have good names.\nIn this case it’s OK to let readers read the code to figure out the meaning of the variable.\nHowever, if the variable is used over a large span of code, then you should consider adding a comment to describe the variable.\nWhen documenting variables, focus on what the variable represents, not how it is manipulated in the code.\nCross-module decisions are often they account for many bugs, so good complex and subtle, and documentation for them is crucial.\nAdding a Status for a new error condition requires modifying many different files (one file maps Status values to exceptions, another provides a human-readable message for each Status, and so on).\nFortunately, there is one obvious place where developers will have to go when adding a new status value, which is the declaration of the Status enum.\n// Note: if you add a new status value you must make the\n// its status code.\nNew status values will be added at the end of the existing list, so the comments are also placed at the end, where they are most likely to be seen.\nUnfortunately, in many cases there is not an obvious central place to put cross-module documentation.\nOne example from the RAMCloud storage system was the code for dealing with zombie servers, which are servers that the system believes have crashed, but in fact are still running.\nNeutralizing zombie servers required code in several different modules, and these pieces of code all depend on each other.\nNone of the pieces of code is an obvious central place to put documentation.\nAlternatively, the documentation can be located in one of the places where it is needed, but in this case it’s unlikely that developers will see the documentation or know where to look for it.\nThen, in any piece of code that relates to one of these issues there is a short comment referring to the designNotes file: // See \"Zombies\" in designNotes.\nThe goal of comments is to ensure that the structure and behavior of the system is obvious to readers, so they can quickly find the information they need and make modifications to the system with confidence that they will work.\nWhen following the rule that comments should describe things that aren’t obvious from the code, “obvious” is from the perspective of someone reading your code for the first time (not you).\nDoes a developer need to know each of the following pieces of information in order to use the IndexLookup class?\nNo: this information should be encapsulated on the servers; not even the implementation of IndexLookup should need to know this.\nNo: RAMCloud recovers automatically from server crashes, so crashes are not visible to application-level software; thus, there is no need to mention crashes in the interface documentation for IndexLookup.\nGood names are a form of documentation: they make code easier to understand.\nThe file system code used the variable name block for two different purposes.\nUnfortunately, at one point in the code there was a block variable containing a logical block number, but it was accidentally used in a context where a physical block number was needed; as a result, an unrelated block on disk got overwritten with zeroes.",
      "keywords": [
        "Status",
        "code",
        "documentation",
        "block",
        "obvious",
        "servers",
        "variable",
        "comments",
        "bug",
        "add",
        "block number",
        "n’t",
        "system",
        "file",
        "status code"
      ],
      "concepts": [
        "blocks",
        "block",
        "variables",
        "variable",
        "code",
        "bug",
        "bugs",
        "comments",
        "comment",
        "status"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 16,
          "title": "Segment 16 (pages 136-143)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "code",
          "score": 0.007,
          "source": "cross_book_yake"
        },
        {
          "term": "Status",
          "score": 0.012,
          "source": "cross_book_yake"
        },
        {
          "term": "status code",
          "score": 0.014,
          "source": "cross_book_yake"
        },
        {
          "term": "Status code documentation",
          "score": 0.021,
          "source": "cross_book_yake"
        },
        {
          "term": "obvious",
          "score": 0.024,
          "source": "cross_book_yake"
        },
        {
          "term": "status code blocks",
          "score": 0.024,
          "source": "cross_book_yake"
        },
        {
          "term": "documentation",
          "score": 0.024,
          "source": "cross_book_yake"
        },
        {
          "term": "variable",
          "score": 0.025,
          "source": "cross_book_yake"
        },
        {
          "term": "block",
          "score": 0.029,
          "source": "cross_book_yake"
        },
        {
          "term": "file status code",
          "score": 0.03,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "code",
          "source": "cross_book_summa"
        },
        {
          "concept": "status",
          "source": "cross_book_summa"
        },
        {
          "concept": "block",
          "source": "cross_book_summa"
        },
        {
          "concept": "blocks",
          "source": "cross_book_summa"
        },
        {
          "concept": "variables",
          "source": "cross_book_summa"
        },
        {
          "concept": "variable",
          "source": "cross_book_summa"
        },
        {
          "concept": "document",
          "source": "cross_book_summa"
        },
        {
          "concept": "documentation",
          "source": "cross_book_summa"
        },
        {
          "concept": "documenting",
          "source": "cross_book_summa"
        },
        {
          "concept": "obvious",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 17,
      "title": "Segment 17 (pages 144-151)",
      "start_page": 144,
      "end_page": 151,
      "summary": "14.3 Names should be precise\nThe most common problem with names is that they are too generic or vague; as a result, it’s hard for readers to tell what the name refers to; the reader may assume that the name refers to something different from reality, as in the block bug above.\nA more precise name like getActiveIndexlets or numIndexlets would be better: with one of these names, readers will probably be able to guess what the method returns without having to look at its documentation.\nHere are some other examples of names that aren’t precise enough,\nThese names are too generic.\nprivate boolean cursorVisible = true; The name cursorVisible conveys more information; for example, it allows readers to guess what a true value means (as a general rule, names of boolean variables should always be predicates).\nA variable named result was used in a method with no return value.\nThis name is still a bit generic, but readers can look at the method documentation to see its meaning, and it’s helpful to know that the value will eventually become the return value.\nIf a variable or method name is broad enough to refer to many different things, then it doesn’t convey much information to the developer and the underlying entity is more likely to be misused.\nFor example, it’s fine to use generic names like i and j as loop iteration variables, as long as the loops only span a few lines of code.\nIf you can see the entire range of usage of a variable, then the meaning of the variable will probably be obvious from the code so you don’t need a long name.\nIf the loop gets so long that you can’t see it all at once, or if the meaning of the iteration variable is harder to figure out from the code, then a more descriptive name is in order.\n14.4 Use names consistently\nIf you use names such as i and j for loop variables, always use i in outermost loops and j for nested loops.\nIn a presentation on name choice for Go, Andrew Gerrand states that “long names obscure what the code does.”1 He presents this code sample, which uses single-letter variable names: func RuneCount(b []byte) int { i, n := 0, 0 for i < len(b) { if b[i] < RuneSelf { i++ } else { _, size := DecodeRune(b[i:]) i += size } n++ } return n }\nand argues that it is more readable than the following version, which uses longer names: func RuneCount(buffer []byte) int {\nTo me, ambiguous names like these are likely to result in confusion and error, just as in the block example.\nIf you write code with short variable names and the people who read it find it easy to understand, then that’s fine.\nIf you start getting complaints that your code is cryptic, then you should consider using longer names (a Web search for “go language short names” will identify several such complaints).\nSimilarly, if I start getting complaints that long variable names make my code harder to read, then I’ll consider using shorter ones.\nGerrand makes one comment that I agree with: “The greater the distance between a name’s declaration and its uses, the longer the name\nshould be.” The earlier discussion about using loop variables named i and j is an example of this rule.\nWell chosen names help to make code more obvious; when someone encounters the variable for the first time, their first guess about its behavior, made without much thought, will be correct.\nChoosing good names is an example of the investment mindset discussed in Chapter 3: if you take a little extra time up front to select good names, it will be easier for you to work on the code in the future.",
      "keywords": [
        "code",
        "variable",
        "documentation",
        "variables",
        "method",
        "n’t",
        "Comments",
        "file",
        "readers",
        "Good",
        "information",
        "long",
        "find",
        "loop variables",
        "index"
      ],
      "concepts": [
        "names",
        "naming",
        "code",
        "coding",
        "variables",
        "value",
        "values",
        "documentation",
        "uses",
        "better"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 17,
          "title": "Segment 17 (pages 144-151)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "variable",
          "score": 0.015,
          "source": "cross_book_yake"
        },
        {
          "term": "code",
          "score": 0.015,
          "source": "cross_book_yake"
        },
        {
          "term": "variables",
          "score": 0.021,
          "source": "cross_book_yake"
        },
        {
          "term": "loop variables",
          "score": 0.024,
          "source": "cross_book_yake"
        },
        {
          "term": "variable documentation variables",
          "score": 0.036,
          "source": "cross_book_yake"
        },
        {
          "term": "long",
          "score": 0.039,
          "source": "cross_book_yake"
        },
        {
          "term": "loop",
          "score": 0.042,
          "source": "cross_book_yake"
        },
        {
          "term": "code variable documentation",
          "score": 0.046,
          "source": "cross_book_yake"
        },
        {
          "term": "readers",
          "score": 0.046,
          "source": "cross_book_yake"
        },
        {
          "term": "method",
          "score": 0.049,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "names",
          "source": "cross_book_summa"
        },
        {
          "concept": "naming",
          "source": "cross_book_summa"
        },
        {
          "concept": "variables",
          "source": "cross_book_summa"
        },
        {
          "concept": "code",
          "source": "cross_book_summa"
        },
        {
          "concept": "coding",
          "source": "cross_book_summa"
        },
        {
          "concept": "uses",
          "source": "cross_book_summa"
        },
        {
          "concept": "loop",
          "source": "cross_book_summa"
        },
        {
          "concept": "loops",
          "source": "cross_book_summa"
        },
        {
          "concept": "good",
          "source": "cross_book_summa"
        },
        {
          "concept": "readers",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 18,
      "title": "Segment 18 (pages 152-159)",
      "start_page": 152,
      "end_page": 159,
      "summary": "You look at the code as you are writing the comments, so the comments repeat the code.\nFor each new method I write the interface comment before the body of the method; for instance variables I fill in the comment at the same time that I write the variable declaration.\nWhen the code is done, the comments are also done.\nIf you write the comments as you are designing the class, the key design issues will be fresh in your mind, so it’s easy to record them.\nIt’s better to write the interface comment for each method before its body, so you can focus on the method’s abstraction and interface without being distracted by its implementation.\nDuring the coding and testing process you will notice and fix problems with the comments.\n15.3 Comments are a design tool\nThe second, and most important, benefit of writing the comments at the beginning is that it improves the system design.\nIf you write comments describing the abstractions at the beginning, you can review and tune them before writing implementation code.\nTo write a good comment, you must identify the essence of a variable or piece of code: what are the most important aspects of this thing?\nOverall, the act of writing comments allows you to evaluate your design decisions early, so you can discover and fix problems.\nIf you find it difficult to write such a comment, that’s an indicator that there may be a problem with the design of the thing you are describing.\nIf you write a method interface comment that doesn’t provide all the information needed to invoke the method, or one that is so cryptic that it’s hard to understand, then that comment doesn’t provide a good measure of the method’s depth.\nIf you are programming strategically, where your main goal is a great design rather than just writing code that works, then writing comments should be fun, since that’s how you identify the best designs.\nFirst, estimate the total fraction of development time that you spend typing in code and comments together, including time to revise code and comments; it’s unlikely that this will be more than about 10% of all development time.\nEven if half of your total code lines are comments, writing comments probably doesn’t account for more than about 5% of your total development time.\nWriting the comments first will mean that the abstractions will be more stable before you start writing code.\nIn contrast, if you write the code first, the abstractions will probably evolve as you code, which will require more code revisions than the comments-first approach.\nWhen you change existing code, there’s a good chance that the changes will invalidate some of the existing comments.\nIt’s easy to forget to update comments when you modify code, which results in comments that are no longer accurate.\nThe best way to ensure that comments get updated is to position them close to the code they describe, so developers will see them when they change the code.\nFor example, the best place for a method’s interface comment is in the code file, right next to the body of the method.\nAny changes to the method will involve this code, so the developer is likely to see the interface comments and update them if needed.\nAn alternative for languages like C and C++ that have separate code and header files, is to place the interface comments next to the method’s declaration in the .h file.\nHowever, this is a long way from the code; developers won’t see those comments when modifying the method’s body, and it takes additional work to open a different file and find the interface comments to update them.\nSome might argue that interface comments should go in header files so that users can learn how to use an abstraction without having to look at the code file.\nFor example, if a method has three major phases, don’t write one comment at the top of the method that describes all of the phases in detail.\nInstead, write a separate comment for each phase and position that comment just above the first line of code in that phase.\n16.3 Comments belong in the code, not the commit log",
      "keywords": [
        "comments",
        "code",
        "comment",
        "method",
        "interface comment",
        "design",
        "writing comments",
        "system design",
        "system",
        "write",
        "n’t",
        "interface",
        "method interface comment",
        "writing",
        "write interface comments"
      ],
      "concepts": [
        "comments",
        "comment",
        "code",
        "coding",
        "designed",
        "design",
        "designing",
        "designs",
        "methods",
        "method"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 18,
          "title": "Segment 18 (pages 152-159)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        },
        {
          "book": "A Philosophy of Software Design",
          "chapter": 14,
          "title": "Segment 14 (pages 117-124)",
          "relevance_score": 0.81,
          "method": "cosine_similarity"
        },
        {
          "book": "A Philosophy of Software Design",
          "chapter": 13,
          "title": "Segment 13 (pages 105-116)",
          "relevance_score": 0.79,
          "method": "cosine_similarity"
        },
        {
          "book": "A Philosophy of Software Design",
          "chapter": 15,
          "title": "Segment 15 (pages 125-135)",
          "relevance_score": 0.72,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "comments",
          "score": 0.001,
          "source": "cross_book_yake"
        },
        {
          "term": "comments comments comment",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "comments comment code",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "comment",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "code",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "interface comment",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "comments code comment",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "method interface comment",
          "score": 0.003,
          "source": "cross_book_yake"
        },
        {
          "term": "interface comments comments",
          "score": 0.004,
          "source": "cross_book_yake"
        },
        {
          "term": "writing comments",
          "score": 0.004,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "comments",
          "source": "cross_book_summa"
        },
        {
          "concept": "commenting",
          "source": "cross_book_summa"
        },
        {
          "concept": "code",
          "source": "cross_book_summa"
        },
        {
          "concept": "coding",
          "source": "cross_book_summa"
        },
        {
          "concept": "designing",
          "source": "cross_book_summa"
        },
        {
          "concept": "design",
          "source": "cross_book_summa"
        },
        {
          "concept": "designs",
          "source": "cross_book_summa"
        },
        {
          "concept": "designed",
          "source": "cross_book_summa"
        },
        {
          "concept": "designer",
          "source": "cross_book_summa"
        },
        {
          "concept": "method",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 19,
      "title": "Segment 19 (pages 160-167)",
      "start_page": 160,
      "end_page": 167,
      "summary": "If there are multiple places in the code that are affected by a particular decision, don’t repeat the documentation at each of these points.\nThis is a natural place that developers are likely to check if they’re having trouble understanding code that uses the variable.\nIf there is no “obvious” single place to put a particular piece of documentation where developers will find it, create a designNotes file as described in Section 13.7.\nIn addition, add short comments in the other places that refer to the central location: “See the comment in xyz for an explanation of the code below.” If the reference becomes obsolete because the master comment was moved or deleted, this inconsistency will be self- evident because developers won’t find the comment at the indicated place; they can use revision control history to find out what happened to the comment and then update the reference.\nIn contrast, if the documentation is duplicated and some of the copies don’t get updated, there will be no indication to developers that they are using stale information.\nGood development tools will usually provide this information automatically, for example, by displaying the interface comments for a method if you select the method’s name or\nTry to make it easy for developers to find appropriate documentation, but don’t do it by repeating the documentation.\nThere are already numerous sources for this documentation on the Web; just add a short comment to your code with a URL for one of these sources.\nIt’s important that readers can easily find all the documentation needed to understand your code, but that doesn’t mean you have to write all of that documentation.\nOne final thought on maintaining documentation: comments are easier to maintain if they are higher-level and more abstract than the code.\nBut in general, the comments that are most useful (they don’t simply repeat the code) are also easiest to maintain.\nIf you can use an existing design pattern to solve the problem, the implementation will proceed more quickly, it is more likely to work, and your code will be more obvious to readers.\nCreate a document that lists the most important overall conventions, such as coding style guidelines.\nFor conventions that are more localized, such as invariants, find an appropriate spot in the code to document them.\nEven with good documentation, it’s hard for developers to remember all of the conventions.\nThe best way to enforce conventions is to write a tool that checks for violations, and make sure that code cannot be committed to the repository unless it passes the checker.\nWe established a convention that files should contain newlines only, but it was hard to ensure that every tool used by every developer followed the convention.\nEvery time a new developer joined the project, we would experience a rash of line termination problems while that developer adjusted to the convention.\nCode reviews provide another opportunity for enforcing conventions and for educating new developers about the conventions.\ndo.” When working in a new file, look around to see how the existing code is structured.\nWhen making a design decision, ask yourself if it’s likely that a similar decision was made elsewhere in the project; if so, find an existing example and use the same approach in your new code.\nHowever, you still run the risk that other developers will not know about the new convention, so they may reintroduce the old approach in the future.\nOverall, reconsidering established conventions is rarely a good use of developer time.\nIt will take a bit of extra work to ensure consistency: work to decide on conventions, work to create automated checkers, work to look for similar situations to mimic in new code, and work in code reviews to educate the team.\nDevelopers will be able to understand the code’s behavior more quickly and accurately, and this will allow them to work faster, with fewer bugs.",
      "keywords": [
        "code",
        "Consistency",
        "documentation",
        "developers",
        "conventions",
        "comments",
        "n’t",
        "Consistency Consistency",
        "place",
        "system",
        "comment",
        "developer",
        "find",
        "work",
        "design"
      ],
      "concepts": [
        "consistency",
        "consistent",
        "code",
        "coding",
        "developers",
        "development",
        "developer",
        "document",
        "documented",
        "conventions"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 19,
          "title": "Segment 19 (pages 160-167)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "code",
          "score": 0.008,
          "source": "cross_book_yake"
        },
        {
          "term": "developers",
          "score": 0.015,
          "source": "cross_book_yake"
        },
        {
          "term": "documentation",
          "score": 0.018,
          "source": "cross_book_yake"
        },
        {
          "term": "conventions",
          "score": 0.02,
          "source": "cross_book_yake"
        },
        {
          "term": "code Consistency documentation",
          "score": 0.026,
          "source": "cross_book_yake"
        },
        {
          "term": "developer",
          "score": 0.027,
          "source": "cross_book_yake"
        },
        {
          "term": "find",
          "score": 0.027,
          "source": "cross_book_yake"
        },
        {
          "term": "work",
          "score": 0.028,
          "source": "cross_book_yake"
        },
        {
          "term": "Consistency documentation developers",
          "score": 0.029,
          "source": "cross_book_yake"
        },
        {
          "term": "comment",
          "score": 0.032,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "developers",
          "source": "cross_book_summa"
        },
        {
          "concept": "developer",
          "source": "cross_book_summa"
        },
        {
          "concept": "conventions",
          "source": "cross_book_summa"
        },
        {
          "concept": "convention",
          "source": "cross_book_summa"
        },
        {
          "concept": "code",
          "source": "cross_book_summa"
        },
        {
          "concept": "coding",
          "source": "cross_book_summa"
        },
        {
          "concept": "documentation",
          "source": "cross_book_summa"
        },
        {
          "concept": "document",
          "source": "cross_book_summa"
        },
        {
          "concept": "documented",
          "source": "cross_book_summa"
        },
        {
          "concept": "comments",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 20,
      "title": "Segment 20 (pages 168-175)",
      "start_page": 168,
      "end_page": 175,
      "summary": "Code Should be Obvious\nThe solution to the obscurity problem is to write code in a way that makes it obvious; this chapter discusses some of the factors that make code more or less obvious.\nIf code is obvious, a reader doesn’t need to spend much time or effort to gather all the information they need to work with the code.\nIf code is not obvious, then a reader must expend a lot of time and energy to understand it.\nObvious code needs fewer comments than nonobvious code.\n“Obvious” is in the mind of the reader: it’s easier to notice that someone else’s code is nonobvious than to see problems with your own code.\nThus, the best way to determine the obviousness of code is through code reviews.\nIf someone reading your code says it’s not obvious, then it’s not obvious, no matter how clear it may seem to you.\n18.1 Things that make code more obvious\nTwo of the most important techniques for making code obvious have already been discussed in previous chapters.\nPrecise and meaningful names clarify the behavior of the code and reduce the need for documentation.\nIf a name is vague or ambiguous, then readers will have read through the code in order to deduce the meaning\n18.2 Things that make code less obvious\nThere are many things that can make code nonobvious; this section provides a few examples.\nBecause of this, it’s hard to reason about event-driven code or convince yourself that it works.\nOften this means that there is important information that is not immediately clear to someone reading the code.\nUnfortunately, generic containers result in nonobvious code because the grouped elements have generic names that obscure their meaning.\nGeneric containers are expedient for the person writing the code, but they create confusion for all the readers that follow.\nIt’s better for the person writing the code to spend a few extra minutes to define a specific container structure, so that the resulting code is more obvious.\nThis code is legal, since List is a superclass of ArrayList, but it can mislead a reader who sees the declaration but not the actual allocation.\nCode that violates reader expectations.\nConsider the following code, which is the main program for a Java application public static void main(String[] args) { ...\nCode is most obvious if it conforms to the conventions that readers will be expecting; if it doesn’t, then it’s important to document the behavior so readers aren’t confused.\nIf code is nonobvious, that usually means there is important information about the code that the reader does not have: in the RaftClient example, the reader might not know that the RaftClient constructor created new threads; in the Pair example, the reader might not know that result.getKey() returns the number of the current term.\nTo make code obvious, you must ensure that readers always have the information they need to understand it.\nSecond, you can take advantage of information that readers have already acquired in other contexts (for example, by following conventions and conforming to expectations) so readers don’t have to learn new information for your code.\nThird, you can present the important information to them in the code, using techniques such as good names and strategic comments.",
      "keywords": [
        "Code",
        "Obvious",
        "make code",
        "code obvious",
        "make code obvious",
        "nonobvious code",
        "reader",
        "information",
        "readers",
        "nonobvious",
        "code nonobvious",
        "Obvious code",
        "making code obvious",
        "make code nonobvious",
        "make"
      ],
      "concepts": [
        "code",
        "comments",
        "comment",
        "examples",
        "returned",
        "returns",
        "useful",
        "uses",
        "generic",
        "event"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 20,
          "title": "Segment 20 (pages 168-175)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "Code",
          "score": 0.003,
          "source": "cross_book_yake"
        },
        {
          "term": "code obvious",
          "score": 0.005,
          "source": "cross_book_yake"
        },
        {
          "term": "Code Obvious make",
          "score": 0.006,
          "source": "cross_book_yake"
        },
        {
          "term": "Obvious make code",
          "score": 0.006,
          "source": "cross_book_yake"
        },
        {
          "term": "Obvious",
          "score": 0.006,
          "source": "cross_book_yake"
        },
        {
          "term": "make code",
          "score": 0.007,
          "source": "cross_book_yake"
        },
        {
          "term": "code code obvious",
          "score": 0.009,
          "source": "cross_book_yake"
        },
        {
          "term": "make code obvious",
          "score": 0.009,
          "source": "cross_book_yake"
        },
        {
          "term": "Obvious code",
          "score": 0.016,
          "source": "cross_book_yake"
        },
        {
          "term": "nonobvious code",
          "score": 0.017,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "code",
          "source": "cross_book_summa"
        },
        {
          "concept": "reader",
          "source": "cross_book_summa"
        },
        {
          "concept": "readers",
          "source": "cross_book_summa"
        },
        {
          "concept": "chapters",
          "source": "cross_book_summa"
        },
        {
          "concept": "names",
          "source": "cross_book_summa"
        },
        {
          "concept": "container",
          "source": "cross_book_summa"
        },
        {
          "concept": "main",
          "source": "cross_book_summa"
        },
        {
          "concept": "create",
          "source": "cross_book_summa"
        },
        {
          "concept": "meaning",
          "source": "cross_book_summa"
        },
        {
          "concept": "means",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 21,
      "title": "Segment 21 (pages 176-183)",
      "start_page": 176,
      "end_page": 183,
      "summary": "The first form of inheritance is interface inheritance, in which a parent class defines the signatures for one or more methods, but does not implement the methods.\nHowever, implementation inheritance creates dependencies between the parent class and each of its subclasses.\nFor example, a developer making changes to the parent class may need to examine all of the subclasses to ensure that the changes don’t break anything.\nSimilarly, if a subclass overrides a method in the parent class, the developer of the subclass may need to examine the implementation in the parent.\nAgile development is mostly about the process of software development (organizing teams, managing schedules, the role of unit testing, interacting with customers, etc.) as opposed to software design.\nIn the agile approach, a software system is developed in a series of iterations, each of which adds and evaluates a few new features; each iteration includes design, test, and customer input.\nThe best way to end up with a good design is to develop a system in increments, where each increment adds a few new abstractions and refactors existing abstractions based on experience.\nAgile development tends to focus developers on features, not abstractions, and it encourages developers to put off design decisions in order to produce working software as soon as possible.\nHowever, one of the tenets of agile development is that testing should be tightly integrated with development, and programmers should write tests for their own code.\nUnit tests are the ones most often written by developers.\nTests, particularly unit tests, play an important role in software design because they facilitate refactoring.\nAs a result, developers avoid refactoring in systems without good test suites; they try to minimize the number of code changes for each new feature or bug fix, which means that complexity accumulates and design mistakes don’t get corrected.\nWith a good set of tests, developers can be more confident when refactoring because the test suite will find most bugs that are introduced.\nThis encourages developers to make structural improvements to a system, which results in a better design.\n19.4 Test-driven development\nTest-driven development is an approach to software development where programmers write unit tests before they write code.\nWhen creating a new class, the developer first writes unit tests for the class, based on its expected\nNone of the tests pass, since there is no code for the class.\nThen the developer works through the tests one at a time, writing enough code for that test to pass.\nAlthough I am a strong advocate of unit testing, I am not a fan of test- driven development.\nThe problem with test-driven development is that it focuses attention on getting specific features working, rather than finding the best design.\nTest-driven development is too incremental: at any point in time, it’s tempting to just hack in the next feature to make the next test pass.\nIf you fix the bug before writing the test, it’s possible that the new unit test doesn’t actually trigger the bug, in which case it won’t tell you whether you really fixed the problem.\nThe notion of design patterns was popularized by the book Design Patterns: Elements of Reusable Object- Oriented Software by Gamma, Helm, Johnson, and Vlissides, and design patterns are now widely used in object-oriented software development.\nIn the Java programming community, getter and setter methods are a popular design pattern.\nOne of the risks of establishing a design pattern is that developers assume the pattern is good and try to use it as much as possible.",
      "keywords": [
        "design",
        "Design patterns",
        "Unit tests",
        "development",
        "parent class",
        "software development",
        "Software",
        "Agile development",
        "implementation inheritance",
        "inheritance",
        "unit",
        "parent",
        "unit test",
        "implementation",
        "methods"
      ],
      "concepts": [
        "tested",
        "designs",
        "design",
        "designing",
        "development",
        "developed",
        "develop",
        "developers",
        "developing",
        "inheritance"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 21,
          "title": "Segment 21 (pages 176-183)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "design",
          "score": 0.009,
          "source": "cross_book_yake"
        },
        {
          "term": "development",
          "score": 0.011,
          "source": "cross_book_yake"
        },
        {
          "term": "Unit tests",
          "score": 0.013,
          "source": "cross_book_yake"
        },
        {
          "term": "software development",
          "score": 0.016,
          "source": "cross_book_yake"
        },
        {
          "term": "software",
          "score": 0.017,
          "source": "cross_book_yake"
        },
        {
          "term": "design patterns",
          "score": 0.017,
          "source": "cross_book_yake"
        },
        {
          "term": "unit",
          "score": 0.018,
          "source": "cross_book_yake"
        },
        {
          "term": "Agile development",
          "score": 0.022,
          "source": "cross_book_yake"
        },
        {
          "term": "Test-driven development",
          "score": 0.023,
          "source": "cross_book_yake"
        },
        {
          "term": "design Design patterns",
          "score": 0.024,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "developed",
          "source": "cross_book_summa"
        },
        {
          "concept": "develop",
          "source": "cross_book_summa"
        },
        {
          "concept": "developers",
          "source": "cross_book_summa"
        },
        {
          "concept": "developing",
          "source": "cross_book_summa"
        },
        {
          "concept": "design",
          "source": "cross_book_summa"
        },
        {
          "concept": "designing",
          "source": "cross_book_summa"
        },
        {
          "concept": "unit",
          "source": "cross_book_summa"
        },
        {
          "concept": "inheritance",
          "source": "cross_book_summa"
        },
        {
          "concept": "software",
          "source": "cross_book_summa"
        },
        {
          "concept": "writes",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 22,
      "title": "Segment 22 (pages 184-192)",
      "start_page": 184,
      "end_page": 192,
      "summary": "On the other hand, if you completely ignore performance issues, it’s easy to end up with a large number of significant inefficiencies spread throughout the code; the resulting system can easily be 5–10x slower than it needs to be.\nWe use these both to understand the performance of existing libraries used in RAMCloud, and also to measure the performance of new classes written for RAMCloud.\nIf the faster design adds a lot of implementation complexity, or if it results in more complicated interfaces, then it may be better to start off with the simpler approach and optimize later if performance turns out to be a problem.\nIf you start making changes based on intuition, you’ll waste time on things that don’t actually improve performance, and you’ll probably make the system more complicated in the process.\nYou’ll need to measure deeper to identify in detail the factors that contribute to overall performance; the goal is to identify a small number of very specific places where the system is currently spending a lot of time, and where you have ideas for improvement.\nThe key idea is to design the code around the critical path.\nImagine instead that you are writing a new method that implements just the critical path, which is the minimum amount of code that must be executed in the the most common case.\nThe current code may also use a variety of variables and data structures; consider only the data needed for the critical path, and assume whatever data structure is most convenient for the critical path.\nYou may have to add a bit of extra code to the ideal in order to allow clean abstractions; for example, if the code involves a hash table lookup, it’s OK to introduce an extra method call to a general-purpose hash table class.\nEach special case adds a little bit of code to the critical path, in the form of extra conditional statements and/or method calls.\nIf the initial test fails (which means a special case has occurred) the code can branch to a separate place off the critical path to handle it.\nPerformance isn’t as important for special cases, so you can structure the special-case code for simplicity rather than performance.\nLet’s consider an example, in which the Buffer class of the RAMCloud storage system was optimized to achieve a speedup of about 2x for the most common operations.\nBuffers are designed to reduce overheads from memory copying and dynamic storage allocation.\nEach Buffer contains a small built-in allocation, which is a block of memory available for storing internal chunks.\nFigure 20.1: A Buffer object uses a collection of memory chunks to store what appears to be a linear array of bytes.\nFor example, when assembling a response message containing a short header and the contents of a large object in the RAMCloud storage system, RAMCloud uses a Buffer with two chunks.\nAside from the fundamental approach of allowing discontiguous chunks, we did not attempt to optimize the code of the Buffer class in the original implementation.\nWe decided to see if we could improve the performance of the Buffer class.\nThe most common operation for Buffer is to allocate space for a small amount of new data using an internal chunk.\nIn the simplest possible case, the space can be allocated by enlarging the last existing chunk in the Buffer.\nThe ideal code would perform a single check to confirm that the\nFigure 20.2 shows the original code for the critical path, which starts with the method Buffer::alloc.\nThe code checks twice to see if the current allocation has enough room for the new data: once in Buffer::Allocation::allocateAppend, and again when its return value is tested by Buffer::allocateAppend.\nFurthermore, rather than trying to expand the last chunk directly, the code allocates new space without any consideration of the last chunk.\nThen Buffer::alloc checks to see if that space happens to be adjacent to the last chunk, in which case it merges the new space with the existing chunk.\nThe critical path makes two additional method calls in addition to the original invocation of Buffer::alloc.\nBuffer::allocateAppend is nearly a pass-though method; its only contribution is to create a new allocation if needed.\nTo fix these problems, we refactored the Buffer class so that its design is centered around the most performance-critical paths.\nWe considered not just the allocation code above but several other commonly executed paths, such as retrieving the total number of bytes of data currently stored in a Buffer.\nFor each of these critical paths, we tried to identify the smallest amount of code that must be executed in the common case.",
      "keywords": [
        "Buffer",
        "code",
        "Performance",
        "critical path",
        "Buffer class",
        "system",
        "chunk",
        "critical",
        "chunks",
        "design",
        "special cases",
        "path",
        "cases",
        "RAMCloud",
        "case"
      ],
      "concepts": [
        "performance",
        "perform",
        "code",
        "buffer",
        "buffers",
        "designing",
        "design",
        "designed",
        "allocating",
        "allocate"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 22,
          "title": "Segment 22 (pages 184-192)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "code buffer buffers",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "Buffer",
          "score": 0.003,
          "source": "cross_book_yake"
        },
        {
          "term": "Buffer class",
          "score": 0.007,
          "source": "cross_book_yake"
        },
        {
          "term": "Buffer code Performance",
          "score": 0.007,
          "source": "cross_book_yake"
        },
        {
          "term": "critical path",
          "score": 0.007,
          "source": "cross_book_yake"
        },
        {
          "term": "code",
          "score": 0.008,
          "source": "cross_book_yake"
        },
        {
          "term": "buffer buffers",
          "score": 0.008,
          "source": "cross_book_yake"
        },
        {
          "term": "buffer buffers designing",
          "score": 0.008,
          "source": "cross_book_yake"
        },
        {
          "term": "critical path Buffer",
          "score": 0.009,
          "source": "cross_book_yake"
        },
        {
          "term": "path Buffer class",
          "score": 0.014,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "performance",
          "source": "cross_book_summa"
        },
        {
          "concept": "perform",
          "source": "cross_book_summa"
        },
        {
          "concept": "chunks",
          "source": "cross_book_summa"
        },
        {
          "concept": "chunk",
          "source": "cross_book_summa"
        },
        {
          "concept": "buffer",
          "source": "cross_book_summa"
        },
        {
          "concept": "buffers",
          "source": "cross_book_summa"
        },
        {
          "concept": "code",
          "source": "cross_book_summa"
        },
        {
          "concept": "allocation",
          "source": "cross_book_summa"
        },
        {
          "concept": "allocate",
          "source": "cross_book_summa"
        },
        {
          "concept": "allocated",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 23,
      "title": "Segment 23 (pages 193-200)",
      "start_page": 193,
      "end_page": 200,
      "summary": "Figure 20.2: The original code for allocating new space at the end of a Buffer, using an internal chunk.\nFigure 20.3: The new code for allocating new space in an internal chunk of a Buffer.\nFigure 20.3 shows the new critical path for allocating internal space in a Buffer.\nThe new code is about twice as fast as the old code: the total time to append a 1-byte string to a Buffer using internal storage dropped from 8.8 ns to 4.75 ns.\nFor example, the time to construct a new Buffer, append a small\nThe Buffer class rewrite improved its performance by a factor of 2 while simplifying its design and reducing code size by 20%.\nDealing with complexity is the most important challenge in software design.\nIf the only thing that matters to you is making your current code work as soon as possible, then thinking about design will seem like drudge work that is getting in the way of your real goal.\nOn the other hand, if good design is an important goal for you, then the ideas in this book should make programming more fun.\nFurthermore, the investments you make in good design will pay off quickly.\nThe time you spent honing your design skills will also pay for itself: as your skills and experience grow, you will find that you can produce good designs more and more quickly.\nPoor designers spend most of their time chasing bugs in complicated and brittle code.\nas design tool, 131 benefits, 98 canary in the coal mine, 131 conventions for, 102 duplication, 138 for intuition, 107 for precision, 105 implementation, 116 interface, 110 near code, 137 obsolete, 98 procrastination, 129 repeating code, 103 role in abstraction, 101 worthless, 98 writing before code, 129",
      "keywords": [
        "Buffer",
        "design",
        "code",
        "Buffer length",
        "total Buffer length",
        "allocating internal space",
        "internal chunk",
        "total Buffer",
        "good design",
        "chunk",
        "internal",
        "space",
        "time",
        "good",
        "original code"
      ],
      "concepts": [
        "code",
        "coding",
        "design",
        "designs",
        "designer",
        "designers",
        "buffer",
        "file",
        "examples",
        "abstractions"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 23,
          "title": "Segment 23 (pages 193-200)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "Buffer",
          "score": 0.008,
          "source": "cross_book_yake"
        },
        {
          "term": "code",
          "score": 0.016,
          "source": "cross_book_yake"
        },
        {
          "term": "Buffer design code",
          "score": 0.019,
          "source": "cross_book_yake"
        },
        {
          "term": "design code Buffer",
          "score": 0.019,
          "source": "cross_book_yake"
        },
        {
          "term": "design",
          "score": 0.021,
          "source": "cross_book_yake"
        },
        {
          "term": "Buffer good design",
          "score": 0.024,
          "source": "cross_book_yake"
        },
        {
          "term": "total Buffer",
          "score": 0.027,
          "source": "cross_book_yake"
        },
        {
          "term": "internal",
          "score": 0.029,
          "source": "cross_book_yake"
        },
        {
          "term": "Buffer length",
          "score": 0.032,
          "source": "cross_book_yake"
        },
        {
          "term": "code Buffer",
          "score": 0.037,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "coding",
          "source": "cross_book_summa"
        },
        {
          "concept": "implementation",
          "source": "cross_book_summa"
        },
        {
          "concept": "interface",
          "source": "cross_book_summa"
        },
        {
          "concept": "design",
          "source": "cross_book_summa"
        },
        {
          "concept": "designs",
          "source": "cross_book_summa"
        },
        {
          "concept": "designers",
          "source": "cross_book_summa"
        },
        {
          "concept": "designer",
          "source": "cross_book_summa"
        },
        {
          "concept": "near",
          "source": "cross_book_summa"
        },
        {
          "concept": "precision",
          "source": "cross_book_summa"
        },
        {
          "concept": "work",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 24,
      "title": "Segment 24 (pages 201-208)",
      "start_page": 201,
      "end_page": 208,
      "summary": "masking exceptions, 81 memory allocation, dynamic, 160 method interface comment, 110 micro-benchmark, 160 missing parameter example, 82 modular design, 2, 19 module, 20\nselection/cursor example, 65 self-documenting code, 96 setter, 156 shallow module, 25 small classes, 26 special-purpose code, 62, 67 specification, formal, 21 strategic programming, 14, 135 style, coding, 141 substring example (Java), 80 system tests, 154\n2. Working code isn’t enough (see p.\n5. Interfaces should be designed to make the most common usage as simple as possible (see p.\n8. Separate general-purpose and special-purpose code (see p.\nDesign it twice (see p.\nComments should describe things that are not obvious from the code (see p.\nInformation Leakage: a design decision is reflected in multiple modules (see p.\nTemporal Decomposition: the code structure is based on the order in which operations are executed, not on information hiding (see p.\nComment Repeats Code: all of the information in a comment is immediately obvious from the code next to the comment (see p.\nVague Name: the name of a variable or method is so imprecise that it doesn’t convey much useful information (see p.\n(see p.\n(see p.",
      "keywords": [
        "NFS server crash",
        "HTTP parameters",
        "Java substring",
        "HTTP server",
        "RAMCloud Buffer",
        "RAMCloud Status",
        "HTTP response",
        "NFS server",
        "Java",
        "tactical programming",
        "formal parts",
        "performance micro-benchmark",
        "code",
        "RAMCloud error promotion",
        "object-oriented programming"
      ],
      "concepts": [
        "code",
        "coding",
        "interface",
        "interfaces",
        "design",
        "designing",
        "designed",
        "method",
        "methods",
        "module"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 24,
          "title": "Segment 24 (pages 201-208)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "code",
          "score": 0.019,
          "source": "cross_book_yake"
        },
        {
          "term": "HTTP parameters Java",
          "score": 0.046,
          "source": "cross_book_yake"
        },
        {
          "term": "Java substring HTTP",
          "score": 0.046,
          "source": "cross_book_yake"
        },
        {
          "term": "NFS server Java",
          "score": 0.048,
          "source": "cross_book_yake"
        },
        {
          "term": "Java",
          "score": 0.049,
          "source": "cross_book_yake"
        },
        {
          "term": "comment",
          "score": 0.062,
          "source": "cross_book_yake"
        },
        {
          "term": "design",
          "score": 0.065,
          "source": "cross_book_yake"
        },
        {
          "term": "NFS server",
          "score": 0.066,
          "source": "cross_book_yake"
        },
        {
          "term": "Information",
          "score": 0.066,
          "source": "cross_book_yake"
        },
        {
          "term": "Comment Repeats Code",
          "score": 0.068,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "code",
          "source": "cross_book_summa"
        },
        {
          "concept": "coding",
          "source": "cross_book_summa"
        },
        {
          "concept": "module",
          "source": "cross_book_summa"
        },
        {
          "concept": "modules",
          "source": "cross_book_summa"
        },
        {
          "concept": "programming",
          "source": "cross_book_summa"
        },
        {
          "concept": "information",
          "source": "cross_book_summa"
        },
        {
          "concept": "design",
          "source": "cross_book_summa"
        },
        {
          "concept": "designed",
          "source": "cross_book_summa"
        },
        {
          "concept": "designing",
          "source": "cross_book_summa"
        },
        {
          "concept": "server",
          "source": "cross_book_summa"
        }
      ]
    },
    {
      "chapter_number": 25,
      "title": "Segment 25 (pages 209-210)",
      "start_page": 209,
      "end_page": 210,
      "summary": "Ousterhout received a BS degree in Physics from Yale University and a PhD in Computer Science from Carnegie Mellon University.",
      "keywords": [
        "Bosack Lerner Professor",
        "Author John Ousterhout",
        "Author John",
        "Bosack Lerner",
        "Lerner Professor",
        "Stanford University",
        "Carnegie Mellon University",
        "John Ousterhout",
        "Computer Science",
        "National Science Foundation",
        "Science Foundation Presidential",
        "Murray Hopper Award",
        "Young Investigator Award",
        "Professor of Computer",
        "Software System Award"
      ],
      "concepts": [
        "national",
        "science",
        "foundation",
        "john",
        "presidential",
        "academy",
        "young",
        "received",
        "storage",
        "author"
      ],
      "related_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 25,
          "title": "Segment 25 (pages 209-210)",
          "relevance_score": 1.0,
          "method": "cosine_similarity"
        }
      ],
      "keywords_enriched": [
        {
          "term": "Carnegie Mellon University",
          "score": 0.0,
          "source": "cross_book_yake"
        },
        {
          "term": "Ousterhout Computer Science",
          "score": 0.001,
          "source": "cross_book_yake"
        },
        {
          "term": "University Carnegie Mellon",
          "score": 0.001,
          "source": "cross_book_yake"
        },
        {
          "term": "Science Foundation Science",
          "score": 0.001,
          "source": "cross_book_yake"
        },
        {
          "term": "National Science Foundation",
          "score": 0.001,
          "source": "cross_book_yake"
        },
        {
          "term": "Mellon University John",
          "score": 0.001,
          "source": "cross_book_yake"
        },
        {
          "term": "University John Ousterhout",
          "score": 0.001,
          "source": "cross_book_yake"
        },
        {
          "term": "John Ousterhout Computer",
          "score": 0.001,
          "source": "cross_book_yake"
        },
        {
          "term": "Science National Science",
          "score": 0.002,
          "source": "cross_book_yake"
        },
        {
          "term": "Stanford University Carnegie",
          "score": 0.002,
          "source": "cross_book_yake"
        }
      ],
      "concepts_enriched": [
        {
          "concept": "university",
          "source": "cross_book_summa"
        },
        {
          "concept": "john",
          "source": "cross_book_summa"
        },
        {
          "concept": "award",
          "source": "cross_book_summa"
        },
        {
          "concept": "author",
          "source": "cross_book_summa"
        },
        {
          "concept": "young",
          "source": "cross_book_summa"
        },
        {
          "concept": "presidential",
          "source": "cross_book_summa"
        },
        {
          "concept": "professor",
          "source": "cross_book_summa"
        },
        {
          "concept": "foundation",
          "source": "cross_book_summa"
        },
        {
          "concept": "science",
          "source": "cross_book_summa"
        },
        {
          "concept": "national",
          "source": "cross_book_summa"
        }
      ]
    }
  ]
}