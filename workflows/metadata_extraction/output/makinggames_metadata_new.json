[
  {
    "chapter_number": 1,
    "title": "– Installing Python and Pygame ...................................................................................... 1",
    "start_page": 7,
    "end_page": 9,
    "summary": "Who is this book for?\nAbout This Book ..............................................................................................................................\nChapter 1 – Installing Python and Pygame ......................................................................................\nInstalling Pygame.........................................................................................................................\nChapter 2 – Pygame Basics ..............................................................................................................\nSource Code for Hello World with Pygame ................................................................................\nSetting Up a Pygame Program .....................................................................................................\npygame.event.Event Objects ...........................................................................................\nThe QUIT Event and pygame.quit() Function ..................................................................\niv    http://inventwithpython.com/pygame \npygame.Color Objects ..........................................................................................................\npygame.PixelArray Objects ..............................................................................................\nDrawing Images with pygame.image.load() and blit() ............................................\nCreating the Board Data Structure: Step 1 – Get All Possible Icons .........................................\nStep 2 – Shuffling and Truncating the List of All Icons ............................................................\nDrawing the Icon, and Syntactic Sugar ......................................................................................\nDrawing the Box Cover .............................................................................................................\nHandling the Revealing and Covering Animation .....................................................................",
    "keywords": [
      "TABLE OF CONTENTS",
      "Book iii TABLE",
      "iii TABLE",
      "Installing Python",
      "Book",
      "Game",
      "Drawing",
      "Objects",
      "Source Code",
      "Memory Puzzle",
      "Pygame",
      "Animation",
      "Icons",
      "TABLE",
      "CONTENTS"
    ],
    "concepts": [
      "pygame",
      "drawing",
      "animation",
      "objects",
      "function",
      "functions",
      "vs",
      "instructions",
      "chapter",
      "coordinates"
    ]
  },
  {
    "chapter_number": 4,
    "title": "– Slide Puzzle ................................................................................................................ 77",
    "start_page": 10,
    "end_page": 11,
    "summary": "Why Bother Having a main() Function?\nSource Code to Slide Puzzle ......................................................................................................\nSliding Tiles with the Mouse .....................................................................................................\nSliding Tiles with the Keyboard ................................................................................................\nDrawing a Tile ...........................................................................................................................\nDrawing the Board .....................................................................................................................\nDrawing the Border of the Board ...............................................................................................\nDrawing the Buttons ................................................................................................................\nAnimating the Tile Slides ........................................................................................................\nAnimating the Board Reset ......................................................................................................\nDrawing the Board to the Screen .............................................................................................\nDrawing the Buttons ................................................................................................................",
    "keywords": [
      "Slide Puzzle",
      "Play Slide Puzzle",
      "Board Data Structure",
      "Board",
      "Drawing the Board",
      "Drawing",
      "Buttons",
      "Converting Tile Coordinates",
      "Sliding Tiles",
      "Board Data",
      "Slide",
      "Puzzle",
      "Drawing the Buttons",
      "Tile Slide",
      "Tile"
    ],
    "concepts": [
      "drawing",
      "slide",
      "sliding",
      "slides",
      "puzzle",
      "buttons",
      "button",
      "coordinates",
      "pygame",
      "event"
    ]
  },
  {
    "chapter_number": 6,
    "title": "– Wormy ...................................................................................................................... 131",
    "start_page": 12,
    "end_page": 13,
    "summary": "viii    http://inventwithpython.com/pygame \nEmail questions to the author: al@inventwithpython.com \nThe Event Handling Loop ........................................................................................................\nCollision Detection ..................................................................................................................\nDetecting Collisions with the Apple ........................................................................................\nMoving the Worm ....................................................................................................................\nDeciding Where the Apple Appears ........................................................................................\nDon’t Reuse Variable Names ...................................................................................................\nSetting up Timing Constants for Holding Down Keys ............................................................\nThe Event Handling Loop ........................................................................................................\nUsing Movement Variables to Handle User Input ...................................................................\nMoving by Holding Down the Key..........................................................................................",
    "keywords": [
      "Function",
      "Screen",
      "Text Screen Function",
      "Setup Code",
      "Start Screen Text",
      "Coordinates to Buttons",
      "Event Handling Loop",
      "Drawing",
      "Code",
      "Start Screen",
      "Source Code",
      "Board Data Structure",
      "Converting from Pixel",
      "Converting",
      "Buttons"
    ],
    "concepts": [
      "function",
      "functions",
      "screen",
      "screens",
      "drawing",
      "text",
      "chapter",
      "piece",
      "pieces",
      "variable"
    ]
  },
  {
    "chapter_number": 8,
    "title": "– Squirrel Eat Squirrel ................................................................................................. 200",
    "start_page": 14,
    "end_page": 15,
    "summary": "Chapter 8 – Squirrel Eat Squirrel .................................................................................................\nHow to Play Squirrel Eat Squirrel............................................................................................\nThe Design of Squirrel Eat Squirrel .........................................................................................\nSource Code to Squirrel Eat Squirrel .......................................................................................\nThe Game Loop .......................................................................................................................\nMoving the Enemy Squirrels ...................................................................................................\nAdding New Grass and Squirrel Objects .................................................................................\nDrawing the Background, Grass, Squirrels, and Health Meter ................................................\nFinding a Place to Add New Squirrels and Grass ....................................................................\nCreating Enemy Squirrel Data Structures ................................................................................\nCreating Grass Data Structures ................................................................................................\nData Structures in Star Pusher .................................................................................................",
    "keywords": [
      "Squirrel Eat Squirrel",
      "Squirrel Eat",
      "Eat Squirrel",
      "Squirrel",
      "Drawing the Score",
      "Squirrel Data Structures",
      "Play Squirrel Eat",
      "Data Structures",
      "Star Pusher",
      "Drawing",
      "Grass Data Structures",
      "Enemy Squirrel Data",
      "Eat",
      "Data",
      "Squirrel Objects"
    ],
    "concepts": [
      "function",
      "functions",
      "squirrel",
      "squirrels",
      "data",
      "grass",
      "files",
      "file",
      "text",
      "drawing"
    ]
  },
  {
    "chapter_number": 10,
    "title": "– Four Extra Games ................................................................................................... 289",
    "start_page": 16,
    "end_page": 24,
    "summary": "Chapter 1 – Installing Python and Pygame    1 \nPYTHON AND PYGAME \nIt might help if you know a bit about Python programming (or how to program in another \nlanguage besides Python) before you read through this book; however even if you haven’t you \nYou don’t need to know how to use the Pygame library before reading this book.\nJust in case you haven’t read the first book and already installed Python and Pygame on your \nDownloading and Installing Python \nBefore we can begin programming you'll need to install software called the Python interpreter on \nthe interpreter, your computer won't be able to run your Python programs.\nprogramming language, http://www.python.org.\ndownload and install the Python software.\ncan also find videos online of people installing the Python software on their computers at \ndoes not include source)‖ and click on its link to download Python for Windows.\nDouble-click on the python-3.2.msi file that you've just downloaded to start the Python installer.\nMac OS X 10.5 comes with Python 2.5.1 pre-installed by Apple.\nHowever, the programs in this book work with both Python \nPygame for Linux also only supports Python 2, not Python 3.\nyou can install Python by opening a terminal window (from the desktop click on Applications > \nAccessories > Terminal) and entering ―sudo apt-get install python2.7‖ then \nYou will need to enter the root password to install Python, so ask the person who \neasy to write Python programs, just like word processor software makes it easy to write books.\nIf your operating system is Windows XP, you should be able to run Python by clicking the Start \nbutton, then selecting Programs, Python 3.1, IDLE (Python GUI).\nChapter 1 – Installing Python and Pygame    3 \nInstalling Pygame \nPygame does not come with Python.\nLike Python, Pygame is available for free.\ndownload and install Pygame, which is as easy as downloading and installing the Python \ninstaller for your operating system and the version of Python you have installed.\nPygame for Python 3.2 on Windows.\nIf you installed a different version of Python (such as 2.7 or \n2.6) download the .msi file for your version of Python.) The current version of Pygame at the \nFor Mac OS X, download the .zip or .dmg file for the version of Python you have and run it.\nFor Linux, open a terminal and run ―sudo apt-get install python-pygame‖.\nOn Windows, double click on the downloaded file to install Pygame.\ninstall Pygame again (and make sure you typed import pygame correctly).\nPython with Pygame.\nA video tutorial of how to install Pygame is available from this book's website at \n―Making Games with Python & Pygame‖ is different from other programming books because it \nIt is very helpful to copy these programs by typing in the code line by line from this book.\nHowever, you can also download the source code file from this book's website.\ngo to the URL http://invpy.com/source and follow the instructions to download the source code \nWhile you can just type in the code you read out of this book, you will need to download the \ngraphics and sound files used by the games in this book from http://invpy.com/downloads.\notherwise your Python program will not be able to find these files.\nWhen entering the source code yourself, do not type the line numbers that appear at the beginning \nChapter 1 – Installing Python and Pygame    5 \nThose numbers are only used so that this book can refer to specific lines in the code.\nSome lines of code are too long to fit on one line on the pages in this book, and the text of the \ntyping out the source code for these programs, you may accidentally make typos that cause your \nYou can copy and paste the text of your source code to the online diff tool on the book’s website.\nThe online diff tool is at this web page: http://invpy.com/diff/pygame.",
    "keywords": [
      "Python",
      "Flood Fill Algorithm",
      "Pygame",
      "Fill Algorithm",
      "Installing Python",
      "Book",
      "Source Code",
      "Code",
      "Installing Pygame Pygame",
      "Python interpreter",
      "IDLE",
      "line",
      "install Pygame",
      "Python programs",
      "Windows"
    ],
    "concepts": [
      "python",
      "pygame",
      "programming",
      "program",
      "programs",
      "book",
      "books",
      "windows",
      "window",
      "downloading"
    ]
  },
  {
    "chapter_number": 2,
    "title": "– Pygame Basics    7",
    "start_page": 25,
    "end_page": 31,
    "summary": "additional functions for your programs, the Pygame framework includes several modules with \nThis chapter will cover the basic modules and functions that Pygame provides and assumes you \nPygame provides functions for creating programs with a graphical user interface, or GUI \nOur first program made with Pygame is a small program that makes a window that says ―Hello \n1. import pygame, sys \n2. from pygame.locals import * \n8.     for event in pygame.event.get(): \npygame.quit() \nPygame uses other functions for input and output which are explained later in this \nSetting Up a Pygame Program \nprogram you write that uses Pygame.\n1. import pygame, sys \nLine 1 is a simple import statement that imports the pygame and sys modules so that our \nprogram can use the functions in them.\nAll of the Pygame functions dealing with graphics, sound, \nLine 4 is the pygame.init() function call, which always needs to be called after importing \nthe pygame module and before calling any other Pygame function.\nthis function does, you just need to know that it needs to be called first in order for many Pygame \nLine 5 is a call to the pygame.display.set_mode() function, which returns the \npygame.Surface object for the window.\ncorrect way to call the function is like this: pygame.display.set_mode((400, 300)).\nA function call like pygame.display.set_mode(400, 300) will cause an error that \npygame.display.set_caption() function.\n8.     for event in pygame.event.get(): \nevents have been created (with Pygame, this is done by calling the pygame.event.get() \nThe main loop also has code that updates the game state based on which events have \npygame.event.Event Objects \npygame.event.Event object is created by the Pygame library to record this ―event‖.\na type of object called Event that exists in the event module, which itself is in the pygame \nmodule.) We can find out which events have happened by calling the pygame.event.get() \nfunction, which returns a list of pygame.event.Event objects (which we will just call Event \npygame.event.get() function was called.\n(Or, if pygame.event.get() has never been \ncalled, the events that have happened since the start of the program.) \n8.     for event in pygame.event.get(): \nLine 8 is a for loop that will iterate over the list of Event objects that was returned by \npygame.event.get().\nfrom pygame.event.get() will be in the order that the events happened.\nhave happened, then pygame.event.get() will return a blank list.\nThe QUIT Event and pygame.quit() Function \npygame.quit() \nLine 9 checks if the Event object’s type is \nIf the Event object is a quit event, then the pygame.quit() and sys.exit() functions are \nThe pygame.quit() function is sort of the opposite of the pygame.init() \nfunction: it runs code that deactivates the Pygame library.\npygame.quit() before they call sys.exit() to terminate the program.\nthat causes IDLE to hang if a Pygame program terminates before pygame.quit() is called.\nobjects that have been returned by pygame.event.get(), the program execution continues \nLine 12 calls the pygame.display.update() function, which draws the Surface object \nreturned by pygame.display.set_mode() to the screen (remember we stored this object \nto the screen each time pygame.display.update() is called.\nPygame drawing functions.\nCoordinates work in Pygame (and almost every programming language).",
    "keywords": [
      "Pygame",
      "event",
      "Event objects",
      "program",
      "Pygame Basics",
      "function",
      "pygame module",
      "game",
      "window",
      "line",
      "game state",
      "object",
      "objects",
      "loop",
      "events"
    ],
    "concepts": [
      "pygame",
      "programs",
      "programming",
      "program",
      "import",
      "imports",
      "importing",
      "functions",
      "function",
      "line"
    ]
  },
  {
    "chapter_number": 12,
    "title": "of ―Invent Your Own Computer Games with",
    "start_page": 32,
    "end_page": 50,
    "summary": "The Pygame framework often represents Cartesian Coordinates as a tuple of two integers, such as \nan object.\nFor example, pygame.Rect() and pygame.Surface() are both constructor functions \ninside the pygame module that return new Rect and Surface objects.\n(These objects are \nregular function, but it is a safe bet.) The object is stored in a variable named egg.\nSurface Objects and The Window \nThe pixels of the Surface object \ncan be changed by calling the Pygame drawing functions (described later in this chapter) and then \nSurface object.\nIn particular, the Surface object returned by pygame.display.set_mode() is called the \nAnything that is drawn on the display Surface object will be displayed on the \nwindow when the pygame.display.update() function is called.\non a Surface object (which only exists in the computer’s memory) than it is to draw a Surface \nOften your program will draw several different things to a Surface object.\ndrawing everything on the display Surface object for this iteration of the game loop (called a \nframe, just like a still image on a paused DVD is called) on a Surface object, it can be drawn to \nDrawing on Surface objects will be covered in the ―Primitive Drawing Functions‖ and ―Drawing \nColors \nIn Pygame, we \nrepresent colors with tuples of three integers.\ncolor.\nThese tuples of three integers used to represent a color are often called RGB values.\nmeans Pygame can draw 16,777,216 different colors (that is, 256 x 256 x 256 colors).\nColor \ncolor is.\nNormally when you draw a pixel onto a surface object, the new color completely \nFor example, this tuple of three integers is for the color green: (0, 255, 0).\nfourth integer for the alpha value, we can make this a half transparent green color: (0, 255, \nIf you draw any color that has an alpha value of 0 to a \nsurface object, it will have no effect, because this color is completely transparent and invisible.\nIn order to draw using transparent colors, you must create a Surface object with the \nFor example, the following code creates a Surface object that \nOnce things have been drawn on the Surface object stored in anotherSurface, then \n(See the ―Drawing Images with pygame.image.load() and blit()‖ section later \nIt’s important to note that you cannot use transparent colors on Surface objects not returned from \npygame.display.set_mode().\nIf we were to create a color tuple to draw the legendary Invisible Pink Unicorn, we would use \npygame.Color Objects \nYou need to know how to represent a color because Pygame’s drawing functions need a way to \nknow what color you want to draw with.\nway is as a pygame.Color object.\nYou can create Color objects by calling the \npygame.Color() constructor function and passing either three or four integers.\nthis Color object in variables just like you can store tuples in variables.\n>>> pygame.Color(255, 0, 0) \n>>> myColor = pygame.Color(255, 0, 0, 128) \nAny drawing function in Pygame (which we will learn about in a bit) that has a parameter for \ncolor can have either the tuple form or Color object form of a color passed for it.\nthey are different data types, a Color object is equal to a tuple of four integers if they both \nNow that you know how to represent colors (as a pygame.Color object or a tuple of three or \nfor X and Y), let’s learn about pygame.Rect objects so we can start using Pygame’s drawing \ncolors).\nThe second way is as a pygame.Rect object, which we will call Rect objects for short.\nexample, the code below creates a Rect object with a top left corner at (10, 20) that is 200 pixels \nedge of the pygame.Rect object we stored in the spamRect variable, you can just access the \nThe Pygame code for the Rect object automatically calculated that if the left edge is at the X \nHere’s a list of all the attributes that pygame.Rect objects provide (in our example, the \nvariable where the Rect object is stored in a variable named myRect): \nPygame provides several different functions for drawing different shapes onto a surface object.\n7. DISPLAYSURF = pygame.display.set_mode((500, 400), 0, 32) \n8. pygame.display.set_caption('Drawing') \n# draw on the surface object \npygame.draw.polygon(DISPLAYSURF, GREEN, ((146, 0), (291, 106), (236, 277), \npygame.draw.line(DISPLAYSURF, BLUE, (60, 60), (120, 60), 4) \npygame.draw.line(DISPLAYSURF, BLUE, (120, 60), (60, 120)) \npygame.draw.line(DISPLAYSURF, BLUE, (60, 120), (120, 120), 4) \npygame.draw.circle(DISPLAYSURF, BLUE, (300, 50), 20, 0) \npygame.draw.ellipse(DISPLAYSURF, RED, (300, 250, 40, 80), 1) \npygame.draw.rect(DISPLAYSURF, RED, (200, 150, 100, 50)) \nfunctions tell them which Surface object to draw on, where to draw the shape (and what size), in \ndrawing.py program, but here is a short description of each function: \nfill(color) – The fill() method is not a function but a method of pygame.Surface \nobjects.\nIt will completely fill in the entire Surface object with whatever color value you pass \npygame.draw.polygon(surface, color, pointlist, width) – A polygon is shape made up of \nThe surface and color parameters tell the function on what surface to \ndraw the polygon, and what color to make it.\nAll of the pygame.draw drawing functions have optional width parameters at the end, \nand they work the same way as pygame.draw.polygon()’s width parameter.\npygame.draw.line(surface, color, start_point, end_point, width) – This function draws a \npygame.draw.lines(surface, color, closed, pointlist, width) – This function draws a series \nof lines from one point to the next, much like pygame.draw.polygon().\npygame.draw.circle(surface, color, center_point, radius, width) – This function draws a \npygame.draw.ellipse(surface, color, bounding_rectangle, width) – This function draws an \nparameters, but in order to tell the function how large and where to draw the ellipse, you must \nThe bounding_rectangle parameter can be a pygame.Rect object or a tuple of four \npygame.draw.circle() function.\npygame.draw.rect(surface, color, rectangle_tuple, width) – This function draws a \nof the top left corner, and the width and height) or a pygame.Rect object can be passed \npygame.PixelArray Objects \nUnfortunately, there isn’t a single function you can call that will set a single pixel to a color \n(unless you call pygame.draw.line() with the same start and end point).\nThe Pygame \nobject.\nInstead, you should create a pygame.PixelArray object (we’ll call them PixelArray objects \nfor short) of a Surface object and then set individual pixels.\nWhile a Surface object is locked, the drawing \nIf you want to see if a Surface object is locked, the get_locked() Surface method will return \nThe PixelArray object that is returned from pygame.PixelArray() can have individual \nTo tell Pygame that you are finished drawing individual pixels, delete the PixelArray object with \nSurface object so that you can once again draw images on it.\nPixelArray object, the next time you try to blit (that is, draw) an image to the Surface the program \nThe pygame.display.update() Function \nAfter you are done calling the drawing functions to make the display Surface object look the way \nyou want, you must call pygame.display.update() to make the display Surface actually \nthe display Surface (that is, the Surface object that was returned from the call to \npygame.display.set_mode()) appear on the screen.\nSurface objects to appear on the screen, you must ―blit‖ them (that is, copy them) to the display \nSurface object with the blit() method (which is explained next in the ―Drawing Images‖ \nNow that we know how to get the Pygame framework to draw to the screen, let’s learn how to \nDISPLAYSURF = pygame.display.set_mode((400, 300), 0, 32) \npygame.display.set_caption('Animation') \nFrames Per Second and pygame.time.Clock Objects \nA pygame.time.Clock object can help us make sure our program runs at a certain maximum \nThis Clock object will ensure that our game programs don’t run too fast by putting in \nClock object in the game loop can make sure the game runs at the same speed no matter how \nThe Clock object’s tick() method should be called at the very end of the game loop, after the \nDrawing Images with pygame.image.load() and blit() \nThe drawing functions are fine if you want to draw simple shapes on the screen, but many games \nPygame is able to load images onto Surface objects from PNG, \n'cat.png' is passed to the pygame.image.load() function.\npygame.image.load() function call will return a Surface object that has the image drawn \nmust blit (that is, copy) the image’s Surface object to the display Surface object.\nIt is done with the blit() Surface object \ncalling pygame.image.load(), then make sure the cat.png file is in the same folder as the \nThe first is the source Surface object, which is what will \nbe copied onto the DISPLAYSURF Surface object.\nIf you want to draw text to the screen, you could write several calls to pygame.draw.line() \npygame.draw.line() calls and figure out all the XY coordinates, and probably wouldn’t \nThe above message would take forty one calls to the pygame.draw.line() function to \nInstead, Pygame provides some much simpler functions for fonts and creating text.\na small Hello World program using Pygame’s font functions.\n5. DISPLAYSURF = pygame.display.set_mode((400, 300)) \n1. Create a pygame.font.Font object.\n2. Create a Surface object with the text drawn on it by calling the Font object’s render() \n3. Create a Rect object from the Surface object by calling the Surface object’s \n(Line 14) This Rect object will have the width and height \npygame.display.set_mode().\n6. Call pygame.display.update() to make the display Surface appear on the screen.\nThe parameters to the pygame.font.Font() constructor function is a string of the font file to \nbackground color parameter in the method call.\nTo make Pygame’s text use anti-aliasing, just pass True for the second parameter of the \nfunctions have the same parameters as pygame.draw.line() and \npygame.draw.lines(), except they will draw anti-aliased (smooth) lines instead of aliased \nFirst, you must create a pygame.mixer.Sound object (which we will call Sound objects \nfor short) by calling the pygame.mixer.Sound() constructor function.\nSound object from playing call the stop() method.\nPygame can only load one music file to \npygame.mixer.music.load() function and pass it a string argument of the sound file to \npygame.mixer.music.play(-1, 0.0) function.",
    "keywords": [
      "Surface object",
      "Surface",
      "display Surface object",
      "object",
      "color",
      "Pygame",
      "DISPLAYSURF Surface object",
      "function",
      "Rect object",
      "display Surface",
      "Pygame Basics",
      "Surface object method",
      "Functions",
      "objects",
      "drawing functions"
    ],
    "concepts": [
      "pygame",
      "colors",
      "color",
      "colored",
      "functions",
      "function",
      "drawing",
      "draw",
      "draws",
      "myrect"
    ]
  },
  {
    "chapter_number": 3,
    "title": "– Memory Puzzle    33",
    "start_page": 51,
    "end_page": 125,
    "summary": "In the Memory Puzzle game, several icons are covered up by white boxes.\nThe player can click on two boxes to see what icon is behind them.\nThe player wins when all the boxes on the board are uncovered.\nThere are several times in the Memory Puzzle code that we need to iterate through every possible \nX and Y coordinate on the board.\nType the following code into the interactive shell, and compare the order it prints values to \nassert (BOARDWIDTH * BOARDHEIGHT) % 2 == 0, 'Board needs to have an even \n\"Board is too big for the number of shapes/colors defined.\" \nmousex = 0 # used to store x coordinate of mouse event \nmousey = 0 # used to store y coordinate of mouse event \npygame.display.set_caption('Memory Game') \nfirstSelection = None # stores the (x, y) of the first box clicked.\nrevealedBoxes[boxx][boxy] = True # set the box as \n# Create the board data structure, with randomly placed icons.\nboard = [] \nboard.append(column) \nreturn board \n# Convert board coordinates to pixel coordinates \npygame.draw.circle(DISPLAYSURF, color, (left + half, top + half), \npygame.draw.circle(DISPLAYSURF, BGCOLOR, (left + half, top + \npygame.draw.rect(DISPLAYSURF, color, (left + quarter, top + \npygame.draw.polygon(DISPLAYSURF, color, ((left + half, top), (left \npygame.draw.line(DISPLAYSURF, color, (left, top + i), (left + \npygame.draw.line(DISPLAYSURF, color, (left + i, top + BOXSIZE \npygame.draw.ellipse(DISPLAYSURF, color, (left, top + quarter, \ndef getShapeAndColor(board, boxx, boxy): \n# shape value for x, y spot is stored in board[x][y][0] \n# color value for x, y spot is stored in board[x][y][1] \nreturn board[boxx][boxy][0], board[boxx][boxy][1] \ndef drawBoxCovers(board, boxes, coverage): \n# Draws boxes being covered/revealed.\n\"boxes\" is a list \n# of two-item lists, which have the x & y spot of the box.\npygame.draw.rect(DISPLAYSURF, BGCOLOR, (left, top, BOXSIZE, \nshape, color = getShapeAndColor(board, box[0], box[1]) \npygame.draw.rect(DISPLAYSURF, BOXCOLOR, (left, top, coverage, \ndef revealBoxesAnimation(board, boxesToReveal): \ndef coverBoxesAnimation(board, boxesToCover): \ndef drawBoard(board, revealed): \n# Draws all of the boxes in their covered or revealed state.\n# Draw a covered box.\npygame.draw.rect(DISPLAYSURF, BOXCOLOR, (left, top, \nshape, color = getShapeAndColor(board, boxx, boxy) \npygame.draw.rect(DISPLAYSURF, HIGHLIGHTCOLOR, (left - 5, top - 5, \ndef startGameAnimation(board): \n# Randomly reveal the boxes 8 at a time.\nboxes = [] \nboxes.append( (x, y) ) \ndef gameWonAnimation(board): \n# Returns True if all the boxes have been revealed, otherwise False \nreturn False # return False if any boxes are covered.\nThis program makes use of many functions in other modules, so it imports those modules on line \nThere are no functions in the \npygame.locals module, but there are several constant variables in it that we want to use such \nThe game programs in this book use a lot of constant variables.\nFor example, instead of using the BOXSIZE variable in our code we could just \nconstant, we only have to change line 13 and the rest of the program is already up to date.\nsize of the white boxes, and changing that 40 accidentally would cause bugs in our program.\nentire board.\nBut if line 18 didn’t use constant variables, it would look like this: \nassert (BOARDWIDTH * BOARDHEIGHT) % 2 == 0, 'Board needs to have an even \nThe assert statement on line 15 ensures that the board width and height we’ve selected will \nresult in an even number of boxes (since we will have pairs of icons in this game).\ncheck to your program to make sure that if the execution ever passes an assertion we can at least \nIf the values we chose for BOARDWIDTH and BOARDHEIGHT that we chose on line 15 and 16 \nresult in a board with an odd number of boxes (such as if the width were 3 and the height were 5), \nof the bug was on line 15 and 16 where we set the BOARDWIDTH and BOARDHEIGHT constants.\nNotice the spacing of the tuples on lines 22 to 31 are such that the \nmore time typing spaces than you would have saved by having readable tuple values.\nThe program also sets up constant variables for some strings.\ndata structure for the board, tracking which spaces on the board have which icons.\nconstant variable instead of the string value is a good idea.\nSince the program has crashed on line 187, when we check that line it will be easy \nvariables and made the same typo, line 187 would look like this: \n\"Board is too big for the number of shapes/colors defined.\" \nIn order for our game program to be able to create icons of every possible color and shape \ncombination, we need to make a tuple that holds all of these values.\nassertion on line 46 to make sure that there are enough color/shape combinations for the size of \nthe board we have.\nIf there isn’t, then the program will crash on line 46 and we will know that we \neither have to add more colors and shapes, or make the board width and height smaller.\ncolors and 5 shapes, we can make 35 (that is, 7 x 5) different icons.\nof each icon, that means we can have a board with up to 70 (that is, 35 x 2, or 7 x 5 x 2) spaces.\nFor an example of trying to change values in lists and tuples, look at the following code: \ncode that uses tuples is slightly faster than code that uses lists.\noptimizations knowing that the values in a tuple will never change.) But having your code run a \nsign that the value in the tuple will never change, so anyone reading the code later will be able to \nused a list.‖ This also lets a future programmer reading your code say, ―If I see a list value, I \nYou can still assign a new tuple value to a variable: \nexample, look at the following two lines of code: \nYou can convert between list and tuple values just like you can convert between string and \nJust pass a tuple value to the list() function and it will return a list form of that \nOr, pass a list value to the tuple() function and it will return a tuple form of that \nlist value.\nmousex = 0 # used to store x coordinate of mouse event \nmousey = 0 # used to store y coordinate of mouse event \npygame.display.set_caption('Memory Game') \ngame code is.\nInside the main() function, those names are not for local variables that might just \nother functions in the program.\n1. If there is a global statement for a variable at the beginning of the function, then the \n2. If the name of a variable in a function has the same name as a global variable and the \nfunction never assigns the variable a value, then that variable is the global variable.\n3. If the name of a variable in a function has the same name as a global variable and the \nfunction does assign the variable a value, then that variable is a local variable.\n4. If there isn't a global variable with the same name as the variable in the function, then \nYou generally want to avoid using global variables inside functions.\nreturn value).\nBut a function that reads and writes to global variables has additional inputs and \nSince the global variable could have been modified in many places before the function \nwas called, it can be tricky to track down a bug involving a bad value set in the global variable.\nHaving a function as a separate mini-program that doesn’t use global variables makes it easier to \nfind bugs in your code, since the parameters of the function are clearly known.\nchanging the code in a function easier, since if the new function works with the same parameters \nand gives the same return value, it will automatically work with the rest of the program just like \nBasically, using global variables might make it easier to write your program but they generally \nconstants that never change, but need the pygame.init() function called first.\nother functions to see them.\nJust write your code so that you pass in values to \nfunctions rather than have the functions read global variables as a general rule.\nThe getRandomizedBoard() function returns a data structure that represents the state of the \nboard.\nThe generateRevealedBoxesData() function returns a data structure that \nThe return values of these functions are two \nIf we have a list value stored in a variable named spam, we could access a value in that list with \nspam[2] is itself a list, then we could use another set of square brackets to retrieve a value in \nin the list that is the third value in spam.\nmap a 2D board to a 2D list value.\nSince the mainBoard variable will store icons in it, if we \nwanted to get the icon on the board at the position (4, 5) then we could just use the expression \nand color, the complete data structure is a list of list of two-item tuples.\nSay the board looked like this: \nicon at the (x, y) coordinate on the board.\nMeanwhile, the ―revealed boxes‖ data structure is also a 2D list, except instead of two-item tuples \nlike the board data structure, it has Boolean values: True if the box at that x, y coordinate is \ngenerateRevealedBoxesData() function sets all of the Boolean values to False.\nThese two data structures are used to keep track of the state of the game board.\nfirstSelection = None # stores the (x, y) of the first box clicked.\nLine 61 sets up a variable called firstSelection with the value None.\nhttp://invpy.com/None) When the player clicks on an icon on the board, the program needs to \nthe firstSelection variable as a tuple of two integers (one for the X value, the other for Y).\nOn the second click the value will be this tuple and not None, which is how the program tracks \nicons are under which boxes.\nThe game loop is an infinite loop that starts on line 66 that keeps iterating for as long as the game \nRemember that the game loop handles events, updates the game state, and draws \nThe game state for the Memory Puzzle program is stored in the following variables: \nOn each iteration of the game loop in the Memory Puzzle program, the mouseClicked variable \nstores a Boolean value that is True if the player has clicked the mouse during this iteration \nThe program then calls drawBoard() to draw the current state of the \n(These lines of \ncode are part of drawing and updating the screen.) \nRemember that our drawing functions only draw on the in-memory display Surface object.\npygame.display.update(), which is done at the end of the game loop on line 121.\nThe for loop on line 72 executes code for every event that has happened since the last iteration \nThis loop is called the event handling loop (which is different from the game \nloop, although the event handling loop is inside of the game loop) and iterates over the list of \npygame.Event objects returned by the pygame.event.get() call.\nIf the event object was a either a QUIT event or a KEYUP event for the Esc key, then the program \nOnce we have handled all of the events, the values stored in mousex, mousey, and \nThe getBoxAtPixel() function will return a tuple of two integers.\nXY board coordinates of the box that the mouse coordinates are over.\ncoordinates were over a box, a tuple of the XY board coordinates are returned by the function and \nthe side of the board or in a gap in between boxes) then the tuple (None, None) is returned by \nthe function and boxx and boxy will both have None stored in them.\nseveral lines of code are in the block following the if statement on line 83 that checks for this \nThe if statement on line 85 checks if the box is covered up or not by reading the value stored in \nWhenever the mouse is over a covered up box, we want to draw a blue highlight around the box \nrevealedBoxes[boxx][boxy] = True # set the box as \nOn line 87, we check if the mouse cursor is not only over a covered up box but if the mouse has \nIn that case, we want to play the ―reveal‖ animation for that box by calling our \nYou should note that calling this function only draws the \nrevealedBoxes[boxx][boxy] = True that the data structure that tracks the game state \nIf you comment out line 89 and then run the program, you’ll notice that after clicking on a box \ngame loop, the board is drawn with this box covered up.\nBefore the execution entered the game loop, the firstSelection variable was set to None.\nOur program will interpret this to mean that no boxes have been clicked, so if line 90’s condition \nfirstSelection variable to a tuple of the box coordinates for the box that was clicked.\nIf this is the second box the player has clicked on, we want to play the reveal animation for that \nfunction (explained later) will retrieve the shape and color values of the icons.\nThe if statement on line 97 checks if either the shapes or colors of the two icons don’t match.\nupdate the game state to mark these boxes as not revealed (that is, covered up).\nHowever, the program should check if this was the last pair of icons on the \nboard to be matched.\nThis is done inside our hasWon() function, which returns True if the \nboard is in a winning state (that is, all of the boxes are revealed).\nreset the data structures in mainBoard and revealedBoxes to start a new game.\nthrough the game loop as usual, and the player can continue playing until they quit the program.\nNo matter if the two boxes were matching or not, after the second box was clicked line 118 will \nset the firstSelection variable back to None so that the next box the player clicks on will \nbe interpreted as the first clicked box of a pair of possibly matching icons.\nof the game loop, so we call pygame.display.update() to draw the DISPLAYSURF \nLine 9 set the FPS constant to the integer value 30, meaning we want the game to run (at most) at \nmeans that pygame.display.update() and all the code in the game loop must execute in \nand the code in the game loop takes longer than 33.3 milliseconds, then the tick() method will \ngone over the main() function and you have an idea for how the general program works, let’s \nThe generateRevealedBoxesData() function needs to create a list of lists of Boolean \nThe Boolean value will just be the one that is passed to the function as the val parameter.\nWe start the data structure as an empty list in the revealedBoxes variable.\nIn order to make the data structure have the revealedBoxes[x][y] structure, we need to \nmake sure that the inner lists represent the vertical columns of the board and not the horizontal \nCreating the Board Data Structure: Step 1 – Get All Possible Icons \nThe board data structure is just a list of lists of tuples, where each tuple has a two values: one for \nWe need to be sure to have exactly as many icons for the number of boxes on the \nboard and also be sure there are two and only two icons of each type.\nfor loops on lines 135 and 136 will go through every possible shape for every possible color.\nThese are each added to the list in the icons variable on line 137.\nBut remember, there may be more possible combinations than spaces on the board.\ncalculate the number of spaces on the board by multiplying BOARDWIDTH by BOARDHEIGHT.\nOn a board with 70 spaces, \nLine 141 uses list slicing to grab the first numIconsUsed number of icons in the list.\non line 139, so it won’t always be the same icons each game.\nthe old list in the icons variable.\nStep 3 – Placing the Icons on the Board \n# Create the board data structure, with randomly placed icons.\nboard = [] \nboard.append(column) \nreturn board \nNow we need to create a list of lists data structure for the board.\nboard, we will create a list of randomly selected icons.\n149 we will then delete them from the front of the icons list on line 150.\nvariable the values 0, 8, and 16 for the three iterations of the for loop.\nThe list slicing on line 160 with theList[i:i + groupSize] creates the lists that are \nThis new list value is the list that is appended to the list in the result variable on line 160.\nwhen we return result at the end of this function, we are returning a list of lists.\n# Convert board coordinates to pixel coordinates \nBut we will also be using another coordinate system for the boxes.\nbox’s top left corner, (220, 165).\nThe leftTopCoordsOfBox() function will take box coordinates and return pixel \nBecause a box takes up multiple pixels on the screen, we will always return the \nsingle pixel at the top left corner of the box.\nThis value will be returned as a two-integer tuple.\nThe leftTopCoordsOfBox() function will often be used when we need pixel coordinates for \ndrawing these boxes.\nWe will also need a function to convert from pixel coordinates (which the mouse clicks and \nmouse movement events use) to box coordinates (so we can find out over which box the mouse \nWhen collidepoint() returns True, we know we have found the box that was clicked on or \nmoved over and will return the box coordinates.\ngetBoxAtPixel() function will return the value (None, None).\nof two values to be returned.\nThe drawIcon() function will draw an icon (with the specified shape and color) at the \ndifferent set of Pygame drawing function calls for it, so we must have a large set of if and elif \nThe X and Y coordinates of the left and top edge of the box can be obtained by calling the \nHowever, many of the shape drawing function calls use the midpoint and \nWe could just as easily have the code int(BOXSIZE * 0.25) instead of the variable \ncalculating a value and storing it in a variable is another type of syntactic sugar.\nthe getRandomizedBoard() function, we could have easily made the code on lines 140 and \nline 141 into a single line of code.\nhave the extra quarter and half variables, but having them makes the code easier to read.\npygame.draw.circle(DISPLAYSURF, color, (left + half, top + half), \npygame.draw.circle(DISPLAYSURF, BGCOLOR, (left + half, top + \npygame.draw.rect(DISPLAYSURF, color, (left + quarter, top + \npygame.draw.polygon(DISPLAYSURF, color, ((left + half, top), (left \npygame.draw.line(DISPLAYSURF, color, (left, top + i), (left + \npygame.draw.line(DISPLAYSURF, color, (left + i, top + BOXSIZE \npygame.draw.ellipse(DISPLAYSURF, color, (left, top + quarter, \nEach of the donut, square, diamond, lines, and oval functions require different drawing primitive \nfunction calls to make.\nSyntactic Sugar with Getting a Board Space’s Icon’s Shape and Color \ndef getShapeAndColor(board, boxx, boxy): \n# shape value for x, y spot is stored in board[x][y][0] \n# color value for x, y spot is stored in board[x][y][1] \nreturn board[boxx][boxy][0], board[boxx][boxy][1] \nThe getShapeAndColor() function only has one line.\nwant a function instead of just typing in that one line of code whenever we need it.\nfor the same reason we use constant variables: it improves the readability of the code.\nBut if you looked a code like shape, color = board[boxx][boxy][0], \nDrawing the Box Cover \ndef drawBoxCovers(board, boxes, coverage): \n# Draws boxes being covered/revealed.\n\"boxes\" is a list \n# of two-item lists, which have the x & y spot of the box.\npygame.draw.rect(DISPLAYSURF, BGCOLOR, (left, top, BOXSIZE, \nshape, color = getShapeAndColor(board, box[0], box[1]) \npygame.draw.rect(DISPLAYSURF, BOXCOLOR, (left, top, coverage, \nThe drawBoxCovers() function has three parameters: the board data structure, a list of (X, Y) \ntuples for each box that should have the cover drawn, and then the amount of coverage to draw \nfor the boxes.\nSince we want to use the same drawing code for each box in the boxes parameter, we will use a \nfor loop on line 211 so we execute the same code on each box in the boxes list.\nfor loop, the code should do three things: draw the background color (to paint over anything that \nwas there before), draw the icon, then draw however much of the white box over the icon that is \nThe leftTopCoordsOfBox() function will return the pixel coordinates of the top \nleft corner of the box.\nThe if statement on line 216 makes sure that if the number in coverage \nhappens to be less than 0, we won’t call the pygame.draw.rect() function.\n20, there is a 20 pixel wide white box covering the icon.\ncoverage set to is the number in BOXSIZE, where the entire icon is completely covered.\nthere is no code being run to handle any events being generated.\ndef revealBoxesAnimation(board, boxesToReveal): \ndef coverBoxesAnimation(board, boxesToCover): \nDrawing the Entire Board \ndef drawBoard(board, revealed): \n# Draws all of the boxes in their covered or revealed state.\n# Draw a covered box.\npygame.draw.rect(DISPLAYSURF, BOXCOLOR, (left, top, \nshape, color = getShapeAndColor(board, boxx, boxy) \nThe drawBoard() function makes a call to drawIcon() for each of the boxes on the board.\nThe nested for loops on lines 236 and 237 will loop through every possible X and Y coordinate \nfor the boxes, and will either draw the icon at that location or draw a white square instead (to \npygame.draw.rect(DISPLAYSURF, HIGHLIGHTCOLOR, (left - 5, top - 5, \nTo help the player recognize that they can click on a covered box to reveal it, we will make a blue \npygame.draw.rect() to make a rectangle with a width of 4 pixels.\ndef startGameAnimation(board): \n# Randomly reveal the boxes 8 at a time.\nboxes = [] \nboxes.append( (x, y) ) \nboard.\nThe nested for loops on lines 257 and 258 will add (X, Y) tuples to a list in the boxes \nWe will reveal and cover up the first 8 boxes in this list, then the next 8, then the next 8 after that, \nHowever, since the order of the (X, Y) tuples in boxes would be the same each time, \nTo change up the boxes each time a game starts, we will call the random.shuffle() function \nto randomly shuffle the order of the tuples in the boxes list.\nthe first 8 boxes in this list (and each group of 8 boxes afterwards), it will be random group of 8 \nboxes.\nTo get the lists of 8 boxes, we call our splitIntoGroupsOf() function, passing 8 and the \nlist in boxes.\nThe list of lists that the function returns will be stored in a variable named \nFirst, we draw the board.\ndrawBoard() will end up drawing only covered up white boxes.\nanimate the white boxes expanding to cover up the icons.\niteration to animate the next set of 8 boxes.\ndef gameWonAnimation(board): \nWhen the player has uncovered all of the boxes by matching every pair on the board, we want to \ncolor1 variable for the background color and then draw the board over it.\non line 276.\nRemember that this function needs to call pygame.display.update() to actually make the \n# Returns True if all the boxes have been revealed, otherwise False \nreturn False # return False if any boxes are covered.\ndata structure gets values in it set to True as icons have been matched, we can simply loop \nis in revealedBoxes, then we know there are still unmatched icons on the board.\nNote that because revealedBoxes is a list of lists, the for loop on line 285 will set the inner \nlist as the values of i.\nThis way we don’t need to write an additional line of code and have two nested for \nIt may seem pointless to have a main() function, since you could just put that code in the global \nscope at the bottom of the program instead, and the code would run the exact same.\nfunction would have to become global variables.\nSecond, this also lets you import the program so that you can call and test individual functions.\nfunctions to make sure they return the correct return values: \nThat’s why the code is in a separate function that we have named main().\nbuilt-in Python variable __name__ to see if we should call the main() function or not.\nvariable is automatically set by the Python interpreter to the string '__main__' if the program \ninteractive shell and make sure individual functions are returning the correct values by testing \nget new ideas for game features you want add, or find new bugs with the program.\nthis, it is important that your program is readable so that you can look at the code and understand \npygame.display.set_caption('Memory Game') \npygame.draw.rect(b, tt, (oo + 10, ddd + 10, 20, 20)) \npygame.draw.line(b, tt, (oo, ddd + i), (oo + i, ddd)) \npygame.draw.line(b, tt, (oo + i, ddd + 39), (oo + 39, ddd + i)) \npygame.draw.rect(b, (60, 60, 100), (oo, ddd, 40, 40)) \npygame.draw.rect(b, (255, 255, 255), (oo, ddd, gg, 40)) \npygame.draw.rect(b, (255, 255, 255), (oo, ddd, 40, 40)) \npygame.draw.rect(b, (0, 0, 255), (oo - 5, ddd - 5, 50, 50), 4) \nboxes = [] \nboxes.append( (x, y) ) \nThis chapter covers the entire explanation of how the Memory Puzzle program works.\nMany of the other game programs in \nthis book make use of the same programming concepts (like nested for loops, syntactic sugar, \nThe board is a 4x4 grid with fifteen tiles (numbered 1 through 15 going left to right) and one \nSource Code to Slide Puzzle \nmessages, look at the line number that is mentioned in the error message and check your code for \nBOARDWIDTH = 4  # number of columns in the board \nBOARDHEIGHT = 4 # number of rows in the board \npygame.display.set_caption('Slide Puzzle') \nboard in a start state.\nif event.key in (K_LEFT, K_a) and isValidMove(mainBoard, \n# Return a board data structure with tiles in the solved state.\nboard = [] \nboard.append(column) \nboard[BOARDWIDTH-1][BOARDHEIGHT-1] = None \nreturn board \ndef getBlankPosition(board): \n# Return the x and y of board coordinates of the blank space.\nif board[x][y] == None: \ndef makeMove(board, move): \ndef isValidMove(board, move): \nreturn (move == UP and blanky != len(board[0]) - 1) or \\ \n(move == LEFT and blankx != len(board) - 1) or \\ \ndef getRandomMove(board, lastMove=None): \nif lastMove == LEFT or not isValidMove(board, RIGHT): \nif lastMove == RIGHT or not isValidMove(board, LEFT): \n# return a random move from the list of remaining moves \ndef getSpotClicked(board, x, y): \n# from the x & y pixel coordinates, get the x & y board coordinates \n# draw a tile at board coordinates tilex and tiley, optionally a few \npygame.draw.rect(DISPLAYSURF, TILECOLOR, (left + adjx, top + adjy, \ndef drawBoard(board, message): \npygame.draw.rect(DISPLAYSURF, BORDERCOLOR, (left - 5, top - 5, width + \ndef slideAnimation(board, direction, message, animationSpeed): \n# draw a blank space over the moving tile on the baseSurf Surface.\nreturn (board, sequence) \ndef resetAnimation(board, allMoves): \nBOARDWIDTH = 4  # number of columns in the board \nBOARDHEIGHT = 4 # number of rows in the board \nThis code at the top of the program just handles all the basic importing of modules and creating \npygame.display.set_caption('Slide Puzzle') \nboard in a start state.\nThe makeText() function is defined later in the program, but for now you just need to \nknow that it returns a pygame.Surface object and pygame.Rect object which can be used \nWe will need to have two board data structures for this program.\nOne board will represent the \nThe other board will have its tiles in the ―solved‖ state, meaning that all the \ntiles are lined up in order.\nWhen the current game state’s board is exactly the same as the solved \nthere to compare the current game state board to.) \nThe generateNewPuzzle() will create a board data structure that started off in the ordered, \nThis will make the board into a randomly jumbled state that the player will have to solve (which \nlist of all the random moves that were performed on it (which will be stored in a variable named \nslides it made when it created the board data structure, and then the board can be solved just by \nFor example, below we perform a ―right‖ slide on the board on the left side of the page, which \nAfter the right slide, if we do the opposite slide (a left slide) then the board will be back in the \nIn the main game loop, the slideTo variable will track which direction the player wants to slide \na tile (it starts off at the beginning of the game loop as None and is set later) and the msg \non line 64 to see if the board data structure has the same value as the solved board data structure \nDISPLAYSURF Surface object (which is done on line 67) and pygame.display.update() \nis called to draw the display Surface object on the actual computer screen (which is done on line \nBefore going into the event loop, the program calls checkForQuit() on line 69 to see if any \nQUIT events have been created (and terminates the program if there have).\nThe for loop on line 70 executes the event handling code for any other event \ncreated since the last time pygame.event.get() was called (or since the program started, if \npygame.event.get() has never been called before).\ngetSpotClicked() function which will return the board coordinates of the spot on the board \nIf the mouse button release did not happen over one of the spaces on the board (but obviously still \nthe board).\nThe coordinates of where these buttons are on the window are stored in the pygame.Rect \npass the mouse coordinates from the Event object to the collidepoint() method.\nmethod will return True if the mouse coordinates are within the Rect object’s area and False \ntwo integer values that represent the X and Y coordinate of the spot on the board that was clicked.\nThen the if and elif statements on lines 89 to 96 check if the spot that was clicked is a tile that \nOur getBlankPosition() function will take the board data structure and return the X and Y \nboard coordinates of the blank spot, which we store in the variables blankx and blanky.\nspot the user clicked on was next to the blank space, we set the slideTo variable with the value \nif event.key in (K_LEFT, K_a) and isValidMove(mainBoard, \nlines 100 to 107 let the user set the slideTo variable by either pressing the arrow keys or the \nThe expression event.key in (K_LEFT, K_a) is just a Python trick to make the code \nIt is a way of saying ―evaluate to True if event.key is equal to one of K_LEFT or \nNow that the events have all been handled, we should update the variables of the game state and \nkeyboard event handling code) then we can call slideAnimation() to perform the sliding \nThe parameters are the board data structure, the direction of the slide, a message to \nAfter it returns, we need to update the actual board data structure (which is done by the \nmakeMove() function) and then add the slide to the allMoves list of all the slides made so \nThis is a function that we can call that calls both the pygame.quit() and sys.exit() \nfunctions.\nPygame internally has its own list data structure that it creates and appends Event objects to as \npygame.event.get() function is called with no parameters, the entire list is returned.\nHowever, you can pass a constant like QUIT to pygame.event.get() so that it will only \nLine 123 pulls out a list of QUIT events from Pygame’s event queue and returns them.\nWe can do this with the pygame.event.post() function, which adds \nThe pygame.event.post() function is also handy if you ever want your program to add \nCreating the Board Data Structure \n# Return a board data structure with tiles in the solved state.\nboard = [] \nboard.append(column) \nboard[BOARDWIDTH-1][BOARDHEIGHT-1] = None \nreturn board \nrepresents a ―solved‖ board, where all the numbered tiles are in order and the blank tile is in the \nThis is done with nested for loops, just like the board data structure in the \nGoing down the column, the numbers increase by the size of the board’s width (which is stored in \ndef getBlankPosition(board): \n# Return the x and y of board coordinates of the blank space.\nif board[x][y] == None: \nWhenever our code needs to find the XY coordinates of the blank space, instead of keeping track \nof where the blank space is after each slide, we can just create a function that goes through the \nentire board and finds the blank space coordinates.\nThe None value is used in the board data \nfor loops to find which space on the board is the blank space.\nMaking a Move by Updating the Board Data Structure \ndef makeMove(board, move): \nThe data structure in the board parameter is a 2D list that represents where all the tiles are.\nWhenever the player makes a move, the program needs to update this data structure.\nThe makeMove() function doesn’t have to return any values, because the board parameter has \nThis means that any changes we make to board in this \nfunction will be made to the list value that was passed to makeMove().\ndef isValidMove(board, move): \nreturn (move == UP and blanky != len(board[0]) - 1) or \\ \n(move == LEFT and blankx != len(board) - 1) or \\ \nThe isValidMove() function is passed a board data structure and a move the player would \nThe return value is True if this move is possible and False if it is not.\nexample, you cannot slide a tile to the left one hundred times in a row, because eventually the \nblank space will be at the edge and there are no more tiles to slide to the left.\nThis function makes a call to \nLines 173 to 176 \nof the line).\ndef getRandomMove(board, lastMove=None): \nif lastMove == LEFT or not isValidMove(board, RIGHT): \nif lastMove == RIGHT or not isValidMove(board, LEFT): \n# return a random move from the list of remaining moves \nAt the beginning of the game, we start with the board data structure in the solved, ordered state \nand create the puzzle by randomly sliding around tiles.\nrandom.choice() function and pass it a tuple (UP, DOWN, LEFT, RIGHT) to have \nIf you had a slide puzzle and slid a tile to left, and then slid a tile to the right, you would end up \nfrom selecting the last move that was made, the caller of the function can pass a directional value \nLine 181 starts with a list of all four directional values stored in \nDepending on if the blank space is at the edge of the board, lines 184 to 191 will \nremove other directional values from the lastMove list.\nThe getLeftTopOfTile() function converts board coordinates to pixel coordinates.\nboard XY coordinates that are passed in, the function calculates and returns the pixel XY \ncoordinates of the pixel at the top left of that board space.\nConverting from Pixel Coordinates to Board Coordinates \ndef getSpotClicked(board, x, y): \n# from the x & y pixel coordinates, get the x & y board coordinates \nconverts from pixel coordinates to board coordinates.\nthrough every possible XY board coordinate, and if the pixel coordinates that were passed in are \nwithin that space on the board, it returns those board coordinates.\nrepresents the space on the board by getting the pixel coordinates of the top left corner of the \nboard space, and then use the collidepoint() Rect method to see if the pixel coordinates are \nIf the pixel coordinates that were passed in were not over any board space, then the value \n# draw a tile at board coordinates tilex and tiley, optionally a few \npygame.draw.rect(DISPLAYSURF, TILECOLOR, (left + adjx, top + adjy, \nThe drawTile() function will draw a single numbered tile on the board.\ntiley parameters are the board coordinates of the tile.\ntile appear 5 pixels to the right of the tilex and tiley space on the board.\nadjx would make the tile appear 10 pixels to the left of the space.\nThese adjustment values will be handy when we need to draw the tile in the middle of sliding.\nThe Pygame drawing functions only use pixel coordinates, so first line 217 converts the board \ncoordinates in tilex and tiley to pixel coordinates, which we will store in variables left \nbackground square of the tile with a call to pygame.draw.rect() while adding the adjx \nand adjy values to left and top in case the code needs to adjust the position of the tile.\nLines 219 to 222 then create the Surface object that has the number text drawn on it.\nsince the caller of drawTile() probably will want to draw more tiles for the rest of the board \nThe makeText() function handles creating the Surface and Rect objects for positioning text on \nDrawing the Board \ndef drawBoard(board, message): \nThis function handles drawing the entire board and all of its tiles to the DISPLAYSURF display \nLine 235 to 237 handles drawing the message at the top of the window.\nNext, nested for loops are used to draw each tile to the display Surface object by calling the \nDrawing the Border of the Board \npygame.draw.rect(DISPLAYSURF, BORDERCOLOR, (left - 5, top - 5, width + \nLines 244 to 247 draw a border around the tiles.\nto the left and 5 pixels above the top left corner of the tile at board coordinates (0, 0).\nand height of the border are calculated from the number of tiles wide and high the board is (stored \n5 pixels to the left and above where the top and left variables point so the thickness of the line \ndef slideAnimation(board, direction, message, animationSpeed): \nThe first thing our tile sliding animation code needs to calculate is where the blank space is and \nThe comment on line 255 reminds us that the code that calls \ncoordinates and the direction of the slide, we can figure out the XY board coordinates of the tile \n# draw a blank space over the moving tile on the baseSurf Surface.\ndraw on one Surface object using blit() or the Pygame drawing functions, it will not change \nWe store this copy in the baseSurf variable on line 273.\neach frame of the sliding animation, we will draw the sliding tile over different parts of the \nthen it would still be there as we draw the sliding tile.\nAnd then what it would look like when we draw the ―9‖ tile sliding upwards on top of it: \nYou can see this for yourself by commenting out line 276 and running the program.\ndisplay Surface, then on each frame of the animation draw the sliding tile closer and closer to its \nThe code uses a for loop to go \nIf you have TILESIZE set to 80 (as the program in this book does on line 12) then \nanimationSpeed) would set the i variable to the values 0, 8, 16, 24, 32, 40, 48, 56, 64, \nLines 282 to 289 makes sure that we draw the tile sliding in the correct direction (based on what \nvalue the direction variable has).\nAfter the animation is done, then the function returns.\nThose events will be handled the next time execution reaches line 70 in the main() \nfunction or the code in the checkForQuit() function.\nThe generateNewPuzzle() function will be called at the start of each new game.\ncreate a new board data structure by calling getStartingBoard() and then randomly \nThe first few lines of generateNewPuzzle() get the board and then draw it to \nreturn (board, sequence) \nThe code for doing a random move is the getRandomMove() call on line 305 to get the \ndoing the slide animation does not actually update the board data structure, we update the board \nlist of moves in sequence on line 308.\nThen we store the random move in a variable called lastMove which will be passed to \nAll of this needs to happen numSlides number of times, so we put lines 305 to 309 inside a \nWhen the board is done being scrambled, then we return the board data structure and \nAnimating the Board Reset \ndef resetAnimation(board, allMoves): \nWhen the player clicks on ―Reset‖ or ―Solve‖, the Slide Puzzle game program needs to undo all \nof the moves that were made to the board.\nThe list of directional values for the slides will be \nLine 315 uses list slicing to create a duplicate of the allMoves list.\nWe call this on the revAllMoves list on line 316.\nThe for loop on line 318 iterates over the list of directional values.\nopposite move, so the if and elif statements from line 319 to 326 set the correct directional \nanimation, and makeMove() to update the board data structure.\nJust like in the Memory Puzzle game, after all the def statements have been executed to create \nall the functions, we call the main() function to begin the meat of the program.\nThat’s all there is to the Slide Puzzle program!\nThe more variables and the larger the lists your program uses, the more memory it takes \nsince it goes through all the possible board coordinates to find where the blank space is.\ncoordinates so we would not have to look through the entire board each time we want to know \nThis code could go in makeMove().) Using these variables \nAnother example is that we keep a board data structure in the solved state in the SOLVEDBOARD \nvariable, so that we can compare the current board to SOLVEDBOARD to see if the player has \ngetStartingBoard() function and compare the returned value to the current board.\nthen our program would take longer to run because it is re-creating the solved-state board data \nIf another programmer can look at your program’s source code and figure \nThis chapter hasn’t introduced any new Pygame programming concepts that the Memory Puzzle ",
    "keywords": [
      "Memory Puzzle",
      "board",
      "Memory Puzzle game",
      "Slide Puzzle",
      "board data structure",
      "left",
      "Puzzle",
      "Memory Puzzle program",
      "list",
      "board coordinates",
      "Slide Puzzle game",
      "board data",
      "BOXSIZE",
      "function",
      "code"
    ],
    "concepts": [
      "def",
      "board",
      "functions",
      "function",
      "line",
      "lines",
      "lined",
      "pygame",
      "lists",
      "list"
    ]
  },
  {
    "chapter_number": 5,
    "title": "– SIMULATE",
    "start_page": 126,
    "end_page": 170,
    "summary": "There are four colored buttons on the screen.\nThe buttons \nEach time the player successfully simulates the pattern, the pattern \nmessages, look at the line number that is mentioned in the error message and check your code for \n6. import random, sys, time, pygame \nTIMEOUT = 4 # seconds before game over if no button is pushed.\n# Rect objects for each of the four buttons \nDISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \npygame.display.set_caption('Simulate') \nplayer to click a colored button: \nwhile True: # main game loop \nclickedButton = None # button that was clicked (set to YELLOW, \nfor event in pygame.event.get(): # event handling loop \npygame.time.wait(1000) \nfor button in pattern: \npygame.time.wait(FLASHDELAY) \n# pushed the last button in the pattern \n# pushed the incorrect button, or has timed out \npygame.time.wait(1000) \npygame.event.post(event) # put the other KEYUP event objects back \nflashSurf = pygame.Surface((BUTTONSIZE, BUTTONSIZE)) \nfor start, end, step in ((0, 255, 1), (255, 0, -1)): # animation loop \npygame.draw.rect(DISPLAYSURF, YELLOW, YELLOWRECT) \npygame.draw.rect(DISPLAYSURF, BLUE,   BLUERECT) \npygame.draw.rect(DISPLAYSURF, RED,    REDRECT) \npygame.draw.rect(DISPLAYSURF, GREEN,  GREENRECT) \nnewBgSurf = pygame.Surface((WINDOWWIDTH, WINDOWHEIGHT)) \nfor alpha in range(0, 255, animationSpeed): # animation loop \nflashSurf = pygame.Surface(DISPLAYSURF.get_size()) \n6. import random, sys, time, pygame \nTIMEOUT = 4 # seconds before game over if no button is pushed.\nbuttons light up) and the amount of time the player has to push the next button in the sequence \nbefore the game times out.\nSetting Up the Buttons \n# Rect objects for each of the four buttons \nSimulate game has four rectangular areas and code to handle when the player clicks inside of \nThe program will need Rect objects for the areas of the four buttons so it can call the \nLines 36 to 39 set up these Rect objects with the \nDISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \npygame.display.set_caption('Simulate') \nThe usual Pygame setup functions are called to initialize the library, create a Clock \nThe objects that are created by these function calls will \nbe stored in global variables so that they can be used in other functions.\nLines 55 to 58 will load sound files so that Simulate can play sound effects as the player clicks on \neach button.\nThe pygame.mixer.Sound() constructor function will return a Sound object, \nwhich we store in the variables BEEP1 to BEEP4 which were made into global variables on line \nplayer to click a colored button: \nThe pattern variable will be a list of color values (either YELLOW, RED, BLUE, or GREEN) to \nAs the player finishes each round, a new random color is added to the end \nThe currentStep variable will keep track of which color in the pattern list the player has to \nthen the player would have to click the green button.\nIf they clicked on any other button, the code \nThere is a TIMEOUT constant that makes the player click on next button in the pattern within a \nnumber of seconds, otherwise the code causes a game over.\npassed since the last button click, the lastClickTime variable needs to keep track of the last \ntime the player clicked on a button.\nfunction to return the current time.\nbuttons for the player (in which case, waitingForInput is set to False), or the program has \nfinished playing the pattern and is waiting for the user to click the buttons in the correct order (in \nwhile True: # main game loop \nclickedButton = None # button that was clicked (set to YELLOW, \nLine 68 is the start of the main game loop.\nIf a button is clicked during this iteration, then clickedButton \nwill be set to one of the color values to match the button (YELLOW, RED, GREEN, or BLUE).\nThe fill() method is called on line 70 to repaint the entire display Surface so that we can start \nThe four colored buttons are drawn with a call to the drawButtons() \nThen the text for the score is created on lines 73 to 76.\nrender() method on line 51 for the instruction text, the text for the score changes.\nwhy we create new Surface objects by calling the render() method on line 73 inside the game \nto render() outside the game loop on line 50.\nfor event in pygame.event.get(): # event handling loop \nLine 80 does a quick check for any QUIT events, and then line 81 is the start of the event \ngetButtonClicked() function will return a Color object of the button clicked (otherwise it \nLines 85 to 93 check for any KEYDOWN events (created when the user presses a key on the \nThe Q key is in the upper left of the four keyboard keys, just like the yellow button on the screen \nis in the upper left, so we will make pressing the Q key the same as clicking on the yellow button.\nWe can do this by setting the clickedButton variable to the value in the constant variable \npygame.time.wait(1000) \nfor button in pattern: \npygame.time.wait(FLASHDELAY) \nwaitingForInput is False, the program will be displaying the animation for the pattern.\nWhen waitingForInput is True, the program will be waiting for the user to select buttons.\nLines 97 to 105 will cover the case where the program displays the pattern animation.\nis done at the start of the game or when the player finishes a pattern, line 101 will add a random \ncolor to the pattern list to make the pattern one step longer.\nThen lines 102 to 104 loops through \neach of the values in the pattern list and calls flashButtonAnimation() which makes that \nAfter it is done lighting up all the buttons in the pattern list, the program sets the \nFiguring Out if the Player Pressed the Right Buttons \nIf waitingForInput is True, then the code in line 106’s else statement will execute.\nLine \n108 checks if the player has clicked on a button during this iteration of the game loop and if that \nlist for the button that the player should click on next.\nFor example, if pattern was set to [YELLOW, RED, RED] and the currentStep variable \nwas set to 0 (like it would be when the player first starts the game), then the correct button for the \nplayer to click would be pattern[0] (the yellow button).\nIf the player has clicked on the correct button, we want to flash the button the player clicked by \n# pushed the last button in the pattern \nLines 114 to 119 are inside the else statement that started on line 106.\nthat else statement, we know the player clicked on a button and also it was the correct button.\nLine 114 checks if this was the last correct button in the pattern list by checking if the integer \nstored in currentStep is equal to the number of values inside the pattern list.\nand the waitingForInput variable is set to False so that on the next iteration of the game \nloop the code will add a new Color value to the pattern list and then flash the buttons.\nIf the player did not click on the correct button, the elif statement on line 121 handles the case \nwhere either the player clicked on the wrong button or the player has waited too long to click on a \nbutton.\nEither way, we need to show the ―game over‖ animation and start a new game.\nYou can compare this to line 108’s if statement’s condition clickedButton and \nclickedButton == pattern[currentStep] which evaluates to True if the player \nThe other part of line 121’s elif condition is (currentStep != 0 and time.time() \nIn order to ―time out‖, it must not be the player’s first button click.\n0 is True, then we know the player has begun clicking the buttons.\n(because 4 is stored in TIMEOUT) must be greater than the last time clicked a button (stored in \nWhat this number means is that the moment the time.time() function was called was a little \nGoing back to line 121, if time.time() - TIMEOUT > lastClickTime evaluates to \nTrue, then it has been longer than 4 seconds since time.time() was called and stored in \n# pushed the incorrect button, or has timed out \npygame.time.wait(1000) \nIf either the player clicked on the wrong button or has timed out, the program should play the \n―game over‖ animation and then reset the variables for a new game.\nA small pause and a new background color will be set to indicate to the player the \nstart of a new game, which will begin on the next iteration of the game loop.\nJust like the other game programs, the last thing done in the game loop is drawing the display \nSurface object to the screen and calling the tick() method.\npygame.event.post(event) # put the other KEYUP event objects back \nLine 151 to 166 sets \nthree local variables differently depending on the value in the color parameter: sound, \nAnimating the Button Flash \nflashSurf = pygame.Surface((BUTTONSIZE, BUTTONSIZE)) \nboard is drawn and then on top of that, the bright color version of the button that is flashing is \nThe alpha value of the bright color starts off at 0 for the first frame of \nTo do this in code, line 168 creates a copy of the display Surface object and stores it in \nLine 169 creates a new Surface object the size of a single button and stores it in \nobject can have transparent colors drawn on it (otherwise, the alpha value in the Color objects we \nconvert_alpha() method on any Surface objects that have transparent colors painted on \nLine 171 creates individual local variables named r, g, and b to store the individual RGB values \nBefore we begin animating the button flash, line 172 will play \nstarted to play, so the sound will be playing during the button flash animation.\nfor start, end, step in ((0, 255, 1), (255, 0, -1)): # animation loop \nRemember that to do the animation, we want to first draw the flashSurf with color that has \nBut notice that the code inside the for loops handles drawing the frame and are identical to each \npart of the animation (where the alpha value goes from 0 to 255) and the second for loop would \nThis is what we do with the for loop on line 173, which supplies different values for \nthe range() call on line 174: \nfor start, end, step in ((0, 255, 1), (255, 0, -1)): # animation loop \nOn the first iteration of line 173’s for loop, start is set to 0, end is set to 255, and step is \nThis way, when the for loop on line 174 is executed, it is calling range(0, 255, \nLine 174’s for loop then executes and performs the brightening animation.\nOn the second iteration of line 173’s for loop (there are always two and only two iterations of \nWhen the line \nHere’s the code again that is inside line 174’s for loop: \nby calling fill() (supplying the r, g, b values of the color we got on line 171 and the alpha \nvalue that the for loop sets in the alpha variable).\nThen, to make the display Surface appear on the screen, pygame.display.update() is \ncalled on line 179.\nDrawing the Buttons \npygame.draw.rect(DISPLAYSURF, YELLOW, YELLOWRECT) \npygame.draw.rect(DISPLAYSURF, BLUE,   BLUERECT) \npygame.draw.rect(DISPLAYSURF, RED,    REDRECT) \npygame.draw.rect(DISPLAYSURF, GREEN,  GREENRECT) \nSince each of the buttons is just a rectangle of a certain color in a certain place, we just make four \ncalls to pygame.draw.rect() to draw the buttons on the display Surface.\nnewBgSurf = pygame.Surface((WINDOWWIDTH, WINDOWHEIGHT)) \nfor alpha in range(0, 255, animationSpeed): # animation loop \nThe background color change animation happens whenever the player finishes entering the entire \nOn each iteration through the loop which starts on line 198 the entire display \nLine 200 fills in the entire display Surface (stored in DISPLAYSURF) with the old \nLine 202 fills in a different Surface object (stored in newBgSurf) with the new \niteration since that is what the for loop on line 198 does).\nLine 203 then draws the newBgSurf Surface to the display Surface in DISPLAYSURF.\nNow that we have the background the way we want it, we’ll draw the buttons over it with \na call to drawButtons() on line 205.\nLine 207 and 208 then just draws the display Surface to the screen and adds a pause.\nfunction modifies the content of the variable with an assignment statement on line 209.\nfunction can read the value of a global variable without specifying the global statement.\nIf that function assigns a value to a global variable without a global statement, then Python \nThe main() function uses the bgColor variable but doesn’t need a global statement \nflashSurf = pygame.Surface(DISPLAYSURF.get_size()) \nEach of the iterations of the for loop on the next line (line 223 below) will perform a flash.\nmore or fewer flashes, then change the integer that is passed to range() on line 222.\nThe for loop on line 223 is exactly the same as the one line 173.\nvariables will be used on the next for loop (on line 224) to control how the alpha variable \nThis animation loop works the same as the previous flashing animation code in the ―Animating \ndrawn on the display Surface, then flashSurf (which has the new flashing color painted on it) \nAfter the background color is set up, the buttons are drawn \non top on line 232.\nThe for loop on line 226 adjusts the alpha value for the color used for each frame of animation \nThe getButtonClicked() function simply takes XY pixel coordinates and returns either the \nvalues YELLOW, BLUE, RED, or GREEN if one of the buttons was clicked, or returns None if the \nstatement on line 247.\nNormally when a function reaches the end and returns the None value implicitly (that is, there is \nAll function calls have to return a value (so that they can evaluate to \nsomething and be part of expressions), but our code doesn’t always make use of the return value.\nNone is returned from getButtonClicked(), we have the return None line at the end of \nmessages, look at the line number that is mentioned in the error message and check your code for \nDISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \npygame.display.set_caption('Wormy') \nwhile True: # main game loop \nfor event in pygame.event.get(): # event handling loop \npygame.time.wait(500) \nwormSegmentRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \npygame.draw.rect(DISPLAYSURF, DARKGREEN, wormSegmentRect) \nwormInnerSegmentRect = pygame.Rect(x + 4, y + 4, CELLSIZE - 8, \npygame.draw.rect(DISPLAYSURF, GREEN, wormInnerSegmentRect) \nappleRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \npygame.draw.rect(DISPLAYSURF, RED, appleRect) \nfor x in range(0, WINDOWWIDTH, CELLSIZE): # draw vertical lines \npygame.draw.line(DISPLAYSURF, DARKGRAY, (x, 0), (x, WINDOWHEIGHT)) \nfor y in range(0, WINDOWHEIGHT, CELLSIZE): # draw horizontal lines \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, y), (WINDOWWIDTH, y)) \nIf you play the game a little, you’ll notice that the apple and the segments of the worm’s body \nThe code at the start of the program just sets up some constant variables used in the game.\nSome more constants are set on lines 19 to 32.\nDISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \npygame.display.set_caption('Wormy') \nIn the Wormy game program, we’ve put the main part of the code in a function called \nrotating ―Wormy‖ text) once when the program starts (by calling the showStartScreen() \nwill return when the player’s worm collides into a wall or into itself and causes a game over.\nthat function call returns, the loop goes back to the start and calls runGame() again.\nwhile loop on line 44 will loop forever until the program terminates.\nAt the beginning of a game, we want the worm to start in a random position (but not too close to \nThe body of the worm will be stored in a list of dictionary values.\nmore readable, we’ve set the HEAD constant to 0 on line 32, so that we can use \nwhile True: # main game loop \nfor event in pygame.event.get(): # event handling loop \nLine 61 is the start of the main game loop and line 62 is the start of the event handling loop.\nterminate() function in the previous game programs).\narrow key, the worm would immediate start going right and crash into itself.\nreturns to the function call in main(), the next line after the runGame() call (line 46) is the \nwhy we have the return statement on line 79.\nLine 80 loops through every body segment in wormCoords after the head (which is at index 0.\nboth the 'x' and 'y' values of the body segment are the same as the 'x' and 'y' of the head, \nthen we also end the game by returning out of the runGame() function.\nThe code on lines 91 to 100 (described next in the ―Moving the Worm‖ section) will add a new \nBut when line 89 deletes the last body segment, the size \nTo move the worm, we add a new body segment to the beginning of the wormCoords list.\nThis new head segment is added to wormCoords with the insert() list method on line 100.\nThe code for drawing the screen in the runGame() function is fairly simple.\nthe entire display Surface with the background color.\nLines 102 to 105 draw the grid, worm, \nThen the call to pygame.display.update() draws \nWhile the start screen animation is playing or the game over screen is being shown, there will be \npygame.event.get() on line 117 returns a list of all the QUIT events in the event queue \nthe list that pygame.event.get() returns will be the empty list: [] \nThe len() call on line 117 will return 0 if pygame.event.get() returned an empty list.\nthere are more than zero items in the list returned by pygame.event.get() (and remember, \npygame.event.get()), then the terminate() function gets called on line 118 and the \nOtherwise, the first key event object in the list that was returned by pygame.event.get() is \nWhen the Wormy game program first begins running, the player doesn’t automatically begin \nInstead, a start screen appears which tells the player what program they are \nA start screen also gives the player a chance to prepare for the game to begin (otherwise \nThe Wormy start screen requires two Surface objects with the ―Wormy!‖ text drawn on them.\nThese are what the render() method calls create on lines 130 and 131.\nthe Font() constructor function call on line 129 creates a Font object that is 100 points in size.\nLine 135 begins the animation loop for the start screen.\ntext will be rotated and drawn to the display Surface object.\nThe showStartScreen() function will rotate the images on the Surface objects that the \nThe first parameter is the Surface object to make a rotated copy of.\nThe second parameter is the number of degrees to rotate the Surface.\npygame.transform.rotate() function doesn’t change the Surface object you pass it, but \nrather returns a new Surface object with the rotated image drawn on it.\nIn order to make a Surface object that can fit the rotated \nThe two rotated ―Wormy!‖ Surface objects are blitted to the display Surface on each frame of the \nanimation loop on lines 140 and 145.\nOn line 147 the drawPressKeyMsg() function call draws the ―Press a key to play.‖ text in the \ncheckForKeyPress() returns a value that is not None, which happens if the player presses a \nBefore returning, pygame.event.get() is called simply to clear out any other events \nthat have accumulated in the event queue which the start screen was displayed.\nYou may wonder why we store the rotated Surface in a separate variable, rather than just \nThe amount that we rotate the two ―Wormy!‖ text Surface objects is stored in degrees1 and \nOn each iteration through the animation loop, we increase the number stored in \nthe white text ―Wormy!‖ Surface object will be rotated by another 3 degrees and the green text \n―Wormy!‖ Surface object will be rotated by another 7 degrees.\nThe terminate() function calls pygame.quit() and sys.exit() so that the game \nThe getRandomLocation() function is called whenever new coordinates for the apple are \nThis function returns a dictionary with keys 'x' and 'y', with the values set to random \nThe game over screen is similar to the start screen, except it isn’t animated.\npygame.time.wait(500) \nThe Game Over text will stay on the screen until the player pushes a key.\npygame.time.wait() on line 180.\nshowGameOverScreen() was called, and that key press would cause the game over screen to \nThe code to draw the score, worm, apple, and grid are all put into separate functions.\nThe drawScore() function simply renders and draws the text of the score that was passed in \nits score parameter on the display Surface object.\nwormSegmentRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \npygame.draw.rect(DISPLAYSURF, DARKGREEN, wormSegmentRect) \nwormInnerSegmentRect = pygame.Rect(x + 4, y + 4, CELLSIZE - 8, \npygame.draw.rect(DISPLAYSURF, GREEN, wormInnerSegmentRect) \nThe drawWorm() function will draw a green box for each of the segments of the worm’s body.\nThe for loop on line 196 loops through each of the dictionary values \nLine 199 creates a Rect object for the worm segment that will be passed to the \npygame.draw.rect() function on line 200.\nLine 200 draws a dark green rectangle for the segment.\nappleRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \npygame.draw.rect(DISPLAYSURF, RED, appleRect) \na single rectangle that fills up the cell, all the function needs to do is convert to pixel coordinates \n(which is what lines 206 and 207 do), create the Rect object with the location and size of the \napple (line 208), and then pass this Rect object to the pygame.draw.rect() function.\nfor x in range(0, WINDOWWIDTH, CELLSIZE): # draw vertical lines \npygame.draw.line(DISPLAYSURF, DARKGRAY, (x, 0), (x, WINDOWHEIGHT)) \nfor y in range(0, WINDOWHEIGHT, CELLSIZE): # draw horizontal lines \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, y), (WINDOWWIDTH, y)) \nJust to make it easier to visualize the grid of cells, we call pygame.draw.line() to draw out \nNormally, to draw the 32 vertical lines needed, we would need 32 calls to \npygame.draw.line() with the following coordinates: \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 0), (0, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (20, 0), (20, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (40, 0), (40, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (60, 0), (60, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (560, 0), (560, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (580, 0), (580, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (600, 0), (600, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (620, 0), (620, WINDOWHEIGHT)) \nInstead of typing out all these lines of code, we can just have one line of code inside a for loop.\nNotice that the pattern for the vertical lines is that the X coordinate of the start and end point \nThis is why the for loop on line 213 iterates over \nFor the horizontal lines, the coordinates would have to be: \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 0), (WINDOWWIDTH, 0)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 20), (WINDOWWIDTH, 20)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 40), (WINDOWWIDTH, 40)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 60), (WINDOWWIDTH, 60)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 400), (WINDOWWIDTH, 400)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 420), (WINDOWWIDTH, 420)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 440), (WINDOWWIDTH, 440)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 460), (WINDOWWIDTH, 460)) \nThe Y coordinate ranges from 0 to 460, increasing by 20 each time.\nhere so we don’t have to type out all those pygame.draw.line() calls.\nWe could have typed out all 56 pygame.draw.line() calls and the \nmain() function is called to start the game.\nTake a look at a few lines of code from the drawWorm() function again: \nwormSegmentRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \npygame.draw.rect(DISPLAYSURF, DARKGREEN, wormSegmentRect) \nwormInnerSegmentRect = pygame.Rect(x + 4, y + 4, CELLSIZE - 8, \npygame.draw.rect(DISPLAYSURF, GREEN, wormInnerSegmentRect) \nNotice that two different Rect objects are created on lines 199 and 201.\non line 199 is stored in the wormSegmentRect local variable and is passed to the \npygame.draw.rect() function on line 200.\nThe Rect object created on line 201 is stored in \nthe wormInnerSegmentRect local variable and is passed to the pygame.draw.rect() \nfunction on line 202.\nwormSegmentRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \npygame.draw.rect(DISPLAYSURF, DARKGREEN, wormSegmentRect) \nwormSegmentRect = pygame.Rect(x + 4, y + 4, CELLSIZE - 8, CELLSIZE \npygame.draw.rect(DISPLAYSURF, GREEN, wormInnerSegmentRect) \nBecause the Rect object returned by pygame.Rect() on line 199 won’t be needed after 200, \nwe can overwrite this value and reuse the variable to store the Rect object returned by \npygame.Rect() on line 201.\nthey would see that wormSegmentRect is passed to the pygame.draw.rect() calls on \nline 200 and 202.\nassigned a value, they would see the pygame.Rect() call on line 199.\nthat the Rect object returned by line 199’s pygame.Rect() call isn’t the same as the one that is \npassed to the pygame.draw.rect() call on line 202.",
    "keywords": [
      "line",
      "Surface",
      "HEAD",
      "DISPLAYSURF",
      "CELLSIZE",
      "Surface object",
      "button",
      "WINDOWWIDTH",
      "display Surface",
      "game",
      "WINDOWHEIGHT",
      "BUTTONSIZE",
      "True",
      "loop",
      "Wormy"
    ],
    "concepts": [
      "pygame",
      "line",
      "lines",
      "def",
      "function",
      "functions",
      "button",
      "colored buttons",
      "colors",
      "color"
    ]
  },
  {
    "chapter_number": 7,
    "title": "- Tetromino    153",
    "start_page": 171,
    "end_page": 259,
    "summary": "The player tries to keep forming complete lines until the screen fills up and a new \nIn this chapter, I have come up with a set of terms for the different things in the game program.\nBoard – The board is made up of 10 x 20 spaces that the blocks fall and stack up in.\nPiece – The things that fall from the top of the board that the player can rotate and \nEach piece has a shape and is made up of 4 boxes.\nShape – The shapes are the different types of pieces in the game.\nTemplate – A list of shape data structures that represents all the possible rotations of a \nLanded – When a piece has either reached the bottom of the board or is touching a box \non the board, we say that the piece has landed.\nmessages, look at the line number that is mentioned in the error message and check your code for \nLIGHTCOLORS = (LIGHTBLUE, LIGHTGREEN, LIGHTRED, LIGHTYELLOW) \nDISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \nwhile True: # game loop \n# setup variables for the start of the game \nwhile True: # main game loop \n# No falling piece in play, so start a new piece at the top \nreturn # can't fit a new piece on the board, so game over \n# let the piece fall if it is time to fall \n# falling piece has landed, set it on the board \nreturn event.key \n# Based on the score, return the level the player is on and \n# how many seconds pass until a falling piece falls one space.\n# return a random new piece in a random rotation and color \nshape = random.choice(list(SHAPES.keys())) \ndef addToBoard(board, piece): \n# fill in the board based on piece's location, shape, and rotation \nif SHAPES[piece['shape']][piece['rotation']][y][x] != BLANK: \nboard[x + piece['x']][y + piece['y']] = piece['color'] \n# create and return a new blank board data structure \nreturn board \ndef isValidPosition(board, piece, adjX=0, adjY=0): \n# Return True if the piece is within the board and not colliding \nisAboveBoard = y + piece['y'] + adjY < 0 \nSHAPES[piece['shape']][piece['rotation']][y][x] == BLANK: \nif board[x + piece['x'] + adjX][y + piece['y'] + adjY] != \ndef isCompleteLine(board, y): \n# Return True if the line filled with boxes with no gaps.\nif board[x][y] == BLANK: \n# Remove any completed lines on the board, move everything above them \ndown, and return the number of complete lines.\n# Set very top line to blank.\n# draw a single box (each tetromino piece has four boxes) \npygame.draw.rect(DISPLAYSURF, COLORS[color], (pixelx + 1, pixely + 1, \npygame.draw.rect(DISPLAYSURF, LIGHTCOLORS[color], (pixelx + 1, pixely \nstored in the piece data structure \npixelx, pixely = convertToPixelCoords(piece['x'], piece['y']) \n# draw each of the blocks that make up the piece \ndrawBox(None, None, piece['color'], pixelx + (x * \n# draw the \"next\" piece \nas a value to represent blank spaces in the board’s data structure.\nSetting up Timing Constants for Holding Down Keys \nEvery time the player pushes the left or right arrow key down, the falling piece should move one \narrow key to keep moving the falling piece.\nthat every 0.15 seconds that passes with the left or right arrow key held down, the piece will \none box while the player has the down arrow key held down.\nThe program needs to calculate how many pixels are to the left and right side of the board to use \nLIGHTCOLORS = (LIGHTBLUE, LIGHTGREEN, LIGHTRED, LIGHTYELLOW) \nSetting Up the Piece Templates \nOur game program needs to know how each of the shapes are shaped, including for all of their \nThough, of course, the code for the eggs list would be much more readable if we lined up all the \nLines \nImagine that each possible piece in a tiny 5 x 5 board of empty space, with some of the spaces on \nThis is how we can represent things like Tetromino pieces as Python values such as strings and \nall of the shape data in our game.\nDISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \nThe main() function handles creating some more global constants and showing the start screen \nwhile True: # game loop \nWhen the player presses a key, the showTextScreen() function that displays the game over \nThe game loop will loop back to the beginning at line 169 and start another \ngame.\n# setup variables for the start of the game \nBefore the game begins and pieces start falling, we need to initialize some variables to their start-\nof-game values.\nOn line 191 the fallingPiece variable will be set to the currently falling \npiece that can be rotated by the player.\nOn line 192 the nextPiece variable will be set to the \npiece that shows up in the ―Next‖ part of the screen so that player knows what piece is coming up \nafter setting the falling piece.\nwhile True: # main game loop \n# No falling piece in play, so start a new piece at the top \nreturn # can't fit a new piece on the board, so game over \nThe main game loop that starts on line 194 handles all of the code for the main part of the game \nwhen pieces are falling to the bottom.\nfalling piece has landed.\nfallingPiece variable, and a random new piece should be put into the nextPiece variable.\nA new piece can be generated from the getNewPiece() function.\nvariable is also reset to the current time so that the piece will fall in however many seconds is in \nThe pieces that getNewPiece() are positioned a little bit above the board, usually with part of \nthe piece already on the board.\nup there (in which case the isValidPosition() call on line 201 will return False), then \nwe know that the board is full and the player should lose the game.\nThe event handling loop takes care of when the player rotates the falling piece, moves the falling \npiece, or pauses the game.\nIf the player has pressed the P key, then the game should pause.\nthe player (otherwise the player could cheat by pausing the game and taking time to decide where \nto move the piece).\nwait for the player to press a key to continue.\nOnce the player has pressed a key, showTextScreen() will return.\nAlso, since a large amount of time could have passed since the player paused \nvariables should all be reset to the current time (which is done on lines 213 to 215).\nWhen the left arrow key is pressed down (and moving to the left is a valid move for the falling \nto one space to the left by subtracting the value of fallingPiece['x'] by 1.\nisValidPosition() function checks the position of the data provided by the piece object \nPassing -1 for adjY checks one space above where the piece is \ncurrently positioned, and passing a value like 3 for adjY would check three spaces down from \nwhere the piece is.\nThe movingLeft variable is set to True, and just to make sure the falling piece won’t move \nboth left and right, the movingRight variable is set to False on line 228.\nlastMoveSidewaysTime variable will be updated to the current time on line 229.\nThese variables are set so that the player can just hold down the arrow key to keep moving the \npiece over.\nIf the movingLeft variable is set to True, the program can know that the left \nthen it is time for the program to move the falling piece to the left again.\nThe code on lines 231 to 235 is almost identical to lines 225 to 229, except that it handles moving \nthe falling piece to the right when the right arrow key (or D key) has been pressed.\nThe up arrow key (or W key) will rotate the falling piece to its next rotation.\ndo is increment the 'rotation' key’s value in the fallingPiece dictionary by 1.\nHowever, if incrementing the 'rotation' key’s value makes it larger than the total number of \nIf the new rotated position is not valid because it overlaps some boxes already on the board, then \nLines 242 to 245 do the same thing 238 to 241, except they handle the case where the player has \npressed the Q key which rotates the piece in the opposite direction.\nIf the down arrow or S key is pressed down, then the player wants the piece to fall faster than \nLine 251 moves the piece down one space on the board (but only if it is a valid space).\nThese variables will be checked later so that the piece keeps falling at the faster rate as long \nWhen the player presses the space key the falling piece will immediately drop down as far as it \nThe program first needs to find out how many spaces the piece can \nLines 256 to 258 will set all the moving variables to False (which makes the code in later parts \ndone because this code will move the piece to the absolute bottom and begin falling the next \npiece, and we don’t want to surprise the player by having those pieces immediately start moving \nTo find the farthest that the piece can fall, we should first call isValidPosition() and pass \nthe piece cannot fall any further and is already at the bottom.\nloop on line 259 handles: calling isValidPosition() with increasing integer values to pass \nfor adjY until the function call returns False.\nThis is why line 262 increases fallingPiece['y'] by i - 1 \n(Also note that the second parameter to range() on line 259’s for statement is set to \nRemember that on line 227 the movingLeft variable was set to True if the player pressed \n(The same for line 233 where movingRight was set to True if \nthe player pressed down on the right arrow key.) The moving variables were set back to False if \nthe user let up on these keys also (see line 217 and 219).\nWhat also happened when the player pressed down on the left or right arrow key was that the \nlastMoveSidewaysTime variable was set to the current time (which was the return value of \nIf the player continued to hold down the arrow key without letting up on it, \nIf the user held down on the key for longer than 0.15 seconds (the value stored in \ncondition is True if the user has both held down the arrow key and 0.15 seconds has passed, and \nin that case we should move the falling piece to the left or right even though the user hasn’t \nkeys to get the falling piece to move over multiple spaces on the board.\ndown an arrow key and the piece will keep moving over until they let up on the key.\nhappens, the code on lines 216 to 221 will set the moving variable to False and the condition on \nline 265 will be False.\nThe first number on each line of output is the return value of time.time() when the program \nThe second number is the latest return value from \ntime.time() (this value keeps getting updated on each iteration of the loop).\nhave elapsed since the begin = time.time() line of code was executed.\nThis is how our game program can know if a certain amount of time has passed since \na line of code was run.\nMOVESIDEWAYSFREQ, we know it is time for the code to move the falling piece over one more \ndo on line 270.\npiece down.\n# let the piece fall if it is time to fall \n# falling piece has landed, set it on the board \nIf enough time has elapsed since the falling piece last fell down one \nspace, lines 279 to 288 will handle dropping the piece by one space.\nIf the condition on line 279 is True, then the piece has landed.\nmake the piece part of the board data structure (so that future pieces can land on it), and the \nremoveCompleteLines() call will handle erasing any complete lines on the board and \nvalue of how many lines were removed, so we add this number to the score.\nfunction to update the current level and frequency that the pieces fall.\nfallingPiece variable to None to indicate that the next piece should become the new falling \n(That is done on lines \nIf the piece has not landed, we simply set its Y position down one space (on line 287) and reset \nlastFallTime to the current time (on line 288).\nneeds to draw the game state to the screen.\nthe game loop code just needs to call those functions.\nand a Color object, it calls render() for us and returns the Surface and Rect object for this text.\nThis just saves us from typing out the code to create the Surface and Rect object each time we \nThe terminate() function works the same as in the previous game programs.\nreturn event.key \nInstead of separate functions for the start screen and game over screens, we will create one \nNotice that lines 328 to 330 draw the text in a darker shadow color first, and then lines 333 to 335 \nThe checkForQuit() function can be called to handle any events that will cause the program \nBecause the pygame.event.get() call on line 350 pulls out all of the KEYUP events \n# Based on the score, return the level the player is on and \n# how many seconds pass until a falling piece falls one space.\nEvery time the player completes a line, their score will increase by one point.\nthe game goes up a level and the pieces start falling down faster.\nTo calculate the falling frequency, we start with a base time of 0.27 (meaning that the piece will \nlevel * 0.02 part of the equation as ―for every level, the piece will fall 0.02 seconds faster \nWe can also make a graph showing how fast the pieces will fall at each level of the game: \nwith our code, because line 277 just checks that the elapsed time since the falling piece last fell \nthen the condition on line 277 will always be True and the piece will fall on every iteration of \nFrom level 14 and beyond, the piece cannot fall any faster.\nIf the FPS is set at 25, this means that at reaching level 14, the falling piece will fall 25 spaces a \nConsidering that the board is only 20 spaces tall, that means the player will have less than \na second to set each piece!\nIf you want the pieces to start (if you can see what I mean) falling faster at a slower rate, you can \nline 360 was this: \nIn the above case, the pieces would only fall 0.01 seconds faster on each level rather than 0.02 \nGenerating Pieces with the getNewPiece() Function \n# return a random new piece in a random rotation and color \nshape = random.choice(list(SHAPES.keys())) \nThe getNewPiece() function generates a random piece that is positioned at the top of the \nFirst, to randomly choose the shape of the piece, we create a list of all the possible shapes \nby calling list(SHAPES.keys()) on line 365.\nfunction only accepts list values for its parameter.\nrandomly returns the value of an item from the list.\nThe piece data structures are simply a dictionary value with the keys 'shape', 'rotation', \nThe value for the 'rotation' key is a random integer between 0 to one less than however \nS_SHAPE_TEMPLATE) in each piece data structure to represent the boxes of each piece.\nwe just store an index for the shape and rotation which refer to the PIECES constant.\nThe 'x' key’s value is always set to the middle of the board (also accounting for the width of the \nThe 'y' key’s value is \nto the length of COLORS (subtracting one) will give us a random index value for the piece’s \nOnce all of the values in the newPiece dictionary are set, the getNewPiece() function \nAdding Pieces to the Board Data Structure \ndef addToBoard(board, piece): \n# fill in the board based on piece's location, shape, and rotation \nif SHAPES[piece['shape']][piece['rotation']][y][x] != BLANK: \nboard[x + piece['x']][y + piece['y']] = piece['color'] \nThe board data structure is a data representation for the rectangular space where pieces that have \nThe currently falling piece is not marked on the board data \nWhat the addToBoard() function does is takes a piece data structure and adds its \nboxes to the board data structure.\nThe nested for loops on lines 376 and 377 go through every space in the piece data structure, \nand if it finds a box in the space (line 378), it adds it to the board (line 379).\nCreating a New Board Data Structure \n# create and return a new blank board data structure \nreturn board \nThe data structure used for the board is fairly simple: it’s a list of lists of values.\nIn order to create a blank board, list replication is used to create the lists of BLANK values which \nThis is done on line 386.\ncolumns in the board (this is what the for loop on line 385 does).\nrepresent valid values that exist on the board.\ndef isValidPosition(board, piece, adjX=0, adjY=0): \n# Return True if the piece is within the board and not colliding \nisAboveBoard = y + piece['y'] + adjY < 0 \nSHAPES[piece['shape']][piece['rotation']][y][x] == BLANK: \nThe isValidPosition() function is given a board data structure and a piece data structure, \nand returns True if all the boxes in the piece are both on the board and not overlapping any \ncoordinate of the upper right box on the 5x5 boxes for the piece) and adding the coordinate inside \nthe piece data structure.\nThe board with a falling piece in a valid \nThe board with the falling piece in an invalid \nOn the left board, the falling piece’s (that is, the top left corner of the falling piece’s) XY \nBut the boxes inside the falling piece’s coordinate system \nthe ―board‖ coordinates of the falling piece’s top left box and the ―piece‖ coordinates of the \nOn the left board, the falling piece’s boxes are at the following ―piece‖ coordinates: \nWhen we add the (2, 3) coordinate (the piece’s coordinates on the board) to these coordinates, it \nAnd now that we can figure out where the falling piece’s boxes are as board coordinates, we can \nlines 396 and 397 go through each of the possible coordinates on the falling piece.\nWe want to check if a box of the falling piece is either off of the board or overlapping a box on \nwhen the falling piece just begins falling.) Line 398 creates a variable named isAboveBoard \nthat is set to True if the box on the falling piece at the coordinates pointed to be x and y is above \nThe if statement on line 399 checks if the space on the piece is above the board or is blank.\n(Note that the end of line 399 has [y][x] instead of [x][y].\ncoordinates in the PIECES data structure are reversed.\nif board[x + piece['x'] + adjX][y + piece['y'] + adjY] != \nThe if statement on line 401 checks that the piece’s box is not located on the board.\nstatement on line 403 checks that the board space the piece’s box is located is not blank.\nof these conditions are True, then the isValidPosition() function will return False.\nposition of the piece must be valid and so the function returns True on line 405.\ndef isCompleteLine(board, y): \n# Return True if the line filled with boxes with no gaps.\nif board[x][y] == BLANK: \nsame value as the BLANK constant), then the function return False.\n# Remove any completed lines on the board, move everything above them \ndown, and return the number of complete lines.\nThe removeCompleteLines() function will find any complete lines in the passed board data \nstructure, remove the lines, and then shift all the boxes on the board above that line down one \nThe function will return the number of lines that were removed (which is tracked by the \nThe way this function works is by running in a loop starting on line 419 with the y variable \n# Set very top line to blank.\nThe isCompleteLine() function will return True if the line that y is referring to is \nIn that case, the program needs to copy the values of each row above the removed line \nThis is what the for loop on line 422 does (which is why its call to the \nrange() function begins at y, rather than 0.\nrange(), so that the list it returns starts at y, ends at 0, and after each iteration ―increases‖ by -\nThis ―pulling down‖ is really just copying the higher row’s values to the row below it on line 424.\nThis is what lines 426 \nAfter the complete line is removed, the execution reaches the end of the while loop that started \nthe line was being removed and the rows being pulled down that the y variable changed at all.\nthe y variable is decremented on line 433.\nThis helper function converts the board’s box coordinates to pixel coordinates.\nDrawing a Box on the Board or Elsewhere on the Screen \n# draw a single box (each tetromino piece has four boxes) \npygame.draw.rect(DISPLAYSURF, COLORS[color], (pixelx + 1, pixely + 1, \npygame.draw.rect(DISPLAYSURF, LIGHTCOLORS[color], (pixelx + 1, pixely \nThe drawBox() function draws a single box on the screen.\nboxy parameters for board coordinates where the box should be drawn.\n―Next‖ piece, which is not on the board.\nThen the if statement on line 450 will overwrite the None values \nboxes of a piece, the left and top parameters in the pygame.draw.rect() call have + 1 \nThe drawBoard() function is responsible for calling the drawing functions for the board’s \nboard[x][y] is set to BLANK.\nDrawing a Piece on the Board or Elsewhere on the Screen \nstored in the piece data structure \npixelx, pixely = convertToPixelCoords(piece['x'], piece['y']) \n# draw each of the blocks that make up the piece \ndrawBox(None, None, piece['color'], pixelx + (x * \nThe drawPiece() function will draw the boxes of a piece according to the piece data structure \nThis function will be used to draw the falling piece and the ―Next‖ piece.\nSince the piece data structure will contain all of the shape, position, rotation, and color \ninformation, nothing else besides the piece data structure needs to be passed to the function.\nHowever, the ―Next‖ piece is not drawn on the board.\nvariables with the return values of convertToPixelCoords() call.\nThe nested for loops on line 489 and 490 will then call drawBox() for each box of the piece \n# draw the \"next\" piece \nThe drawNextPiece() draws the ―Next‖ piece in the upper right corner of the screen.\nLine 505 and 506 are run after all the function definitions have been \nexplain to someone in English: ―Blocks fall from the top of a board, and the player moves and \nThe complete lines disappear (giving the player \nentire board and the player loses.‖ \nof this game with pieces made up of five boxes.\nthe pieces are made up of just one box.\nSQUIRREL \nSquirrel Eat Squirrel is loosely based on the game ―Katamari Damacy‖.\nsquirrels.\nEach time the player’s squirrel eats a squirrel that is smaller than it, it grows larger.\nthe player’s squirrel gets hit by a larger squirrel larger than it, it loses a life point.\nThe player \nloses if their squirrel gets hit three times.\nI’m not really sure where I got the idea for a video game where squirrels eat each other.\nThere are three types of data structures in this game, which are represented as dictionary values.\nThe types are player squirrels, enemy squirrels, and grass objects.\nThere is only one player \nsquirrel object at a time in the game.\nBut really, the player squirrel, enemy \nsquirrels, and grass ―objects‖ are just dictionary values.\nAll the objects have the following keys in their dictionary value: 'x', 'y', and 'rect'.\n'x' and 'y' key’s value give the coordinates of the top left of the object in game world \nThese are different from pixel coordinates (which is what the 'rect' key’s value \nThe difference between game world and pixel coordinates will be explained when you \nIn addition, the player squirrel, enemy squirrel, and grass objects have other keys which are \nThis source code can be downloaded from http://invpy.com/squirrel.py.\nmessages, look at the line number that is mentioned in the error message and check your code for \nhttp://invpy.com/diff/squirrel to see if the differences between your code and the code in the \nNUMSQUIRRELS = 30    # number of squirrels in the active area \nThis program has three data structures to represent the player, enemy \nsquirrels, and grass background objects.\n'x' - the left edge coordinate of the object in the game world (not a \n'y' - the top edge coordinate of the object in the game world (not a \n'rect' - the pygame.Rect object representing where on the screen the \nPlayer data structure keys: \n'surface' - the pygame.Surface object that stores the image of the \nsquirrel which will be drawn to the screen.\n'size' - the width and height of the player in pixels.\n'health' - an integer showing how many more times the player can be \nEnemy Squirrel data structure keys: \n'surface' - the pygame.Surface object that stores the image of the \nsquirrel which will be drawn to the screen.\n'width' - the width of the squirrel's image, in pixels \n'height' - the height of the squirrel's image, in pixels \n'bounceheight' - how high (in pixels) the squirrel bounces \npygame.Surface object in GRASSIMAGES used for this grass object \nDISPLAYSURF = pygame.display.set_mode((WINWIDTH, WINHEIGHT)) \npygame.display.set_caption('Squirrel Eat Squirrel') \nL_SQUIR_IMG = pygame.image.load('squirrel.png') \n# set up variables for the start of a new game \n# create the surfaces to hold game text \ngrassObjs = []    # stores all the grass objects in the game \nsquirrelObjs = [] # stores all the non-player squirrel objects \n# stores the player object: \nwhile True: # main game loop \n# move all the squirrels \n# draw all the grass objects on the screen \n# draw the other squirrels \n# draw the player squirrel \nif playerObj['facing'] == RIGHT: # change player image \nif playerObj['facing'] == LEFT: # change player image \n# stop moving the player's squirrel \n# check if the player has collided with any squirrels \n# a player/squirrel collision has occurred \n# player is larger and eats the squirrel \nreturn # end the current game \ncameraRect = pygame.Rect(camerax, cameray, WINWIDTH, WINHEIGHT) \n# create a Rect object with the random coordinates and use \nreturn x, y \nif sq['movex'] < 0: # squirrel is facing left \nelse: # squirrel is facing right \ngr['rect'] = pygame.Rect( (gr['x'], gr['y'], gr['width'], \nobjRect = pygame.Rect(obj['x'], obj['y'], obj['width'], obj['height']) \nplayer squirrel when it moves 90 pixels away from the center of the window.\nNUMSQUIRRELS = 30    # number of squirrels in the active area \nThis program has three data structures to represent the player, enemy \nsquirrels, and grass background objects.\n'x' - the left edge coordinate of the object in the game world (not a \n'y' - the top edge coordinate of the object in the game world (not a \n'rect' - the pygame.Rect object representing where on the screen the \nPlayer data structure keys: \n'surface' - the pygame.Surface object that stores the image of the \nsquirrel which will be drawn to the screen.\n'size' - the width and height of the player in pixels.\n'health' - an integer showing how many more times the player can be \nEnemy Squirrel data structure keys: \n'surface' - the pygame.Surface object that stores the image of the \nsquirrel which will be drawn to the screen.\n'width' - the width of the squirrel's image, in pixels \n'height' - the height of the squirrel's image, in pixels \n'bounceheight' - how high (in pixels) the squirrel bounces \npygame.Surface object in GRASSIMAGES used for this grass object \nthe player squirrel, enemy squirrel, and grass objects.\nIn Python, a multi-line string value by itself \nDISPLAYSURF = pygame.display.set_mode((WINWIDTH, WINHEIGHT)) \npygame.display.set_caption('Squirrel Eat Squirrel') \nThe first several lines of the main() function are the same setup code that we’ve seen in our \nThe pygame.display.set_icon() is a Pygame function that \nL_SQUIR_IMG = pygame.image.load('squirrel.png') \nThe image for the player and enemy squirrels is loaded from squirrel.png on line 74.\nsquirrel facing to the left.\nWe also need a Surface object that contains a picture of the squirrel \nSurface object that returns has the image of the squirrel facing to the right.\n# set up variables for the start of a new game \nThe Squirrel Eat Squirrel game has quite a few variables that track the game state.\n# create the surfaces to hold game text \nSQUIRREL!‖, and ―(Press \"r\" to restart.)‖ text that appears on the screen after the game ends \nThe camerax and cameray variables track the game coordinates of the ―camera‖.\nbecause it is as though our screen is just the area of the game world in front what a camera would \nsquirrels are located (in game world coordinates) at (-384, -84), (384, 306), and (585, -234).\ndifferent numbers to the pygame.display.set_mode() function), so we need to track \nwhere the camera’s origin is located in game world coordinates.\ncoordinates of the squirrels (that is, where on the screen they appear), take the game coordinates \nof the squirrel and subtract the game coordinates of the camera’s origin.\nSo the squirrel on the left has game world coordinates of (-384, -84) but appears at (102, 246) on \nWhen we do the same calculation to find the pixel coordinates of the other two squirrels, we find \nenemy squirrel or grass objects, we don’t want them to be created inside the view of the camera, \nsquirrel and grass objects can safely be created.\nAlso, when squirrel and grass objects are beyond the border of the active area then they are far \ngrassObjs = []    # stores all the grass objects in the game \nsquirrelObjs = [] # stores all the non-player squirrel objects \n# stores the player object: \nThe grassObjs variable holds a list of all the grass objects in the game.\nThe same goes for the squirrelObjs variable and the enemy squirrel objects.\nThe playerObj variable is not a list, but just the dictionary value itself.\nThe move variables on lines 120 to 123 track which of arrow keys (or WASD keys) are being \nThe active area should start off with a few grass objects visible on the screen.\nmakeNewGrass() function will create and return a grass object that is randomly located \nwhile True: # main game loop \nThe game loop, like the game loops in the previous game programs, will do event handling, \nupdating the game state, and drawing everything to the screen.\nWhen the player gets hit by an enemy squirrel and does not die, we make the player invulnerable \nDuring this time, the player’s \ntime is over, line 134 will set invulnerableMode to False.\nMoving the Enemy Squirrels \n# move all the squirrels \nThe enemy squirrels all move according to the values in their 'movex' and 'movey' keys.\nthese values are positive, the squirrels move right or down.\nThe larger the value, the farther they move on each iteration through the game \nThe for loop on line 137 will apply this moving code to each of the enemy squirrel objects in the \nFirst, line 139 and 140 will adjust their 'x' and 'y' keys’ values.\nThe value in sObj['bounce'] is incremented on each iteration of the game loop for each \nsquirrel.\nWhen this value is 0, the squirrel is at the very beginning of its bounce.\nsObj['bouncerate'] value makes for a faster bounce.\nthen it only takes three iterations through the game loop for the squirrel to do a full bounce.\nThis is what lines 142 and 143 do.\nThere is a 2% chance on each iteration through the game loop that the squirrel will randomly \nset to 2 on line 33) then a new value will be set for sObj['movex'] and sObj['movey'].\nBecause this means the squirrel might have changed direction, the Surface object in \nSurface object scaled from R_SQUIR_IMG and line 152 gets one scaled from L_SQUIR_IMG.\nRemoving the Far Away Grass and Squirrel Objects \nDuring each iteration of the game loop, the code will check all of the grass and enemy squirrel \nthe grass/enemy squirrel object, and returns True if the object is not located in the active area.\nIf this is the case, this object is deleted on line 158 (for grass objects) or line 161 (for squirrel \nThis is how squirrel and grass objects get deleted when the player moves far enough \naway from them (or when the enemy squirrels move away far enough from the player).\nensures that there is always a number of squirrels and grass objects near the player.\nDeleting squirrel and grass objects is done with the del operator.\nloop on line 156 and 159 pass arguments to the range() function so that the numbering starts at \nmeans that the call to range(4) would cause the for loop to iterate with the values 0, 1, 2, \nSimilarly, we can delete grass and squirrel objects from the grassObjs and squirrelObjs \nlists without error because the for loop on lines 156 and 159 iterate in reverse order.\nAdding New Grass and Squirrel Objects \nalways plenty of grass and squirrel objects in the active area at all times.\nthen new grass and squirrel objects are created.\nmakeNewSquirrel() functions that create these objects are explained later in this chapter.\nThe camera’s position (which is stored as integers in the camerax and cameray variables) \nLine 19 set the CAMERASLACK \nconstant to 90, which our program will take to mean that the player squirrel can move 90 pixels \nfrom the center before the camera position gets updated to follow the squirrel.\nHALF_WINHEIGHT) are the XY game world coordinates currently at the center of the screen.\nThe playerCenterx and playerCentery is set to the middle of the player’s squirrel’s \nposition, also in game world coordinates.\nFor line 172, if the center X coordinate minus the player’s center X coordinate is greater than the \nCAMERASLACK value, that means the player is more pixels to the right of the center of the \nplayer squirrel is just at the edge of the camera slack.\nThis is why line 173 sets camerax to \nvariable is changed, not the playerObj['x'] value.\nplayer.\nDrawing the Background, Grass, Squirrels, and Health Meter \nLine 182 begins the code that starts drawing the contents of the display Surface object.\nFirst, line \n# draw all the grass objects on the screen \nThe for loop on line 185 goes through all the grass objects in the grassObjs list and creates a \nRect object from the x, y, width, and height information stored in it.\nthe grass objects with similar gObj['grassImage'] values look identical.\n# draw the other squirrels \nThe for loop that draws all the enemy squirrel game objects is similar to the previous for loop, \nexcept that the Rect object it creates is saved in the 'rect' key’s value of the squirrel \nThe reason the code does this is because we will use this Rect object later to check if \nthe enemy squirrels have collided with the player squirrel.\nfunction will return the number of pixels that the top value should be raised.\nAlso, there is no common list of Surface objects of the squirrel images, like there was with grass \ngame objects and GRASSIMAGES.\nEach enemy squirrel game object has its own Surface object \n# draw the player squirrel \nAfter drawing the grass and enemy squirrels, the code will draw the player’s squirrel.\nthere is one case where we would skip drawing the player’s squirrel.\nwith a larger enemy squirrel, the player takes damage and flashes for a little bit to indicate that \nThis flashing effect is done by drawing the player squirrel \non some iterations through the game loop but not on others.\nThe player squirrel will be drawn on game loop iterations for a tenth of a second, and then not \nas the player is invulnerable (which, in the code, means that the invulnerableMode variable \nINVULNTIME constant variable on line 25.\nIn fact, time.time() will keep returning values that will end up putting False into \nflashIsOn variable will constantly have False for one tenth of a second, and then True for \nThere are three things that must be True before we draw the player’s squirrel.\nThe game must \nThe code for drawing the player’s squirrel is almost identical to the code for drawing the enemy \nsquirrels.\nThe drawHealthMeter() function draws the indicator at the top left corner of the screen that \ntells the player how many times the player squirrel can be hit before dying.\nvariable (moveRight, moveDown, etc.) for that direction should be set to True and the move \nif playerObj['facing'] == RIGHT: # change player image \nif playerObj['facing'] == LEFT: # change player image \nThe moveLeft and moveRight variables should also be set when the left or right arrow keys \nIf the player squirrel is now facing a new direction, the playerObj['surface'] \nvalue should be replaced with a correctly scaled image of the squirrel facing the new direction.\nLine 229 is run if the left arrow key was pressed and checks if the player squirrel was facing \nIf that was so, then a new scaled Surface object of the player squirrel image is stored in \nThe code in line 232’s elif statement handles the opposite case.\nIf the player has won the game by growing large enough (in which case, winMode will be set to \nTrue) and the R key has been pressed, then runGame()should return.\ngame, and a new game will start the next time that runGame() gets called.\n# stop moving the player's squirrel \nIf the player lets up on any of the arrow or WASD keys, then the code should set the move \nThe code inside the if statement on line 255 will move the player’s squirrel around only if the \ngame is not over.\n(This is why pressing on the arrow keys after the player’s squirrel dies will have \nno effect.) Depending on which of the move variables is set to True, the playerObj dictionary \nshould have its playerObj['x'] and playerObj['y'] values changed by MOVERATE.\n(This is why a larger value in MOVERATE makes the squirrel move faster.) \nThe value in playerObj['bounce'] keeps track of at what point in bouncing the player is \nThis variable stores an integer value from 0 to BOUNCERATE.\nthe enemy squirrels, a playerObj['bounce'] value of 0 means the player squirrel is at the \nstart of a bounce and a value of BOUNCERATE means the player squirrel is at the end of the \nThe player squirrel will bounce whenever the player is moving, or if the player has stopped \nmoving but the squirrel hasn’t finished its current bounce.\nIf any of the move variables is set to True or the current \nplayerObj['bounce'] is not 0 (which means the player is currently in a bounce), then the \nvariable should be incremented on line 267.\n# check if the player has collided with any squirrels \nThe for loop on 273 will go run code on each of the enemy squirrel game objects in \nNotice that the parameters to range() on line 273 start at the last index of \ndeleting some of these enemy squirrel game objects (if the player’s squirrel ends up eating them), \n# a player/squirrel collision has occurred \n# player is larger and eats the squirrel \nIf the player’s squirrel is equal or larger than the size of the enemy squirrel it has collided with, \nthen the player’s squirrel will eat that squirrel and grow.\nkey in the player object (that is, the growth) is calculated based on the enemy squirrel’s size on \nline 280.\nSo, according to the chart, eating a squirrel that has a width and height of 45 (that is, an area of \nLine 281 deletes the eaten squirrel object from the squirrelObjs list so that it will no longer \nThe player’s squirrel image needs to be updated now that the squirrel is larger.\npygame.transform.scale() function, which will return an enlarged version of the image.\nwhich original squirrel image we pass to the function.\nSize of Eaten Squirrel (width & height) \nThe way the player wins the game is by getting the squirrel to have a size larger than the integer \nIf this is true, then the winMode variable is set to \nchecking for the player to press the R key to restart the game.\nIf the player’s area was not equal to or larger than the area of the enemy squirrel, and \ninvulnerableMode was not set to True, then the player will take damage from colliding \nTo prevent the player from being damaged several times by the same squirrel immediately, we \nwill briefly make the player invulnerable to further squirrel attacks by setting \ninvulnerableMode to True on line 293.\nLine 294 will set invulnerableStartTime to \nthe current time (which is returned by time.time()) so that lines 133 and 134 can know when \nLine 295 decrements the player’s health by 1.\nnow at 0, line 296 checks for this and, if so, sets gameOverMode to True and \nThe Game Over Screen \nreturn # end the current game \nWhen the player has died, the ―Game Over‖ text (which is on the Surface object in the \nThis lets the enemy squirrels continue to be animated and moving around for a few seconds after \nthe player dies and before the next game starts.\ndoes not wait until the player presses a key before a new game starts.\nThe winMode variable is set to True on line 289 if the player has reached a certain size (which \nhave achieved OMEGA SQUIRREL!‖ text (which is on the Surface object stored in the \nwinSurf variable) and the ―(Press ―r‖ to restart.)‖ text (which is on the Surface object stored in \nkey, at which point the program execution will return from runGame().\ncode for the R key is done on lines 238 and 239.\nTo draw the health meter, first the for loop on line 317 draws the filled-in red rectangle for the \nThen the for loop on line 319 draws an unfilled white rectangle \nfor all of the possible health the player could have (which is the integer value stored in the \nThe terminate() function works the same as in the previous game programs.\nYou can pass an int or float value to math.sin(), and it will return a float value that is \nValues Returned by math.sin() \nValues Returned by math.sin() \nalso stored in the constant variable pi in the math module (which is why line 333 uses the \nwant a wavy-looking bounce for our squirrel, we’ll only pay attention to the return values of \nRemember that on line 21 we set the BOUNCERATE constant to 6.\nValues Returned by math.sin() \nAs playerObj['bounce'] gets its value incremented, the getBounceAmount() function \nwill return values that have the same bounce shape that the sine wave has from 0 to 3.14.\nsquirrel will move.\ncameraRect = pygame.Rect(camerax, cameray, WINWIDTH, WINHEIGHT) \n# create a Rect object with the random coordinates and use \nreturn x, y \nWhen a new squirrel or grass object is created in the game world, we want it to be within the \nactive area (so that it is near the player’s squirrel) but not within the view of the camera (so that it \nLine 352 will check if the random XY coordinates would \nthe while loop on line 346 will keep generating new coordinates until it finds acceptable ones.\nCreating Enemy Squirrel Data Structures \nCreating enemy squirrel game objects is similar to making the grass game objects.\nThe width and height are set to random sizes on \nline 360 and 361.\nwidth and height of the squirrel are this general size with a random number from 0 to 10 added to \nThe original XY coordinate position of the squirrel will be a random location that the camera \nif sq['movex'] < 0: # squirrel is facing left \nelse: # squirrel is facing right \nright-facing squirrel images on them.\npygame.transform.scale() function to match the squirrel’s  width and height (stored in \nwhich is 0 because the squirrel always starts at the beginning of the bounce) and the dictionary is \nreturned on line 372.\ngr['rect'] = pygame.Rect( (gr['x'], gr['y'], gr['width'], \nThe grass game objects are dictionaries with the usual 'x', 'y', 'width', 'height', and \nThis number will determine what image the grass game object \nFor example, if the value of the grass object’s 'grassImage' key is 3, then it will use the \nobjRect = pygame.Rect(obj['x'], obj['y'], obj['width'], obj['height']) \nThe isOutsideActiveArea() will return True if the object you pass it is outside of the \nWe can create a Rect object that represents the active area by passing camerax - WINWIDTH \nSince the player squirrel, enemy squirrel and grass objects all have 'x', 'y', 'width' and \n'height' keys, the isOutsideActiveArea() code can work with any type of those game \nSquirrel Eat Squirrel was our first game to have multiple enemies moving around the board at \nenemy squirrel, so that the same code could be run on each of them during an iteration through \nthat involve a player moving around a large game world, you will need code to handle converting \nbetween the game world’s coordinate system and the screen’s pixel coordinate system.",
    "keywords": [
      "SQUIRREL EAT SQUIRREL",
      "SQUIRREL",
      "SQUIRREL EAT",
      "EAT SQUIRREL",
      "Piece",
      "player squirrel",
      "True",
      "False",
      "Board",
      "game",
      "player",
      "squirrel game objects",
      "shape",
      "Eat Squirrel Squirrel",
      "Squirrel Squirrel Eat"
    ],
    "concepts": [
      "squirrel",
      "squirrels",
      "function",
      "functions",
      "lines",
      "line",
      "lined",
      "def",
      "game",
      "games"
    ]
  },
  {
    "chapter_number": 9,
    "title": "– STAR PUSHER",
    "start_page": 260,
    "end_page": 310,
    "summary": "The player is in a room with several stars.\nThe player cannot push a star if there is a \nthe player will have to restart the level.\nfloor tiles, the level is complete and the next level starts.\nEach level is made up of a 2D grid of tile images.\nThe level files are not included in the source code.\nInstead, you can either create the level files \nA level file with 201 levels can be downloaded from \nlevel file is in the same folder as the starpusher.py file.\nAssertionError: Cannot find the level file: starPusherLevels.txt \nThe level file can be downloaded from http://invpy.com/starPusherLevels.txt.\n# Surface objects returned by pygame.image.load().\nIMAGESDICT = {'uncovered goal': pygame.image.load('RedSelector.png'), \n'star': pygame.image.load('Star.png'), \n'title': pygame.image.load('star_title.png'), \n'solved': pygame.image.load('star_solved.png'), \n# in the level file to the Surface object it represents.\n# Read in the levels from the text file.\n# details on the format of this file and how to make your own levels.\n# Run the level to actually start playing the game: \n# Go to the next level.\n# If there are no more levels, go back to the first one.\nLoop re-calls runLevel() to reset the level \nreturn 'reset' # Reset the level.\n# Change the player image to the next one.\n# If the player pushed a key to move, make the move \n# level is solved, we should show the \"Solved!\" image.\nReturns the decorated map object.\"\"\" \ndef isBlocked(mapObj, gameStateObj, x, y): \n\"\"\"Returns True if the (x, y) position on the map is \nblocked by a wall or star, otherwise return False.\"\"\" \nif isWall(mapObj, x, y): \nelif x < 0 or x >= len(mapObj) or y < 0 or y >= len(mapObj[x]): \nreturn True # x and y aren't actually on the map.\nelif (x, y) in gameStateObj['stars']: \nreturn True # a star is blocking \n\"\"\"Given a map and game state object, see if it is possible for the \nReturns True if the player moved, otherwise False.\"\"\" \n# There is a star in the way, see if the player can push it.\n# Move the star.\nassert os.path.exists(filename), 'Cannot find the level file: %s' % \n# Each level must end with a blank line \nlevels = [] # Will contain a list of level objects.\nmapTextLines = [] # contains the lines for a single level's map.\nmapObj = [] # the map object made from the data in mapTextLines \n# Process each line that was in the level file.\nif ';' in line: \n# Ignore the ; lines, they're comments in the level file.\nif line != '': \n# This line is part of the map.\nelif line == '' and len(mapTextLines) > 0: \n# A blank line indicates the end of a level's map in the file.\n# Convert the text in mapTextLines into a level object.\nmapObj[x].append(mapTextLines[y][x]) \nstartx = None # The x and y for the player's starting position \ngoals = [] # list of (x, y) tuples for each goal.\nstars = [] # list of (x, y) for each star's starting position.\nfor y in range(len(mapObj[x])): \nif mapObj[x][y] in ('@', '+'): \nif mapObj[x][y] in ('.', '+', '*'): \ngoals.append((x, y)) \nif mapObj[x][y] in ('$', '*'): \n# '$' is star \nstars.append((x, y)) \nassert len(goals) > 0, 'Level %s (around line %s) in %s must \nassert len(stars) >= len(goals), 'Level %s (around line %s) in \n# Create level object and starting game state object.\nreturn levels \ndef floodFill(mapObj, x, y, oldCharacter, newCharacter): \npositions to the left, right, down, and up of (x, y), recursively.\"\"\" \nif mapObj[x][y] == oldCharacter: \nmapObj[x][y] = newCharacter \nif x < len(mapObj) - 1 and mapObj[x+1][y] == oldCharacter: \nfloodFill(mapObj, x+1, y, oldCharacter, newCharacter) # call right \nif x > 0 and mapObj[x-1][y] == oldCharacter: \nfloodFill(mapObj, x-1, y, oldCharacter, newCharacter) # call left \nif y < len(mapObj[x]) - 1 and mapObj[x][y+1] == oldCharacter: \nfloodFill(mapObj, x, y+1, oldCharacter, newCharacter) # call down \nif y > 0 and mapObj[x][y-1] == oldCharacter: \nfloodFill(mapObj, x, y-1, oldCharacter, newCharacter) # call up \n\"\"\"Draws the map to a Surface object, including the player and \nstars.\ndoes it draw the \"Level\" and \"Steps\" text in the corner.\"\"\" \n# mapSurf will be the single Surface object that the tiles are drawn \nfor y in range(len(mapObj[x])): \nspaceRect = pygame.Rect((x * TILEWIDTH, y * (TILEHEIGHT - \nif mapObj[x][y] in TILEMAPPING: \nbaseTile = TILEMAPPING[mapObj[x][y]] \nelif mapObj[x][y] in OUTSIDEDECOMAPPING: \nif mapObj[x][y] in OUTSIDEDECOMAPPING: \nmapSurf.blit(OUTSIDEDECOMAPPING[mapObj[x][y]], spaceRect) \nelif (x, y) in gameStateObj['stars']: \nif (x, y) in goals: \nelif (x, y) in goals: \nif (x, y) == gameStateObj['player']: \n\"\"\"Returns True if all the goals have stars in them.\"\"\" \nif goal not in gameStateObj['stars']: \n# Found a space with a goal but no star on it.\nThe grassy tiles outside of the level’s room will sometimes have extra decorations added to them \n# Surface objects returned by pygame.image.load().\nIMAGESDICT = {'uncovered goal': pygame.image.load('RedSelector.png'), \n'star': pygame.image.load('Star.png'), \n'title': pygame.image.load('star_title.png'), \n'solved': pygame.image.load('star_solved.png'), \nto use in other functions, since only the IMAGESDICT variable needs to be made global.\n# in the level file to the Surface object it represents.\nThe data structure for the map is just a 2D list of single character strings.\nThe PLAYERIMAGES list stores the images used for the player.\nset to 0 then PLAYERIMAGES[0], which is the ―princess‖ player image, is drawn to the screen.\n# Read in the levels from the text file.\n# details on the format of this file and how to make your own levels.\ninstructions for the game) until the player presses a key.\nstartScreen() function returns and then reads in the levels from the level file.\nstarts off on the first level, which is the level object in the levels list at index 0.\n# Run the level to actually start playing the game: \nIt is passed a list of level objects, \nthe level, runLevel() will return one of the following strings: 'solved' (because the player \nhas finished putting all the stars on the goals), 'next' (because the player wants to skip to the \nnext level), 'back' (because the player wants to go back to the previous level), and 'reset' \n(because the player wants to start playing the current level over again, maybe because they \n# Go to the next level.\n# If there are no more levels, go back to the first one.\nLoop re-calls runLevel() to reset the level \nThe levels list contains all the level objects that were loaded from the level file.\nThe level object \nfor the current level (which is what levelNum is set to) is stored in the levelObj variable.\nmap object (which makes a distinction between indoor and outdoor tiles, and decorates the \noutdoor tiles with trees and rocks) is returned from the decorateMap() function.\nthe state of the game while the player plays this level, a copy of the game state object that is \nlevelObj['startState'] represents the game state at the very beginning of the level, and \nOtherwise, if the player restarts the level, the original game state \nThe copy.deepcopy() function is used because the game state object is a dictionary of that \nMore variables are set at the start of playing a level.\nThe camera in Star Pusher can be moved independently of the player moving around the map.\nmove the player character on the map.\nreturn 'reset' # Reset the level.\n# Change the player image to the next one.\n# If the player pushed a key to move, make the move \n# level is solved, we should show the \"Solved!\" image.\nvalue was False, then the player must have tried to move into a tile that was a wall, or push a \nstar that had something behind it.\nIn this case, the player can’t move and nothing on the map \nplayer moving or a star being pushed).\nAfter the map has been drawn on line 225, the mapNeedsRedraw variable is set to False.\nLines 237 to 261 position the camera and draw the map and other graphics to the display Surface \ndef isWall(mapObj, x, y): \n\"\"\"Returns True if the (x, y) position on \nthe map is a wall, otherwise return False.\"\"\" \nreturn False # x and y aren't actually on the map.\nelif mapObj[x][y] in ('#', 'x'): \nThe isWall() function returns True if there is a wall on the map object at the XY coordinates \nWall objects are represented as either a 'x' or '#' string in the map \nReturns the decorated map object.\"\"\" \nThe map object has characters that represent the position of the player, goals, and stars.\nnecessary for the map object (they’re stored in other data structures after the map file is read) so \nThe floodFill() function will change all of the tiles inside the walls from ' ' characters to \nThe large, multi-line if statement on line 301 checks if the wall tile at the current XY \nIf so, the '#' string in the map object that represents a normal wall is changed to a \n'x' string which represents a corner wall tile.\ndef isBlocked(mapObj, gameStateObj, x, y): \n\"\"\"Returns True if the (x, y) position on the map is \nblocked by a wall or star, otherwise return False.\"\"\" \nif isWall(mapObj, x, y): \nelif x < 0 or x >= len(mapObj) or y < 0 or y >= len(mapObj[x]): \nreturn True # x and y aren't actually on the map.\nelif (x, y) in gameStateObj['stars']: \nreturn True # a star is blocking \nThere are three cases where a space on the map would be blocked: if there is a star, a wall, or the \n\"\"\"Given a map and game state object, see if it is possible for the \nReturns True if the player moved, otherwise False.\"\"\" \n# There is a star in the way, see if the player can push it.\n# Move the star.\nThe makeMove() function checks to make sure if moving the player in a particular direction is \nIf there was a star in the space that the player wanted to move, that star’s position is also changed \nWe will store each line as a string in the instructionText list.\nimage (stored in IMAGESDICT['title'] as a Surface object (that was originally loaded from \nthe star_title.png file)) will be positioned 50 pixels from the top of the window.\ngoing to be set so that the images and text are centered, as it is on line 385 for the title image.\nOn line 386, the topCoord variable is increased by whatever the height of that image is.\nLine 400 is where the title image is blitted to the display Surface object.\nline 403 will render, position, and blit each instructional string in the instructionText loop.\nlines of text).\nThere is a game loop in startScreen() that begins on line 412 and handles events that \nplayer does either, the loop will keep calling pygame.display.update() and \nStar Pusher has a specific format for the levels, maps, and game state data structures.\nThe game state object will be a dictionary with three keys: 'player', 'stepCounter', and \n'stars'.\nthe player has made in this level (so the player can try to solve the puzzle in the future \nThe value at the 'stars' key is a list of two-integer tuples of XY values for each of the \nstars on the current level.\nThe map data structure is simply a 2D list of lists where the two indexes used represent the X and \nY coordinates of the map.\n'@' – The starting space for the player on this level.\n'$' – A space where a star is at the start of the level.\n'+' – A space with a goal and the starting player’s space.\n'*' – A space with a goal and a star at the start of the level.\nThe level object contains a game state object (which will be the state used when the level first \nstarts), a map object, and a few other values.\nThe level object itself is a dictionary with the \nThe value at the key 'width' is an integer of how many tiles wide the entire map is.\nThe value at the key 'height' is an integer of how many tiles tall the entire map is.\nThe value at the key 'mapObj' is the map object for this level.\nThe value at the key 'startState' is a game state object used to show the starting \nposition of the stars and player at the start of the level.\nPython has functions for reading files off of the player’s hard drive.\na separate file keep all of the data for each level.\nnew levels, the player doesn’t have to change the source code of the game but instead can just \ndownload new level files.\nTo create a file, call the open() function pass it two arguments: a string for the name of the file, \nand the string 'w' to tell the open() function you want to open the file in ―write‖ mode.\nopen() function returns a file object: \nIf you run this code from the interactive shell, the hello.txt file that this function creates will be \nIf the open() function is called from a .py program, the file is created in the same \nThe file object has a method called write() which can be used to write text to the file.\nTo read the content of a file, pass the string 'r' instead of 'w' to the open() function.\nThe readlines() method returns a list of strings: one string for each line of text in the file: \nAbout the Star Pusher Map File Format \nWe need the level text file to be in a specific format.\nIf we have the maps for multiple levels, how can we tell when one \nlevel’s map ends and the next one begins?\nmap file format.\nIf you download the levels file from http://invpy.com/starPusherLevels.txt and \n;   + - Player & goal \n;   * - Star & goal \n; Level maps are separated by a blank line (I like to use a ; at the start \nJust place the levels in a text file \nWhen you load the first level, it \nassert os.path.exists(filename), 'Cannot find the level file: %s' % \nThe os.path.exists() function will return True if the file specified by the string passed to \n# Each level must end with a blank line \nlevels = [] # Will contain a list of level objects.\nmapTextLines = [] # contains the lines for a single level's map.\nmapObj = [] # the map object made from the data in mapTextLines \nThe file object for the level file that is opened for reading is stored in mapFile.\nfrom the level file is stored as a list of strings in the content variable, with a blank line added \nAfter the level objects are created, they will be stored in the levels list.\nvariable will keep track of how many levels are found inside the level file.\nstores the strings of all maps in the level file).\n# Process each line that was in the level file.\nThe for loop on line 437 will go through each line that was read from the level file one line at a \nin line.\nif ';' in line: \n# Ignore the ; lines, they're comments in the level file.\nAny text that exists after a semicolon in the map file is treated like a comment and is ignored.\naccidentally think the comment is part of the map, the line variable is modified so that it only \nIt is not changing the level file on the hard drive.) \nif line != '': \n# This line is part of the map.\nThere can be maps for multiple levels in the map file.\nlines of text from the map file for the current level being loaded.\nelif line == '' and len(mapTextLines) > 0: \n# A blank line indicates the end of a level's map in the file.\n# Convert the text in mapTextLines into a level object.\nWhen there is a blank line in the map file, that indicates that the map for the current level has \nAnd future lines of text will be for the later levels.\nmapObj[x].append(mapTextLines[y][x]) \nThis is why line \ngame.) But the map object will have to be a list of list of single-character strings such that \nmapObj[x][y] refers to the tile at the XY coordinates.\nThe nested for loops on line 465 and 466 will fill these lists with single-character strings to \nrepresent each tile on the map.\nThis creates the map object that Star Pusher uses.\nstartx = None # The x and y for the player's starting position \ngoals = [] # list of (x, y) tuples for each goal.\nstars = [] # list of (x, y) for each star's starting position.\nfor y in range(len(mapObj[x])): \nif mapObj[x][y] in ('@', '+'): \nif mapObj[x][y] in ('.', '+', '*'): \ngoals.append((x, y)) \nif mapObj[x][y] in ('$', '*'): \n# '$' is star \nstars.append((x, y)) \nAfter creating the map object, the nested for loops on lines 475 and 476 will go through each \nwhich will then be stored in the game state object later on line 494.\n2. The starting position of all the stars These will be stored in the stars list, which is later \nstored in the game state object on line 496.\nin the level object on line 500.\nposition is stored in it (because the player can move around) and why the stars are stored in it \n(because the stars can be pushed around by the player).\nBut the goals are stored in the level \nassert len(goals) > 0, 'Level %s (around line %s) in %s must \nassert len(stars) >= len(goals), 'Level %s (around line %s) in \nwith the level file.\nThe first assertion on line 489 checks to make sure that there is a player starting point listed \n# Create level object and starting game state object.\nFinally, these objects are stored in the game state object, which itself is stored in the level object.\nThe level object is added to a list of level objects on line 503.\nIt is this levels list that will be \nreturned by the readLevelsFile() function when all of the maps have been processed.\nreturn levels \nNow that this level is done processing, the variables for mapTextLines, mapObj, and \ngameStateObj should be reset to blank values for the next level that will be read in from the \nlevel file.\nWhen you run this program, the function gets defined when the def statement on line A \nfunction calls itself on line F and passes 42.\nOn line K, the function is called and 41 is passed for the param parameter.\nLine F will then make a call, recursively, to the function and passes \nline of the function, line I, will execute to print out ―End of function.‖ and the function returns to \nBut remember, the line of code that called the function was line F.\nline I which makes ―End of function.‖ display for a second time.\nSince it has reached the end of the function, it returns to the line of code that called this function \nThere are no more lines of code after line K, so the program terminates.\nEach time a function is called, the Python interpreter remembers which line of code made the call.\nFile \"C:\\test67.py\", line 2, in funky \nFile \"C:\\test67.py\", line 2, in funky \nFile \"C:\\test67.py\", line 2, in funky \nFile \"C:\\test67.py\", line 2, in funky \nFile \"C:\\test67.py\", line 2, in funky \nremember what line of code made that call so that when the function returns it can resume the \nBut the funky() function never returns, it just keeps making calls to itself.\nFile \"C:\\test67.py\", line 2, in spam \nFile \"C:\\test67.py\", line 5, in eggs \nFile \"C:\\test67.py\", line 2, in spam \nFile \"C:\\test67.py\", line 5, in eggs \nFile \"C:\\test67.py\", line 2, in spam \nFile \"C:\\rectest.py\", line 5, in fizz \nFile \"C:\\rectest.py\", line 5, in fizz \nFile \"C:\\rectest.py\", line 5, in fizz \nFile \"C:\\rectest.py\", line 2, in fizz \nThe flood fill algorithm is used in Star Pusher to change all of the floor tiles inside the walls of \nthe level to use the ―inside floor‖ tile image instead of the ―outside floor‖ tile (which all the tiles \ndef floodFill(mapObj, x, y, oldCharacter, newCharacter): \npositions to the left, right, down, and up of (x, y), recursively.\"\"\" \nif mapObj[x][y] == oldCharacter: \nmapObj[x][y] = newCharacter \nLine 522 and 523 converts the tile at the XY coordinate passed to floodFill() to the \nif x < len(mapObj) - 1 and mapObj[x+1][y] == oldCharacter: \nfloodFill(mapObj, x+1, y, oldCharacter, newCharacter) # call right \nif x > 0 and mapObj[x-1][y] == oldCharacter: \nfloodFill(mapObj, x-1, y, oldCharacter, newCharacter) # call left \nif y < len(mapObj[x]) - 1 and mapObj[x][y+1] == oldCharacter: \nfloodFill(mapObj, x, y+1, oldCharacter, newCharacter) # call down \nif y > 0 and mapObj[x][y-1] == oldCharacter: \nfloodFill(mapObj, x, y-1, oldCharacter, newCharacter) # call up \nrecursive calls, but instead uses a list of XY coordinates to keep track of which spaces on the map \ndef floodFill(mapObj, x, y, oldCharacter, newCharacter): \nif mapObj[x][y] == oldCharacter: \nmapObj[x][y] = newCharacter \nif x < len(mapObj) - 1 and mapObj[x+1][y] == oldCharacter: \nif x > 0 and mapObj[x-1][y] == oldCharacter: \nif y < len(mapObj[x]) - 1 and mapObj[x][y+1] == oldCharacter: \nif y > 0 and mapObj[x][y-1] == oldCharacter: \n\"\"\"Draws the map to a Surface object, including the player and \nstars.\ndoes it draw the \"Level\" and \"Steps\" text in the corner.\"\"\" \n# mapSurf will be the single Surface object that the tiles are drawn \nThe drawMap() function will return a Surface object with the entire map (and the player and \nmapObj (which is done on line 543 and 544).\nfor y in range(len(mapObj[x])): \nspaceRect = pygame.Rect((x * TILEWIDTH, y * (TILEHEIGHT - \non the map and draw the appropriate tile image at that location.\nif mapObj[x][y] in TILEMAPPING: \nbaseTile = TILEMAPPING[mapObj[x][y]] \nelif mapObj[x][y] in OUTSIDEDECOMAPPING: \nThe baseTile variable is set to the Surface object of the tile image to be drawn at the \nif mapObj[x][y] in OUTSIDEDECOMAPPING: \nmapSurf.blit(OUTSIDEDECOMAPPING[mapObj[x][y]], spaceRect) \ntree or rock image should be drawn on top of the tile that was just drawn at that XY coordinate.\nelif (x, y) in gameStateObj['stars']: \nif (x, y) in goals: \nIf there is a star located at this XY coordinate on the map (which can be found out by checking \nfor (x, y) in the list at gameStateObj['stars']), then a star should be drawn at this XY \nelif (x, y) in goals: \nif (x, y) == gameStateObj['player']: \nFinally, the drawMap() function checks if the player is located at this XY coordinate, and if so, \nthe player’s image is drawn over the tile.\non line 549 and 550, so by the time the Surface object is returned, the entire map has been drawn \n\"\"\"Returns True if all the goals have stars in them.\"\"\" \nif goal not in gameStateObj['stars']: \n# Found a space with a goal but no star on it.\nThe isLevelFinished() function returns True if all the goals are covered stars.\nlevels could have more stars than goals, so it’s important to check that all the goals are covered \nThe for loop on line 585 goes through the goals in levelObj['goals'] (which is a list of \ntuples of XY coordinates for each goal) and checks if there is a star in the \ngameStateObj['stars'] list that has those same XY coordinates (the not in operators \nwork here because gameStateObj['stars'] is a list of those same tuples of XY \nThe first time the code finds a goal with no star at the same position, the function \nAfter all the functions have been defined, the main() function is called on line 602 to begin the \nnew: having uniquely designed levels with tile graphics.\nthat the computer can read, they are typed out into a text file and code in the program reads those \nfiles and creates the data structures for the level.\nReally, rather than just make a simple game with a single map, the Star Pusher program is more \nof a system for loading custom maps based on the level file.\nJust by modifying the level file, we \ncan change where walls, stars, and goals appear in the game world.\nhandle any configuration that the level file is set to (as long as it passes the assert statements \nYou won’t even have to know how to program Python to make your own levels.\nlevel editor for the Star Pusher game.\nThe goal of the game is to have as many of the tiles \nIn Figure 10-5, the white player places a tile at 3, 6 and flips black tiles in both directions \nPlayers must always make a move that captures at least one tile.\nThe player with the most tiles \nThe image files that Flippy uses can be downloaded from http://invpy.com/flippyimages.zip.",
    "keywords": [
      "STAR PUSHER",
      "Star Pusher Star",
      "level",
      "STAR",
      "level file",
      "Pusher Star Pusher",
      "line",
      "stars",
      "player",
      "file",
      "True",
      "mapObj",
      "map",
      "Surface object",
      "return True"
    ],
    "concepts": [
      "function",
      "functions",
      "pygame",
      "line",
      "lines",
      "star",
      "stars",
      "level",
      "levels",
      "player"
    ]
  },
  {
    "chapter_number": 15,
    "title": "",
    "start_page": 311,
    "end_page": 365,
    "summary": "3. # http://inventwithpython.com/pygame \nSPACESIZE = 50 # width & height of each space on the board, in pixels \nBOARDWIDTH = 8 # how many columns of spaces on the game board \nBOARDHEIGHT = 8 # how many rows of spaces on the game board \n# (YMARGIN) the game board, in pixels.\n294    http://inventwithpython.com/pygame \nDISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \nboard: \n# Reset the board and game.\n# Draw the starting board and ask the player what color they want.\n# Make the Surface and Rect objects for the \"New Game\" and \"Hints\" \n# Draw the game board.\n296    http://inventwithpython.com/pygame \n# Draw the board.\nx, y = getComputerMove(mainBoard, computerTile) \nmakeMove(mainBoard, computerTile, x, y, True) \n298    http://inventwithpython.com/pygame \ndef translateBoardToPixelCoord(x, y): \nreturn XMARGIN + x * SPACESIZE + int(SPACESIZE / 2), YMARGIN + y * \npygame.draw.circle(DISPLAYSURF, additionalTileColor, (additionalTileX, \nfor x, y in tilesToFlip: \ncenterx, centery = translateBoardToPixelCoord(x, y) \npygame.draw.circle(DISPLAYSURF, color, (centerx, centery), \ndef drawBoard(board): \n# Draw background of board.\n# Draw grid lines of the board.\nfor x in range(BOARDWIDTH + 1): \npygame.draw.line(DISPLAYSURF, GRIDLINECOLOR, (startx, starty), \nfor y in range(BOARDHEIGHT + 1): \npygame.draw.line(DISPLAYSURF, GRIDLINECOLOR, (startx, starty), \nfor x in range(BOARDWIDTH): \nfor y in range(BOARDHEIGHT): \ncenterx, centery = translateBoardToPixelCoord(x, y) \nif board[x][y] == WHITE_TILE or board[x][y] == BLACK_TILE: \nif board[x][y] == WHITE_TILE: \npygame.draw.circle(DISPLAYSURF, tileColor, (centerx, \nif board[x][y] == HINT_TILE: \npygame.draw.rect(DISPLAYSURF, HINTCOLOR, (centerx - 4, \n# Return a tuple of two integers of the board space coordinates where \nfor x in range(BOARDWIDTH): \nfor y in range(BOARDHEIGHT): \nif mousex > x * SPACESIZE + XMARGIN and \\ \nmousex < (x + 1) * SPACESIZE + XMARGIN and \\ \nreturn (x, y) \ndef drawInfo(board, playerTile, computerTile, turn): \n300    http://inventwithpython.com/pygame \nscores = getScoreOfBoard(board) \ndef resetBoard(board): \n# Blanks out the board it is passed, and sets up starting tiles.\nfor x in range(BOARDWIDTH): \nfor y in range(BOARDHEIGHT): \nboard[x][y] = EMPTY_SPACE \nboard[3][3] = WHITE_TILE \nboard[3][4] = BLACK_TILE \nboard[4][3] = BLACK_TILE \nboard[4][4] = WHITE_TILE \nboard = [] \nboard.append([EMPTY_SPACE] * BOARDHEIGHT) \nreturn board \ndef isValidMove(board, tile, xstart, ystart): \nboard[xstart][ystart] = tile # temporarily set the tile on the board.\nx, y = xstart, ystart \nif isOnBoard(x, y) and board[x][y] == otherTile: \nif not isOnBoard(x, y): \nwhile board[x][y] == otherTile: \nif not isOnBoard(x, y): \nif not isOnBoard(x, y): \nif board[x][y] == tile: \nif x == xstart and y == ystart: \ntilesToFlip.append([x, y]) \nboard[xstart][ystart] = EMPTY_SPACE # make space empty \ndef isOnBoard(x, y): \n# Returns True if the coordinates are located on the board.\nreturn x >= 0 and x < BOARDWIDTH and y >= 0 and y < BOARDHEIGHT \ndef getBoardWithValidMoves(board, tile): \n# Returns a new board with hint markings.\n302    http://inventwithpython.com/pygame \nfor x, y in getValidMoves(dupeBoard, tile): \ndupeBoard[x][y] = HINT_TILE \ndef getValidMoves(board, tile): \n# Returns a list of (x,y) tuples of all valid moves.\nfor x in range(BOARDWIDTH): \nfor y in range(BOARDHEIGHT): \nif isValidMove(board, tile, x, y) != False: \nvalidMoves.append((x, y)) \ndef getScoreOfBoard(board): \nfor x in range(BOARDWIDTH): \nfor y in range(BOARDHEIGHT): \nif board[x][y] == WHITE_TILE: \nif board[x][y] == BLACK_TILE: \ndef makeMove(board, tile, xstart, ystart, realMove=False): \ntilesToFlip = isValidMove(board, tile, xstart, ystart) \nboard[xstart][ystart] = tile \nfor x, y in tilesToFlip: \nboard[x][y] = tile \ndef isOnCorner(x, y): \nreturn (x == 0 and y == 0) or \\ \n(x == BOARDWIDTH and y == 0) or \\ \n(x == 0 and y == BOARDHEIGHT) or \\ \n(x == BOARDWIDTH and y == BOARDHEIGHT) \n304    http://inventwithpython.com/pygame \ndef getComputerMove(board, computerTile): \n# Given a board and the computer's tile, determine where to \n# move and return that move as a [x, y] list.\nfor x, y in possibleMoves: \nif isOnCorner(x, y): \nreturn [x, y] \nfor x, y in possibleMoves: \nmakeMove(dupeBoard, computerTile, x, y) \nbestMove = [x, y] \nThe game ―Flood It‖ begins with a board filled with colored tiles.\nis to turn the entire board into a single color before running out of turns.\nThis game also has a Settings screen where the player can change the size of the board and the \nIf the player gets board of the colors, there are a few other color schemes \n2. # http://inventwithpython.com/pygame \n# life depending on the \"board size\" setting selected.\n306    http://inventwithpython.com/pygame \nDISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n308    http://inventwithpython.com/pygame \nif pygame.Rect(WINDOWWIDTH - \nelif pygame.Rect(WINDOWWIDTH - \ndef hasWon(board): \n# if the entire board is the same color, player has won \nfor x in range(boardWidth): \nfor y in range(boardHeight): \nif board[x][y] != board[0][0]: \n310    http://inventwithpython.com/pygame \nif pygame.Rect(74, 16, 111, 30).collidepoint(mousex, \nelif pygame.Rect(53, 50, 104, 29).collidepoint(mousex, \nelif pygame.Rect(72, 85, 65, 31).collidepoint(mousex, \nelif pygame.Rect(63, 156, 84, 31).collidepoint(mousex, \n# small board size setting: \nelif pygame.Rect(52, 192, 106,32).collidepoint(mousex, \n# medium board size setting: \nelif pygame.Rect(67, 228, 58, 37).collidepoint(mousex, \n# large board size setting: \nelif pygame.Rect(14, 299, 371, 97).collidepoint(mousex, \nelif pygame.Rect(178, 418, 215, 34).collidepoint(mousex, \n312    http://inventwithpython.com/pygame \ndef drawColorSchemeBoxes(x, y, schemeNum): \npygame.draw.rect(DISPLAYSURF, COLORSCHEMES[schemeNum][3 * boxy \nDISPLAYSURF.blit(SPOTIMAGE, (x - 50, y)) \ndef flashBorderAnimation(color, board, animationSpeed=30): \ndrawBoard(board) # draw board ON TOP OF the transparency layer \ndef floodAnimation(board, paletteClicked, animationSpeed=25): \n# Creates a board data structure with random colors for each box.\nboard = [] \nboard.append(column) \n# Make board easier by setting some boxes to same color as a neighbor.\nboard[x-1][y] == board[x][y] \nboard[x][y-1] == board[x][y] \nboard[x+1][y] == board[x][y] \nboard[x][y+1] == board[x][y] \nboard[x][y-1] == board[x][y] \nboard[x+1][y] == board[x][y] \nboard[x][y+1] == board[x][y] \nboard[x-1][y] == board[x][y] \nreturn board \n314    http://inventwithpython.com/pygame \ndef drawBoard(board, transparency=255): \ntempSurf = pygame.Surface(DISPLAYSURF.get_size()) \nfor x in range(boardWidth): \nfor y in range(boardHeight): \nleft, top = leftTopPixelCoordOfBox(x, y) \nr, g, b = paletteColors[board[x][y]] \npygame.draw.rect(tempSurf, (r, g, b, transparency), (left, \npygame.draw.rect(tempSurf, BLACK, (left-1, top-1, boxSize * boardWidth \npygame.draw.rect(DISPLAYSURF, paletteColors[i], (left, top, \npygame.draw.rect(DISPLAYSURF, bgColor,   (left + 2, top + 2, \npygame.draw.rect(DISPLAYSURF, bgColor, (20, 20, 20, 20 + (maxLife * \npygame.draw.rect(DISPLAYSURF, RED, (20, 20 + (i * \npygame.draw.rect(DISPLAYSURF, WHITE, (20, 20 + (i * lifeBoxSize), \ndef getColorOfPaletteAt(x, y): \n# Returns the index of the color in paletteColors that the x and y \nReturns None if x and y are not over any palette.\nif r.collidepoint(x, y): \nreturn None # no palette exists at these x, y coordinates \ndef floodFill(board, oldColor, newColor, x, y): \nif oldColor == newColor or board[x][y] != oldColor: \nboard[x][y] = newColor # change the color of the current box \nif x > 0: \nfloodFill(board, oldColor, newColor, x - 1, y) # on box to the \nfloodFill(board, oldColor, newColor, x + 1, y) # on box to the \n316    http://inventwithpython.com/pygame \nif y > 0: \nfloodFill(board, oldColor, newColor, x, y - 1) # on box to up \nfloodFill(board, oldColor, newColor, x, y + 1) # on box to down \n# Returns the x and y of the left-topmost pixel of the xth & yth box.\nThe game ―Connect Four‖ has a 7 x 6 board where the players take turns dropping tokens from \nthe top of the board.\n318    http://inventwithpython.com/pygame \n3. # http://inventwithpython.com/pygame \n9. BOARDWIDTH = 7  # how many spaces wide the board is \nBOARDHEIGHT = 6 # how many spaces tall the board is \nassert BOARDWIDTH >= 4 and BOARDHEIGHT >= 4, 'Board must be at least 4x4.' \nSPACESIZE = 50 # size of the tokens and individual board spaces in pixels \nDISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \nREDPILERECT = pygame.Rect(int(SPACESIZE / 2), WINDOWHEIGHT - int(3 * \nBLACKPILERECT = pygame.Rect(WINDOWWIDTH - int(3 * SPACESIZE / 2), \nREDTOKENIMG = pygame.image.load('4row_red.png') \nBLACKTOKENIMG = pygame.image.load('4row_black.png') \nBOARDIMG = pygame.image.load('4row_board.png') \n320    http://inventwithpython.com/pygame \ndef makeMove(board, player, column): \nboard[column][lowest] = player \ndef drawBoard(board, extraToken=None): \nfor x in range(BOARDWIDTH): \nfor y in range(BOARDHEIGHT): \nspaceRect.topleft = (XMARGIN + (x * SPACESIZE), YMARGIN + (y * \nif board[x][y] == RED: \nelif board[x][y] == BLACK: \nDISPLAYSURF.blit(REDTOKENIMG, (extraToken['x'], \nDISPLAYSURF.blit(BLACKTOKENIMG, (extraToken['x'], \n# draw board over the tokens \nfor x in range(BOARDWIDTH): \nfor y in range(BOARDHEIGHT): \nspaceRect.topleft = (XMARGIN + (x * SPACESIZE), YMARGIN + (y * \nboard = [] \nfor x in range(BOARDWIDTH): \nboard.append([EMPTY] * BOARDHEIGHT) \nreturn board \n322    http://inventwithpython.com/pygame \ndef getHumanMove(board, isFirstMove): \nif isValidMove(board, column): \nanimateDroppingToken(board, column, RED) \ndrawBoard(board) \ndrawBoard(board, {'x':tokenx - int(SPACESIZE / 2), 'y':tokeny \ndrawBoard(board) \ndef animateDroppingToken(board, column, color): \nx = XMARGIN + column * SPACESIZE \ndrawBoard(board, {'x':x, 'y':y, 'color':color}) \ndef animateComputerMoving(board, column): \ndrawBoard(board, {'x':x, 'y':y, 'color':BLACK}) \nwhile x > (XMARGIN + column * SPACESIZE): \ndrawBoard(board, {'x':x, 'y':y, 'color':BLACK}) \nanimateDroppingToken(board, column, BLACK) \ndef getComputerMove(board): \npotentialMoves = getPotentialMoves(board, BLACK, DIFFICULTY) \n324    http://inventwithpython.com/pygame \ndef getPotentialMoves(board, tile, lookAhead): \ndef getLowestEmptySpace(board, column): \nfor y in range(BOARDHEIGHT-1, -1, -1): \nif board[column][y] == EMPTY: \nreturn y \ndef isValidMove(board, column): \ndef isBoardFull(board): \n# Returns True if there are no empty spaces anywhere on the board.\nfor x in range(BOARDWIDTH): \nfor y in range(BOARDHEIGHT): \nif board[x][y] == EMPTY: \ndef isWinner(board, tile): \nfor x in range(BOARDWIDTH - 3): \nfor y in range(BOARDHEIGHT): \nif board[x][y] == tile and board[x+1][y] == tile and \nboard[x+2][y] == tile and board[x+3][y] == tile: \nfor x in range(BOARDWIDTH): \nfor y in range(BOARDHEIGHT - 3): \nif board[x][y] == tile and board[x][y+1] == tile and \nboard[x][y+2] == tile and board[x][y+3] == tile: \n326    http://inventwithpython.com/pygame \nfor x in range(BOARDWIDTH - 3): \nfor y in range(3, BOARDHEIGHT): \nif board[x][y] == tile and board[x+1][y-1] == tile and \nboard[x+2][y-2] == tile and board[x+3][y-3] == tile: \nfor x in range(BOARDWIDTH - 3): \nfor y in range(BOARDHEIGHT - 3): \nif board[x][y] == tile and board[x+1][y+1] == tile and \nboard[x+2][y+2] == tile and board[x+3][y+3] == tile: \n―Bejeweled‖ is a game where gems fall to fill up a board.\ngame ends when no possible match can be made on the board.\n3. # http://inventwithpython.com/pygame \n9.   'x' and 'y' - The location of the gem on the board.\nto indicate that it is above the board.\n328    http://inventwithpython.com/pygame \nBOARDWIDTH = 8 # how many columns in the board \nBOARDHEIGHT = 8 # how many rows in the board \nGRIDCOLOR = BLUE # color of the game board \nDISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \ngemImage = pygame.image.load('gem%s.png' % i) \n# Create pygame.Rect objects for each board space to \nfor x in range(BOARDWIDTH): \nfor y in range(BOARDHEIGHT): \nr = pygame.Rect((XMARGIN + (x * GEMIMAGESIZE), \n330    http://inventwithpython.com/pygame \n# Swap the gems in the board data structure.\ngameBoard[firstSwappingGem['x']][firstSwappingGem['y']] = \ngameBoard[secondSwappingGem['x']][secondSwappingGem['y']] = \ngameBoard[firstSwappingGem['x']][firstSwappingGem['y']] = \ngameBoard[secondSwappingGem['x']][secondSwappingGem['y']] \n# Remove matched gems, then pull down the board.\n332    http://inventwithpython.com/pygame \n'x': gem[0] * GEMIMAGESIZE + \n'y': gem[1] * GEMIMAGESIZE + \n# Draw the board.\nhighlightSpace(firstSelectedGem['x'], firstSelectedGem['y']) \n# If the gems at the (X, Y) coordinates of the two gems are adjacent, \nfirstGem = {'imageNum': board[firstXY['x']][firstXY['y']], \nsecondGem = {'imageNum': board[secondXY['x']][secondXY['y']], \nif firstGem['x'] == secondGem['x'] + 1 and firstGem['y'] == \nelif firstGem['x'] == secondGem['x'] - 1 and firstGem['y'] == \nelif firstGem['y'] == secondGem['y'] + 1 and firstGem['x'] == \nelif firstGem['y'] == secondGem['y'] - 1 and firstGem['x'] == \n# Create and return a blank board data structure.\nboard = [] \nfor x in range(BOARDWIDTH): \nboard.append([EMPTY_SPACE] * BOARDHEIGHT) \n334    http://inventwithpython.com/pygame \nreturn board \ndef canMakeMove(board): \n# Return True if the board is in a state where a matching \n# The x and y variables iterate over each space on the board.\nfor x in range(BOARDWIDTH): \nfor y in range(BOARDHEIGHT): \nif (getGemAt(board, x+pat[0][0], y+pat[0][1]) == \\ \ngetGemAt(board, x+pat[1][0], y+pat[1][1]) == \\ \ngetGemAt(board, x+pat[2][0], y+pat[2][1]) != None) or \n(getGemAt(board, x+pat[0][1], y+pat[0][0]) == \\ \ngetGemAt(board, x+pat[1][1], y+pat[1][0]) == \\ \ngetGemAt(board, x+pat[2][1], y+pat[2][0]) != None): \nbasex = gem['x'] \nbasey = gem['y'] \nDISPLAYSURF.blit(GEMIMAGES[gem['imageNum']], r) \ndef pullDownAllGems(board): \n# pulls down gems on the board to the bottom to fill in any gaps \nfor x in range(BOARDWIDTH): \nfor y in range(BOARDHEIGHT): \nif board[x][y] != EMPTY_SPACE: \ngemsInColumn.append(board[x][y]) \nboard[x] = ([EMPTY_SPACE] * (BOARDHEIGHT - len(gemsInColumn))) + \ndef getGemAt(board, x, y): \n336    http://inventwithpython.com/pygame \nif x < 0 or y < 0 or x >= BOARDWIDTH or y >= BOARDHEIGHT: \nreturn board[x][y] \ndef getDropSlots(board): \n# count the number of empty spaces in each column on the board \nfor x in range(BOARDWIDTH): \nif boardCopy[x][y] == EMPTY_SPACE: \nneighborGem = getGemAt(boardCopy, x + offsetX, y + \nboardCopy[x][y] = newGem \ndef findMatchingGems(board): \nfor x in range(BOARDWIDTH): \nfor y in range(BOARDHEIGHT): \n== getGemAt(boardCopy, x + 2, y) and getGemAt(boardCopy, x, y) != EMPTY_SPACE: \ntargetGem = boardCopy[x][y] \nwhile getGemAt(boardCopy, x + offset, y) == targetGem: \nremoveSet.append((x + offset, y)) \nboardCopy[x + offset][y] = EMPTY_SPACE \n== getGemAt(boardCopy, x, y + 2) and getGemAt(boardCopy, x, y) != EMPTY_SPACE: \ntargetGem = boardCopy[x][y] \nwhile getGemAt(boardCopy, x, y + offset) == targetGem: \nremoveSet.append((x, y + offset)) \nboardCopy[x][y + offset] = EMPTY_SPACE \ndef highlightSpace(x, y): \npygame.draw.rect(DISPLAYSURF, HIGHLIGHTCOLOR, BOARDRECTS[x][y], 4) \ndef getDroppingGems(board): \nfor x in range(BOARDWIDTH): \nfor y in range(BOARDHEIGHT - 2, -1, -1): \nif boardCopy[x][y + 1] == EMPTY_SPACE and boardCopy[x][y] != \n338    http://inventwithpython.com/pygame \ndroppingGems.append( {'imageNum': boardCopy[x][y], 'x': x, \nboardCopy[x][y] = EMPTY_SPACE \ndef animateMovingGems(board, gems, pointsText, score): \n# pointsText is a dictionary with keys 'x', 'y', and 'points' \ndrawBoard(board) \npointsRect.center = (pointText['x'], pointText['y']) \ndef moveGems(board, movingGems): \n# movingGems is a list of dicts with keys x, y, direction, imageNum \nif gem['y'] != ROWABOVEBOARD: \nboard[gem['x']][gem['y']] = EMPTY_SPACE \nboard[gem['x'] + movex][gem['y'] + movey] = gem['imageNum'] \n# gem is located above the board (where new gems come from) \nboard[gem['x']][0] = gem['imageNum'] # move to top row \ndef fillBoardAndAnimate(board, points, score): \nboard[x][0] = dropSlots[x][0] \n# See if the mouse click was on the board \nfor x in range(BOARDWIDTH): \nif BOARDRECTS[x][y].collidepoint(pos[0], pos[1]): \nreturn {'x': x, 'y': y} \nreturn None # Click was not on the board.\ndef drawBoard(board): \nfor x in range(BOARDWIDTH): \npygame.draw.rect(DISPLAYSURF, GRIDCOLOR, BOARDRECTS[x][y], 1) \ngemToDraw = board[x][y] \nDISPLAYSURF.blit(GEMIMAGES[gemToDraw], BOARDRECTS[x][y]) \n340    http://inventwithpython.com/pygame \ndef getBoardCopyMinusGems(board, gems): \n# Creates and returns a copy of the passed board data structure, \n# Gems is a list of dicts, with keys x, y, direction, imageNum \n# Remove some of the gems from this board data structure copy.\nif gem['y'] != ROWABOVEBOARD: \nboardCopy[gem['x']][gem['y']] = EMPTY_SPACE \ngames that people have written that make use of the Pygame library.\nhttp://inventwithpython.com/pygame - This book's website, which includes all the source \n342    http://inventwithpython.com/pygame \nwith the Pygame drawing or blitting functions will appear on the screen when \ninformation about the player's character, which pieces are on a board, or the score and level \n344    http://inventwithpython.com/pygame \nrepresent the X and Y coordinates of a position on a 2D surface.\nThe X \nThe Y \n346    http://inventwithpython.com/pygame ",
    "keywords": [
      "board",
      "Extra Games",
      "SPACESIZE",
      "TILE",
      "return True",
      "True",
      "BOARDWIDTH",
      "game",
      "return",
      "BOARDHEIGHT",
      "Games",
      "BLACK",
      "range",
      "return False",
      "WINDOWWIDTH"
    ],
    "concepts": [
      "board",
      "pygame",
      "def",
      "x y",
      "return",
      "returns",
      "returned",
      "displaysurf",
      "gems",
      "gem"
    ]
  }
]