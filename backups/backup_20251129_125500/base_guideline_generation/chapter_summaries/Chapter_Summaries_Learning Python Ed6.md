# Comprehensive Python Guidelines — Learning Python, 6th Edition (Chapters 1-41)

*Source: Learning Python, 6th Edition, Chapters 1-41*

---

## Chapter 1: A Python Q&A Session

*Source: Learning Python, 6th Edition, pages 16–44*

### Chapter Summary
This chapter covers a python q&a session. Key topics include modules, collection, and array. Covers statement. [^1]

### Concept-by-Concept Breakdown
#### **Argument** *(p.24)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.24, lines 29–30)*:
```
variables, files, sockets, pipes, processes, threads, regular-expression pattern
matching, command-line arguments, standard-stream interfaces, shell-command
```
[^2]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Array** *(p.17)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.17, lines 18–25)*:
```
Python comes with a large collection of prebuilt and portable functionality,
known as the standard library. This library supports an array of application-
level programming tasks, from text pattern matching to network scripting. In
addition, Python can be extended with both homegrown libraries and a vast
collection of third-party software. As covered ahead, Python’s third-party
domain offers tools for website construction, numeric programming, AI, and
much more. The NumPy extension, for instance, has elevated Python to a
core tool in science, technology, engineering, and math (STEM), and Django
```
[^3]
**Annotation:** This excerpt demonstrates 'array' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.33)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.33, lines 2–9)*:
```
extensions one piece at a time for execution speed if and when needed.
It’s Relatively Easy to Use
Compared to alternatives like C++, Java, and C#, Python programming seems
astonishingly simple to most observers. To run Python code in most contexts,
you simply type it and run it. There are no intermediate compile and link steps,
like those typical for languages such as C or C++. Python executes programs
immediately, which makes for an interactive programming experience and rapid
turnaround after program changes—in many cases, you can witness the effect of
```
[^4]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 19 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Bytecode** *(p.40)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.40, lines 1–8)*:
```
compiled to something called “bytecode” and then routed to something called a
“virtual machine.” This holds true only for the most common version of Python,
and you’ll meet variations on this model in a moment. Since the most common
is, well, most common, let’s see how this works first.
Bytecode compilation
Internally, and almost completely hidden from you, when you execute a program
Python first compiles your source code (the statements in your text file) into a
format known as bytecode. Compilation is simply a translation step, and
```
[^5]
**Annotation:** This excerpt demonstrates 'bytecode' as it appears in the primary text. The concept occurs 16 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.29)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.29, lines 2–9)*:
```
Python is an object-oriented language, from the ground up. As you’ll find in this
book, its class model supports advanced notions such as polymorphism, operator
overloading, and multiple inheritance; yet, in the context of Python’s simple
syntax and typing, OOP is remarkably easy to apply. In fact, if you don’t
understand these terms, you’ll find they are much easier to learn with Python
than with just about any other OOP language available.
Of equal significance, OOP is an option in Python; you can go far without
having to become an object guru all at once. Much like C++, Python supports
```
[^6]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.18)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.18, lines 17–24)*:
```
Of these factors, the first two—quality and productivity—are probably the most
compelling benefits to most Python users; let’s take a closer look at each.
Software Quality
By design, Python has a deliberately simple and readable syntax and a highly
consistent programming model. As a slogan at an early Python conference
attested, the net result is that Python seems to fit your brain—that is, features of
the language interact in consistent and limited ways and follow naturally from a
small set of core concepts. This makes the language easier to learn, understand,
```
[^7]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Closure** *(p.29)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.29, lines 16–23)*:
```
programming—a set that by most measures includes generators,
comprehensions, closures, maps, decorators, anonymous-function lambdas, and
first-class function objects. As you’ll also learn in this book, these can serve as
both complement and alternative to its OOP tools.
It’s Free and Open
Python is completely free to use and distribute. As with other open source
software, such as Linux and Apache, you can fetch the entire Python system’s
source code for free on the internet. There are no restrictions on copying it,
```
[^8]
**Annotation:** This excerpt demonstrates 'closure' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Collections** *(p.32)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.32, lines 2–9)*:
```
To process all those object types, Python comes with powerful and standard
operations, including concatenation (joining collections), slicing (extracting
sections), sorting, mapping, and more.
Library utilities
For more specific tasks, Python also comes with a large collection of
precoded library tools that support everything from regular expression
pattern matching to network servers. Once you learn the language itself,
Python’s library tools are where much of the application-level action occurs.
```
[^9]
**Annotation:** This excerpt demonstrates 'collections' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Compiled** *(p.22)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.22, lines 3–10)*:
```
more than three-decade tenure may also be an inevitable trade-off for its ease of
use: Python’s execution speed may not always be as fast as that of fully compiled
and lower-level languages such as C and C++. Though relatively rare today, you
may still occasionally need to get “closer to the iron” for some tasks by using
languages that are more directly mapped to the underlying hardware.
We’ll talk about implementation concepts in Chapter 2, but in short, the most-
used versions of Python today compile (i.e., translate) source code statements to
an intermediate format known as bytecode and then interpret the bytecode.
```
[^10]
**Annotation:** This excerpt demonstrates 'compiled' as it appears in the primary text. The concept occurs 7 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Comprehension** *(p.29)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.29, lines 16–23)*:
```
programming—a set that by most measures includes generators,
comprehensions, closures, maps, decorators, anonymous-function lambdas, and
first-class function objects. As you’ll also learn in this book, these can serve as
both complement and alternative to its OOP tools.
It’s Free and Open
Python is completely free to use and distribute. As with other open source
software, such as Linux and Apache, you can fetch the entire Python system’s
source code for free on the internet. There are no restrictions on copying it,
```
[^11]
**Annotation:** This excerpt demonstrates 'comprehension' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Coroutine** *(p.24)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.24, lines 24–30)*:
```
programs can search files and directory trees, launch and configure other
programs, do parallel processing with processes, threads, and coroutines, and
more.
Python’s standard library comes with Portable Operating System Interface
(POSIX) bindings and support for all the usual OS tools, including environment
variables, files, sockets, pipes, processes, threads, regular-expression pattern
matching, command-line arguments, standard-stream interfaces, shell-command
```
[^12]
**Annotation:** This excerpt demonstrates 'coroutine' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Csv** *(p.25)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.25, lines 1–8)*:
```
launchers, filename expansion, ZIP file utilities, and XML, JSON, and CSV
parsers. In addition, the bulk of Python’s system interfaces are designed to be
portable; for example, a script that copies directory trees typically runs
unchanged on all platforms that host Python.
GUIs and UIs
Python’s simplicity and rapid turnaround also make it a good match for GUI
programming on devices of all kinds. For instance, Python comes with a
standard object-oriented interface to the Tk GUI toolkit called Tkinter (and
```
[^13]
**Annotation:** This excerpt demonstrates 'csv' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Decorator** *(p.29)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.29, lines 16–23)*:
```
programming—a set that by most measures includes generators,
comprehensions, closures, maps, decorators, anonymous-function lambdas, and
first-class function objects. As you’ll also learn in this book, these can serve as
both complement and alternative to its OOP tools.
It’s Free and Open
Python is completely free to use and distribute. As with other open source
software, such as Linux and Apache, you can fetch the entire Python system’s
source code for free on the internet. There are no restrictions on copying it,
```
[^14]
**Annotation:** This excerpt demonstrates 'decorator' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Def** *(p.16)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.16, lines 6–13)*:
```
introduce some of the main reasons behind Python’s popularity and begin
sculpting a definition of the language. This takes the form of a question-and-
answer session, which addresses some of the most common queries posed by
beginners—like you.
Why Do People Use Python?
Because there are many programming languages to choose from, this is the usual
first question of newcomers and a great place to start. Given that millions of
people use Python today, there really is no way to answer this question with
```
[^15]
**Annotation:** This excerpt demonstrates 'def' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Development Speed** *(p.33)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.33, lines 1–8)*:
```
may be coded in Python first for development speed and later moved to
extensions one piece at a time for execution speed if and when needed.
It’s Relatively Easy to Use
Compared to alternatives like C++, Java, and C#, Python programming seems
astonishingly simple to most observers. To run Python code in most contexts,
you simply type it and run it. There are no intermediate compile and link steps,
like those typical for languages such as C or C++. Python executes programs
immediately, which makes for an interactive programming experience and rapid
```
[^16]
**Annotation:** This excerpt demonstrates 'development speed' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 2: How Python Runs Programs** *(pp.45–76)*

This later chapter builds upon the concepts introduced here, particularly: argument, array, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^17]

**Annotation:** Forward reference: Chapter 2 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts argument, array appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 3: How You Run Programs** *(pp.77–108)*

This later chapter builds upon the concepts introduced here, particularly: argument, array, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^18]

**Annotation:** Forward reference: Chapter 3 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts argument, array appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 4: Introducing Python Object Types** *(pp.109–140)*

This later chapter builds upon the concepts introduced here, particularly: argument, array, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^19]

**Annotation:** Forward reference: Chapter 4 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts argument, array appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 2: How Python Runs Programs

*Source: Learning Python, 6th Edition, pages 45–76*

### Chapter Summary
This chapter covers how python runs programs. Key topics include modules, package, and decorators. Covers module. [^20]

### Concept-by-Concept Breakdown
#### **None** *(p.60)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.60, lines 16–23)*:
```
mainstream model that this chapter often employs. Depending on your tools and
goals, you might see a different prompt or none at all, and you might type
interactive Python code into a web browser, GUI, or app instead of the system
console.
In general, though, this book recommends the traditional and simpler options it
demos and covers, when you’re first starting out. IPython and Jupyter, for
example, have learning curves of their own, and Jupyter is geared toward
scientific work, which is just one of many Python roles. If and when you opt to
```
[^21]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.56)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.56, lines 7–14)*:
```
neutral way to start an interactive interpreter session is to simply type a Python
command at your device’s console prompt, without any arguments. Since this is
most common, nearly universal, and arguably simplest, let’s start here.
Despite this scheme’s generality, both the Python command you’ll type and
where you’ll type it vary per platform. On Windows, macOS, and Android, for
example, py, python3, and python, respectively, do the job as follows:
$ py
Python 3.12.3 (…etc…, Apr  9 2024, 14:05:25) [MSC v.1938 64 bit (AMD64)] on win32
```
[^22]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Array** *(p.47)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.47, lines 20–26)*:
```
Python code can be sped up by Numba, it works well for code that uses
NumPy arrays and functions, as well as math-oriented loops. Numba also
supports code parallelization paradigms commonly used in scientific
programming.
Shed Skin: an AOT compiler for conforming code
Shed Skin is an ahead-of-time (AOT) compiler that translates unadorned
Python code to C++ code, which is then compiled to machine code before it
```
[^23]
**Annotation:** This excerpt demonstrates 'array' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.75)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.75, lines 1–8)*:
```
details vary per app, see Appendix A for mobile platform tips, as well as your
app’s docs for more info.
WebAssembly for Browsers
Although an emerging technology, it’s also possible to run Python code in web
browsers. This is enabled today by WebAssembly (a.k.a. Wasm), which defines a
portable bytecode format that is run by web browsers, much as the Python PVM
runs its own bytecode (see Chapter 2). By compiling the Python interpreter’s
source code to this format with tools like the Emscripten LLVM-based compiler,
```
[^24]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 22 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Async** *(p.46)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.46, lines 24–25)*:
```
stack architectures. Stackless also provides efficient multiprocessing options
that some find more straightforward than CPython’s later async coroutines,
```
[^25]
**Annotation:** This excerpt demonstrates 'async' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.48)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.48, lines 17–24)*:
```
Python code with the ability to call C functions and use C type declarations
for variables, parameters, and class attributes. Cython code can be AOT-
compiled to C code that uses the Python/C API, which may then be compiled
completely to machine code. Though not compatible with standard Python,
Cython can be useful both for wrapping external C libraries and for
implementing performance-critical parts of a system as efficient C extensions
for use in CPython programs.
MicroPython: a Python subset for constraints
```
[^26]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.51)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.51, lines 2–9)*:
```
systems. Moreover, adding type-constraint declarations to support static
compilation would break much of the flexibility, conciseness, simplicity, and
spirit of Python coding we’re about to explore. Python’s type hinting, also
covered later, comes close, but is thankfully still unused by Python itself today.
NOTE
JIT futurism: While CPython currently follows the bytecode/PVM model in Figure 2-1, it may
augment it in the future. Version 3.13, still under development as this is being written, will add
an experimental JIT compiler. As in PyPy and others, this will translate some bytecode all the
```
[^27]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Breakpoint** *(p.74)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.74, lines 3–10)*:
```
includes an object browser and GUI debugger. To use IDLE’s debugger, enable
it in the Debug menu, set breakpoints by right-clicks in edit windows, and run.
For simpler debugging needs, right-click on the text of any error message in the
Shell window to jump to the line of code where the error occurred.
For more IDLE tips, see this book’s Appendix A, IDLE’s own Help menu, and
the notes for your platform in “Python Setup and Usage” in Python’s standard
manuals. Like most GUIs, the best way to learn IDLE may be to test-drive it for
yourself. At the end of the day, its usability may be essential for some beginners,
```
[^28]
**Annotation:** This excerpt demonstrates 'breakpoint' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Bytecode** *(p.50)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.50, lines 1–8)*:
```
shipping your source code files.
Standalone executables bundle together the bytecode of your program files,
along with the PVM (interpreter) and any Python support files and libraries your
program needs, into a single package. There are some variations on this theme,
but the end result can be a single executable (e.g., a .exe file on Windows) or app
(e.g., a .app on macOS, and .apk or .aab on Android) that can easily be shipped
to customers. In Figure 2-1, it is as though the two rightmost bubbles—bytecode
and PVM—are merged into a single component: a standalone executable bundle.
```
[^29]
**Annotation:** This excerpt demonstrates 'bytecode' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.65)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.65, lines 9–16)*:
```
More generally, the interactive prompt is a place to test program components,
regardless of their source—you can import and test functions and classes in your
Python files, type calls to linked-in C functions, exercise Java classes under
Jython, and more. Partly because of its interactive nature, Python supports an
experimental and exploratory programming style you’ll find convenient.
Although Python programmers also test with in-file code (and you’ll learn ways
to make this simple later in the book), for many, the interactive prompt is still
their first line of testing defense.
```
[^30]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.71)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.71, lines 1–8)*:
```
world is too rich in options for exhaustive coverage here, let’s take a quick tour
of the most prominent command-line alternatives to close out this chapter.
Clicking and Tapping File Icons
On most PC platforms, Python program files can be run by simply clicking or
tapping their filename or icon in the local file explorer. For example, this works
automatically on Windows in File Explorer, thanks to filename associations set
up during Python’s install. Clicks also run code files on macOS in Finder, if
made to Open With the Python Launcher included in the macOS install; drags to
```
[^31]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Compiled** *(p.48)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.48, lines 1–8)*:
```
is run. With an AOT, the two rightmost bubbles in Figure 2-1 are replaced
with precompiled machine code. Shed Skin can yield both standalone
programs and extension modules for use in other programs. In exchange, it
implements a restricted subset of Python that requires Python variables to
meet an implicit statically typed constraint and does not support some
Python features or libraries today. Nevertheless, Shed Skin may outperform
both CPython and JIT-based options for some conforming code.
PyThran: an AOT compiler for numeric speed
```
[^32]
**Annotation:** This excerpt demonstrates 'compiled' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Continue** *(p.64)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.64, lines 24–31)*:
```
get a meaningful error message pointing out the mistake and the line of code that
made it, and you can continue on in your session or script. In fact, once you get
comfortable with Python, its error messages may often provide as much
debugging support as you’ll need (watch for more about debugging options in
the sidebar “Debugging Python Code”).
Testing
Besides serving as a tool for experimenting while you’re learning the language,
the interactive interpreter is also an ideal place to test code you’ve written in
```
[^33]
**Annotation:** This excerpt demonstrates 'continue' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Coroutine** *(p.46)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.46, lines 24–25)*:
```
stack architectures. Stackless also provides efficient multiprocessing options
that some find more straightforward than CPython’s later async coroutines,
```
[^34]
**Annotation:** This excerpt demonstrates 'coroutine' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Debugging** *(p.64)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.64, lines 26–32)*:
```
comfortable with Python, its error messages may often provide as much
debugging support as you’ll need (watch for more about debugging options in
the sidebar “Debugging Python Code”).
Testing
Besides serving as a tool for experimenting while you’re learning the language,
the interactive interpreter is also an ideal place to test code you’ve written in
files. You can import your module files interactively and run tests on the tools
```
[^35]
**Annotation:** This excerpt demonstrates 'debugging' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 3: How You Run Programs** *(pp.77–108)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, array.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^36]

**Annotation:** Forward reference: Chapter 3 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 4: Introducing Python Object Types** *(pp.109–140)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, array.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^37]

**Annotation:** Forward reference: Chapter 4 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 5: Numeric Types** *(pp.141–175)*

This later chapter builds upon the concepts introduced here, particularly: argument, array, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^38]

**Annotation:** Forward reference: Chapter 5 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts argument, array appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 3: How You Run Programs

*Source: Learning Python, 6th Edition, pages 77–108*

### Chapter Summary
While we can’t go into full detail in this chapter, this section briefly
surveys the launchers in this department Key topics include modules, sequence, and namespace. Covers module. [^39]

### Concept-by-Concept Breakdown
#### **None** *(p.91)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.91, lines 23–30)*:
```
DEBUGGING PYTHON CODE
Naturally, none of this book’s readers ever have bugs in their code (insert
smiley here), but for less fortunate friends of yours who may, here’s a quick
review of the strategies commonly used by real-world Python programmers
to debug errors in their code. The first two may be all you’ll need early in the
learning process, but others may grow important when you start writing
larger scripts, and all are useful to review now before you start coding in
earnest in the next chapter—and making the mistakes that are inevitable in
```
[^40]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Pythonpath** *(p.78)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.78, lines 2–9)*:
```
Later in this book, you’ll learn that imports in a REPL search for a module in the current
directory, plus those listed on environment variable PYTHONPATH or specified otherwise. The
current directory part of this will suffice for most imports you’re likely to try until then—as
long as all your code files reside there.
Reloading modules
Imports work to run a file, but only once per session (really, process—a program
run) by default. After the first import, later imports do nothing, even if you
change and save the module’s source file again in another window:
```
[^41]
**Annotation:** This excerpt demonstrates 'PYTHONPATH' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.93)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.93, lines 12–19)*:
```
own help command for more usage tips.
Use Python’s –i command-line argument. Short of adding prints
or running debuggers, you can still see what went wrong on errors.
If you run your script from a command line and pass a -i argument
between Python and the name of your script (e.g., python3 –i
script.py), Python will automatically open its interactive mode
(the >>> prompt) when your script exits, whether it ends
successfully or runs into an error. You can then print the final values
```
[^42]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Array** *(p.106)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.106, lines 14–21)*:
```
into a list of individual characters and join it back together with nothing
between, or use the special-purpose bytearray object:
>>> S = 'Python'
>>> L = list(S)                             # Expand to a list: […]
>>> L
['P', 'y', 't', 'h', 'o', 'n']
>>> L[0] = 'C'                              # Change it in place
>>> ''.join(L)                              # Join with empty delimiter
```
[^43]
**Annotation:** This excerpt demonstrates 'array' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.82)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.82, lines 1–8)*:
```
and runs whatever Python source code statements are in the string you pass to it.
Along with its eval expression cousin, this supports many dynamic roles you’ll
meet in upcoming chapters.
By passing a code file’s loaded contents to exec, though, this yields another way
to launch code files from a REPL or other file without having to import and later
reload. Each such exec runs the current version of the code read from a file,
without requiring imports or reloads. For instance, using Example 3-1’s
script1.py again:
```
[^44]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 14 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.80)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.80, lines 1–8)*:
```
assignment statement creates a variable and module attribute named title.
You can access this module’s title attribute in other components in two
different ways. First, you can load the module as a whole with an import
statement, and then qualify the module name with the attribute name to fetch it
(note that we’re letting the interpreter print automatically here):
$ python3                          # Start Python REPL
>>> import myfile                  # Run file, load module as a whole
>>> myfile.title                   # Use its attribute names: '.' to qualify
```
[^45]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 9 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Boolean** *(p.98)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.98, lines 34–35)*:
```
Other core objects
Booleans, types, None
```
[^46]
**Annotation:** This excerpt demonstrates 'boolean' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.93)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.93, lines 4–11)*:
```
module in Python’s standard library. With pdb, you type commands
to step line by line, display variables, set and clear breakpoints,
continue to a breakpoint or error, and so on. You can launch pdb by
either importing it and calling pdb.run('code') or running it as a
top-level script with the command python3 -m pdb file.py. You
can also import and call pdb’s postmortem pdb.pm() after an error
occurs to get more information about what went wrong. We’ll
revisit pdb in Chapter 36, but see Python’s library manual and pdb’s
```
[^47]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Breakpoint** *(p.93)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.93, lines 4–11)*:
```
module in Python’s standard library. With pdb, you type commands
to step line by line, display variables, set and clear breakpoints,
continue to a breakpoint or error, and so on. You can launch pdb by
either importing it and calling pdb.run('code') or running it as a
top-level script with the command python3 -m pdb file.py. You
can also import and call pdb’s postmortem pdb.pm() after an error
occurs to get more information about what went wrong. We’ll
revisit pdb in Chapter 36, but see Python’s library manual and pdb’s
```
[^48]
**Annotation:** This excerpt demonstrates 'breakpoint' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Bytecode** *(p.78)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.78, lines 13–20)*:
```
once per file in a given program run. As you’ll learn in Chapter 22, imports must
find files, compile them to bytecode, and run the code line by line, and importers
usually care only that the module’s lines have defined its exports.
If you really want to force Python to run the file again in the same session
without stopping and restarting the REPL, you need to instead call the reload
function available in the importlib standard-library module (and previously in
the now-defunct imp module, and a built-in function before that: that’s three
incarnations, for anyone counting!):
```
[^49]
**Annotation:** This excerpt demonstrates 'bytecode' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.99)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.99, lines 1–8)*:
```
Program-unit objects
Functions, modules, classes (Parts IV, V, and VI)
Implementation objects
Compiled code, stack tracebacks (Parts IV and VII)
Also shown in Table 4-1, program units such as functions, modules, and classes
—which you’ll meet in later parts of this book—are objects in Python too; they
are created with statements and expressions such as def, class, import, and
lambda and may be passed around scripts freely, stored within other objects, and
```
[^50]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.87)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.87, lines 28–33)*:
```
exit so the output window stays open, but error messages generated by
your script also appear in an output window that closes before you can
examine its contents—and before an input() pause is reached. Hence,
system command lines and IDEs such as IDLE are better for most
development.
5. Python imports (i.e., loads) a module only once per process, by default,
```
[^51]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Collections** *(p.98)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.98, lines 10–17)*:
```
dictionaries alone are powerful data representation tools that obviate most of the
work you do to support collections and searching in lower-level languages. In
short, lists provide ordered collections of other objects, while dictionaries store
objects by key, and both come with automatic memory management, support
arbitrarily nesting, can grow and shrink on demand, and may contain objects of
any kind.
Table 4-1. Python built-in (core) objects
Object type
```
[^52]
**Annotation:** This excerpt demonstrates 'collections' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Compiled** *(p.99)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.99, lines 3–10)*:
```
Implementation objects
Compiled code, stack tracebacks (Parts IV and VII)
Also shown in Table 4-1, program units such as functions, modules, and classes
—which you’ll meet in later parts of this book—are objects in Python too; they
are created with statements and expressions such as def, class, import, and
lambda and may be passed around scripts freely, stored within other objects, and
so on. Python also provides a set of implementation-related objects such as
compiled-code objects, which are generally of interest to tool builders more than
```
[^53]
**Annotation:** This excerpt demonstrates 'compiled' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Comprehension** *(p.96)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.96, lines 15–22)*:
```
your thinking early on. But they are also artificial and simplistic, and prone to confuse. For
example, tools such as comprehensions are both repetition and selection; these terms have
other, more specific meanings in Python; and many later concepts won’t seem to fit this mold
at all. In Python, the more strongly unifying principle is objects and what we can do with them.
To see why, read on.
Why Use Built-in Objects?
If you’ve used lower-level programming languages, you know that much of your
work centers on implementing objects—also known as data structures—to
```
[^54]
**Annotation:** This excerpt demonstrates 'comprehension' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 4: Introducing Python Object Types** *(pp.109–140)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, array.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^55]

**Annotation:** Forward reference: Chapter 4 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 5: Numeric Types** *(pp.141–175)*

This later chapter builds upon the concepts introduced here, particularly: argument, array, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^56]

**Annotation:** Forward reference: Chapter 5 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts argument, array appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 6: The Dynamic Typing Interlude** *(pp.176–210)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^57]

**Annotation:** Forward reference: Chapter 6 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 4: Introducing Python Object Types

*Source: Learning Python, 6th Edition, pages 109–140*

### Chapter Summary
This chapter covers introducing python object types. Key topics include sequence, unicode, and collections. [^58]

### Concept-by-Concept Breakdown
#### **None** *(p.134)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.134, lines 1–8)*:
```
are essentially just the integers 1 and 0 with custom display logic; as well as a
special placeholder object called None, commonly used to initialize names and
objects and designate an absence of a result in functions:
>>> 1 > 2, 1 < 2                    # Booleans
(False, True)
>>> bool('hack')                    # All objects have a Boolean value
True                                # Nonempty means True
>>> X = None                        # None placeholder
```
[^59]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 29 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Utf-8** *(p.132)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.132, lines 1–8)*:
```
>>> tf = open('unidata.txt', 'w', encoding='utf-8')
>>> tf.write('
h\u00c4ck
')                              # Encodes to UTF-8
6
>>> tf.close()
If you read with the same encoding (or one that’s compatible), you get back the
same text-character code points that you wrote. The encoded bytes on the file are
```
[^60]
**Annotation:** This excerpt demonstrates 'UTF-8' as it appears in the primary text. The concept occurs 7 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Eq__** *(p.109)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.109, lines 20–27)*:
```
['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__',
'__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', 
…etc…
'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines',
'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']
Run this live for the full list; its middle was cut at …etc… for space here (strings
have 81 attributes today!). The names without underscores in the second half of
this list are all the callable methods on string objects. The names with double
```
[^61]
**Annotation:** This excerpt demonstrates '__eq__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Annotation** *(p.135)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.135, lines 19–26)*:
```
That being said, Python has slowly accumulated a type-declaration facility
known as type hinting, based originally on its earlier function annotations and
inspired by the TypeScript dialect of JavaScript. With these syntax and module
extensions, it is possible to name expected object types of function arguments
and results, attributes in class-based objects, and even simple variables in Python
code, and these hints may be used by external type checkers like mypy:
>>> x: int = 1           # Optional hint: x might be an integer
>>> x = 'anything'       # But it doesn't have to be!
```
[^62]
**Annotation:** This excerpt demonstrates 'annotation' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.109)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.109, lines 14–21)*:
```
always call the built-in dir function. This function lists variables assigned in the
caller’s scope when called with no argument; more usefully, it returns a list of all
the attributes available for any object passed to it. Because methods are callable
attributes, they will show up in this list. Assuming S is still the string 'Code',
here are its attributes:
>>> dir(S)
['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__',
'__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', 
```
[^63]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Array** *(p.112)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.112, lines 4–11)*:
```
is just a simple kind of Unicode); and its bytes string, together with its
bytearray mutable cousin used earlier, handles raw byte values (including
media and encoded text):
>>> 'hÄck'                   # Normal str strings are Unicode text
'hÄck'
>>> b'a\x01c'                # bytes strings are byte-based data
b'a\x01c'
Formally, Python’s byte strings are sequences of 8-bit bytes that print with
```
[^64]
**Annotation:** This excerpt demonstrates 'array' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.136)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.136, lines 1–8)*:
```
learners and users alike. Especially for beginners, this is an optional and
peripheral topic that’s best deferred until you master the flexibility of Python’s
dynamic typing. We’ll study it only briefly in this book, in Chapter 6.
To be sure, type hinting does not mean that Python is no longer dynamically
typed. Indeed, a statically typed Python that requires type declarations would not
be a Python at all! Some programmers accustomed to restrictive languages may
regrettably code Python type hints anyhow as a hard-to-break habit (or
misguided display of prowess), but good programmers focus instead on Python’s
```
[^65]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 17 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.109)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.109, lines 15–22)*:
```
caller’s scope when called with no argument; more usefully, it returns a list of all
the attributes available for any object passed to it. Because methods are callable
attributes, they will show up in this list. Assuming S is still the string 'Code',
here are its attributes:
>>> dir(S)
['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__',
'__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', 
…etc…
```
[^66]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Await** *(p.116)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.116, lines 8–15)*:
```
make a new list). Unlike indexing, slicing scales offsets to be in bounds, but this
will have to await coverage in the in-depth chapters ahead.
Nesting
One nice feature of Python’s core object types is that they support arbitrary
nesting—we can nest them in any combination, and as deeply as we like. For
example, we can have a list that contains a dictionary, which contains another
list, and so on—as deeply and mixed as needed to describe things in our real
world.
```
[^67]
**Annotation:** This excerpt demonstrates 'await' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Boolean** *(p.133)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.133, lines 28–30)*:
```
the immutable items within them by definition cannot.
Booleans and None
Python also comes with Booleans, with predefined True and False objects that
```
[^68]
**Annotation:** This excerpt demonstrates 'boolean' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.111)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.111, lines 16–23)*:
```
all the lines are concatenated together, and newline characters (\n) are added
where line breaks appear. This is useful for embedding things like multiline
HTML, YAML, or JSON code in a Python script, as well as stubbing out lines of
code temporarily—just add three quotes above and below:
>>> msg = """
... aaaaaaaaaaaa
... bbb'''bbb""bbb
... cccccccc
```
[^69]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.137)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.137, lines 1–8)*:
```
This is called object-oriented, because there is always an implied subject in
functions within a class. Class-based objects ultimately use built-in objects
internally, and we can always describe things like workers with Python’s built-in
objects instead, as we did with dictionaries and lists earlier. Classes, though,
implement operations with meaningful names, add structure to your code, and
come with inheritance mechanisms that lend themselves to customization by
extension. In OOP, we strive to extend software by writing new classes, not by
changing what already works.
```
[^70]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 8 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.111)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.111, lines 10–17)*:
```
'A\x00B\x00C'
As hinted earlier, Python allows strings to be enclosed in single or double quote
characters—they mean the same thing but allow the other type of quote to be
embedded without an escape (most programmers prefer single quotes for less
clutter, unless they’re pining for other-language pasts). You can also code
multiline string literals enclosed in triple quotes (single or double)—when used,
all the lines are concatenated together, and newline characters (\n) are added
where line breaks appear. This is useful for embedding things like multiline
```
[^71]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Closure** *(p.137)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.137, lines 9–16)*:
```
All of which is well beyond the bounds of this object preview, though, so we
must stop short here. For full disclosure on user-defined object types coded with
classes, you’ll have to read on. Because classes build upon other tools in Python,
they are one of the major destinations of this book’s journey.
And Everything Else
As mentioned earlier, everything you can process in a Python script is a type of
object, so our object-type tour is necessarily incomplete. However, even though
everything in Python is an “object,” not everything is considered a part of
```
[^72]
**Annotation:** This excerpt demonstrates 'closure' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Collections** *(p.114)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.114, lines 2–9)*:
```
The Python list object is the most general sequence provided by the language.
Lists are positionally ordered collections of arbitrarily typed objects, and they
have no fixed size. They are also mutable—unlike strings, lists can be modified
in place by assignment to offsets as well as a variety of list method calls.
Accordingly, they provide a very flexible tool for representing arbitrary
collections—files in a folder, employees in a company, emails in your inbox, and
so on.
Sequence Operations
```
[^73]
**Annotation:** This excerpt demonstrates 'collections' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 5: Numeric Types** *(pp.141–175)*

This later chapter builds upon the concepts introduced here, particularly: argument, array, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^74]

**Annotation:** Forward reference: Chapter 5 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts argument, array appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 6: The Dynamic Typing Interlude** *(pp.176–210)*

This later chapter builds upon the concepts introduced here, particularly: None, annotation, argument.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^75]

**Annotation:** Forward reference: Chapter 6 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, annotation appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 7: String Fundamentals** *(pp.211–265)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, array.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^76]

**Annotation:** Forward reference: Chapter 7 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 5: Numeric Types

*Source: Learning Python, 6th Edition, pages 141–175*

### Chapter Summary
Numbers and
Expressions
This chapter begins our in-depth tour of the Python language Key topics include modules, sequence, and collection. Covers expression. [^77]

### Concept-by-Concept Breakdown
#### **Args** *(p.146)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.146, lines 9–16)*:
```
Assignment expression
lambda args: expression
Anonymous function generation
x if y else z
Ternary selection (x is evaluated only if y is true)
x or y
Logical OR (y is evaluated only if x is false)
x and y
```
[^78]
**Annotation:** This excerpt demonstrates 'args' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.163)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.163, lines 26–32)*:
```
binary—all as strings. To go the other way, the built-in int function converts a
string of digits to an integer, and an optional second argument lets you specify
the numeric base—useful for numbers read from files as strings instead of coded
in scripts:
>>> 64, 0o100, 0x40, 0b1000000              # Digits=>numbers in scripts and strings
(64, 64, 64, 64)
>>> int('64'), int('100', 8), int('40', 16), int('1000000', 2)
```
[^79]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Array** *(p.171)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.171, lines 9–16)*:
```
The standard library’s statistics and random modules must be imported as
well. Both modules provide an array of tools; statistics supports operations
commonly found on calculators, and random enables tasks such as picking a
random number between 0 and 1 and selecting a random integer between two
numbers:
>>> import statistics
>>> statistics.mean([1, 2, 4, 5, 7])        # Average, median
3.8
```
[^80]
**Annotation:** This excerpt demonstrates 'array' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.143)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.143, lines 13–20)*:
```
Integer and floating-point literals
Integers are written as strings of decimal digits. As noted, they have
precision (number of digits) limited only by your device’s available memory.
You can easily compute 2 raised to the power 1,000,000, though with 300K
digits, it may take some time to print (and can’t be converted to a print string
today by default, per Chapter 4).
Floating-point numbers have a decimal point and/or an optional signed
exponent introduced by an e or E and followed by an optional sign. If you
```
[^81]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 13 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Async** *(p.147)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.147, lines 10–17)*:
```
await x
Await expression (async functions)
x[i]
x[i:j:k]
x(...)
x.attr
Indexing (sequence, mapping, others)
Slicing
```
[^82]
**Annotation:** This excerpt demonstrates 'async' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.162)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.162, lines 17–24)*:
```
(6+3j)
Complex numbers also allow us to extract their parts as attributes (via attributes
real and imag), support all the usual mathematical expressions, and may be
processed with tools in the standard cmath module (the complex analogue of the
standard math module). Because complex numbers are rare in most
programming domains, though, we’ll skip the rest of this story here. Check
Python’s language reference manual for additional details.
Hex, Octal, and Binary
```
[^83]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Await** *(p.147)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.147, lines 9–16)*:
```
Power (exponentiation)
await x
Await expression (async functions)
x[i]
x[i:j:k]
x(...)
x.attr
Indexing (sequence, mapping, others)
```
[^84]
**Annotation:** This excerpt demonstrates 'await' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Boolean** *(p.156)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.156, lines 4–11)*:
```
Normal comparisons work for numbers exactly as you’d expect—they compare
the relative magnitudes of their operands and return a Boolean result, which we
would normally test and take action on in a larger statement and program (e.g.,
see the intro to if in Chapter 4):
>>> 1 < 2                  # Less than (magnitude)
True
>>> 2.0 >= 1               # Greater than or equal: mixed-type 1 converted to 1.0
True
```
[^85]
**Annotation:** This excerpt demonstrates 'boolean' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.151)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.151, lines 2–9)*:
```
Although we’re focusing on built-in numbers right now, all Python operators
may be overloaded (i.e., implemented) by Python classes and C extension types
to work on objects you create. For instance, you’ll see later that objects coded
with classes may be added or concatenated with x+y expressions, indexed with
x[i] expressions, and so on.
Furthermore, Python itself automatically overloads some operators, such that
they perform different actions depending on the type of built-in objects being
processed. For example, the + operator performs addition when applied to
```
[^86]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.158)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.158, lines 6–13)*:
```
truncate, round, use floors, or, as of Python 3.5, import and call the math
standard-library module’s isclose, which is true if values are within a tolerance
of each other (there’s more on math and floors ahead, and more on isclose in
Python’s manuals):
>>> int(1.1 + 2.2) == int(3.3)        # OK if convert: see also floor, trunc ahead
True
>>> round(1.1 + 2.2, 1) == round(3.3, 1)
True
```
[^87]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Collections** *(p.147)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.147, lines 31–38)*:
```
if it’s used in some contexts.
Comparison operators compare all parts of collections automatically
and may be chained as a shorthand and potential optimization (e.g., X <
Y < Z produces the same result as X < Y and Y < Z).
Python defines an @ operator meant for matrix multiplication but does
not provide an implementation for it; unless you code one in a class or
use a library that does, this operator does nothing.
The parentheses used for tuples, expressions, and generators may
```
[^88]
**Annotation:** This excerpt demonstrates 'collections' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Comprehension** *(p.147)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.147, lines 23–30)*:
```
Tuple, expression, generator expression
List, list comprehension
Dictionary, set, dictionary and set comprehensions
While Table 5-2 works as a reference, some of its operators won’t make sense
until you’ve seen them in action, and some are more subtle than the table may
imply. For instance:
Parentheses are required for yield if it’s not alone on the right side of
an assignment statement, as well as the := named-assignment operator
```
[^89]
**Annotation:** This excerpt demonstrates 'comprehension' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Constructor** *(p.142)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.142, lines 22–29)*:
```
what Python’s numeric types look like when written out in a program as literals
or constructor-function calls.
Table 5-1. Numeric literals and constructors
Literal
Interpretation
1234, −24, 0, 9_999_999_999_999
Integers (unlimited size)
1.23, 1., 3.14e-10, 4E210, 4.0e+210
```
[^90]
**Annotation:** This excerpt demonstrates 'constructor' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Continue** *(p.158)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.158, lines 17–24)*:
```
We’ll revisit this later in this chapter when we meet decimals and fractions,
which can also address such limitations. First, though, let’s continue our tour of
Python’s core numeric operations, with a deeper look at division.
Division Operators
Python has two division operators introduced earlier, as well as one that’s
strongly related. Here’s the whole gang:
X / Y
Called true division, this always keeps remainders in floating-point results,
```
[^91]
**Annotation:** This excerpt demonstrates 'continue' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Decorator** *(p.148)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.148, lines 9–16)*:
```
NOTE
Meet the Python no-ops: The @ character is used by Python to introduce function decorators
(covered later in this book), but not as an expression operator—despite its being specified as
such. In the latter role, @ joins Ellipsis (...) and type hinting as tools defined but wholly
unused by Python itself. As if you didn’t have enough to learn with the real stuff!
Mixed Operators: Precedence
As in most languages, in Python, you code more complex expressions by
stringing together the operator expressions in Table 5-2. For instance, the sum of
```
[^92]
**Annotation:** This excerpt demonstrates 'decorator' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 6: The Dynamic Typing Interlude** *(pp.176–210)*

This later chapter builds upon the concepts introduced here, particularly: argument, as, attribute.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^93]

**Annotation:** Forward reference: Chapter 6 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts argument, as appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 7: String Fundamentals** *(pp.211–265)*

This later chapter builds upon the concepts introduced here, particularly: args, argument, array.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^94]

**Annotation:** Forward reference: Chapter 7 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts args, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 8: Lists and Dictionaries** *(pp.266–315)*

This later chapter builds upon the concepts introduced here, particularly: argument, array, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^95]

**Annotation:** Forward reference: Chapter 8 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts argument, array appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 6: The Dynamic Typing Interlude

*Source: Learning Python, 6th Edition, pages 176–210*

### Chapter Summary
Sets straddle the
fence between collections and math but lean far enough on the latter side to
warrant coverage in this chapter Key topics include collection, dynamic typing, and sequence. Covers variable. [^96]

### Concept-by-Concept Breakdown
#### **None** *(p.204)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.204, lines 13–20)*:
```
is a much stronger form of equality testing and is rarely applied in most
programs (except for single-instance objects like None, True, and False, as in
the prior chapter).
Really, is simply compares the pointers that implement references, and it serves
as a way to detect shared references in your code if needed. It returns False if
the names point to equivalent but different objects, as is the case when we run
two different literal expressions:
>>> L = [1, 2, 3]
```
[^97]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Annotation** *(p.207)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.207, lines 17–24)*:
```
document types of parameters and results, commandeering an earlier feature
known as function annotations. We haven’t covered these yet, but as a preview,
the following function hints that it accepts an integer and list of strings and
returns a float—extraneous info that shows up in __annotations__ dictionaries
of hosting objects:
>>> def func(a: int, b: list[str]) -> float:
        return 'anything' + a + b
Yet as for simple variables, these hints are fully unused, and anything goes when
```
[^98]
**Annotation:** This excerpt demonstrates 'annotation' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.177)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.177, lines 14–21)*:
```
method noted earlier that yields numerator and denominator; fractions have a
from_float method; and float accepts a Fraction as an argument. Because
Fraction is also a lesser-used utility, though, we’re going to stop short here too;
for more details on Fraction, experiment further on your own and consult
Python’s documentation.
Set Objects
In addition to all the numeric objects we’ve explored, Python has built-in
support for sets—an unordered collection of unique and immutable objects that
```
[^99]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.197)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.197, lines 1–8)*:
```
Second, notice that references to objects are discarded along the way. Each time
x is assigned to a new object, Python reclaims the prior object’s space. For
instance, when it is assigned the string 'Python', the object 99 is immediately
reclaimed (assuming it is not referenced anywhere else)—that is, the object’s
space is automatically thrown back into the free space pool, to be reused for a
future object.
Internally, Python accomplishes this feat by keeping a counter in every object
that keeps track of the number of references currently pointing to that object. As
```
[^100]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 18 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.197)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.197, lines 31–32)*:
```
itself (e.g., L.append(L)). The same phenomenon can occur for assignments
to attributes of objects created from user-defined classes. Though relatively
```
[^101]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Boolean** *(p.185)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.185, lines 19–26)*:
```
we have time for just one last numeric object type.
Boolean Objects
Though somewhat gray, the Python Boolean type, bool, is arguably numeric in
nature because its two values, True and False, are just customized versions of
the integers 1 and 0 that print themselves differently. Python treats 1 and 0 as
true and false like many programming languages, but its True and False makes
Boolean roles more explicit. Although that’s all some programmers may need to
know, let’s briefly reveal this type’s forgery.
```
[^102]
**Annotation:** This excerpt demonstrates 'boolean' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.208)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.208, lines 20–21)*:
```
Let’s hope that Python developers of the future learn this well before bloating or
breaking a tool used and beloved by millions.
```
[^103]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.197)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.197, lines 25–32)*:
```
reference counts think of as “garbage collection.”
Circular references are a classic issue in reference-count garbage collectors.
Because references are implemented as pointers, it’s possible for an object to
reference itself, or reference another object that does. For example, exercise
6 in “Test Your Knowledge: Part I Exercises” and its solution in Appendix B
show how to create a cycle easily by embedding a reference to a list within
itself (e.g., L.append(L)). The same phenomenon can occur for assignments
to attributes of objects created from user-defined classes. Though relatively
```
[^104]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class Method** *(p.207)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.207, lines 15–22)*:
```
('hack', 'code')
Type hints can also appear in definitions of functions (and class methods) to
document types of parameters and results, commandeering an earlier feature
known as function annotations. We haven’t covered these yet, but as a preview,
the following function hints that it accepts an integer and list of strings and
returns a float—extraneous info that shows up in __annotations__ dictionaries
of hosting objects:
>>> def func(a: int, b: list[str]) -> float:
```
[^105]
**Annotation:** This excerpt demonstrates 'class method' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.176)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.176, lines 19–26)*:
```
accurately give the zero answer expected, but both of the other types do:
>>> 0.1 + 0.1 + 0.1 - 0.3           # This should be zero (close, but not exact)
5.551115123125783e-17
>>> from fractions import Fraction
>>> Fraction(1, 10) + Fraction(1, 10) + Fraction(1, 10) - Fraction(3, 10)
Fraction(0, 1)
>>> from decimal import Decimal
>>> Decimal('0.1') + Decimal('0.1') + Decimal('0.1') - Decimal('0.3')
```
[^106]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Closure** *(p.203)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.203, lines 18–25)*:
```
Shared References and Equality
In the interest of full disclosure, it’s worth pointing out that the garbage-
collection behavior described earlier in this chapter may be more conceptual
than literal for certain types. Consider these statements:
>>> x = 99
>>> x = 'Python'          # Reclaim 99 now?
Because Python caches and reuses small integers and small strings, as mentioned
earlier, the object 99 here is probably not literally reclaimed; instead, it will
```
[^107]
**Annotation:** This excerpt demonstrates 'closure' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Collections** *(p.177)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.177, lines 22–29)*:
```
supports operations corresponding to mathematical set theory. Sets straddle the
fence between collections and math but lean far enough on the latter side to
warrant coverage in this chapter.
By definition, an item appears only once in a set, no matter how many times it is
added. Accordingly, sets have a variety of applications, especially in numeric
and database-focused work. On the other hand, because sets are collections of
other objects, they share some behavior with objects such as lists and
dictionaries previewed in Chapter 4. For example, sets are iterable, can grow and
```
[^108]
**Annotation:** This excerpt demonstrates 'collections' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Comprehension** *(p.182)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.182, lines 7–14)*:
```
{1.23, (1, 2, 3), frozenset({'a', 'p'})}
Set comprehensions
In addition to literals and calls, sets can also be made by running comprehension
expressions, previewed briefly in Chapter 4. Comprehensions also work for lists,
dictionaries, and generators, and behave largely the same in all. For sets,
comprehensions are coded in curly braces. When run, they perform a loop that
collects the result of an expression on each iteration; a loop variable gives access
to the current iteration value for use in the collection expression. The result is a
```
[^109]
**Annotation:** This excerpt demonstrates 'comprehension' as it appears in the primary text. The concept occurs 8 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Continue** *(p.188)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.188, lines 7–14)*:
```
for coding numbers in scripts.
Later in this part of the book, we’ll continue our in-depth object tour by filling in
details about the next object type—the string. In the next chapter, however, we’ll
take some time to explore the mechanics of variable assignment in more detail
than we have here. This turns out to be perhaps the most fundamental idea in
Python, so make sure you check out the next chapter before moving on. First,
though, it’s time to take the usual chapter quiz.
Test Your Knowledge: Quiz
```
[^110]
**Annotation:** This excerpt demonstrates 'continue' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Deep Copy** *(p.203)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.203, lines 10–17)*:
```
X = copy.copy(Y)          # Make top-level "shallow" copy of any object Y
X = copy.deepcopy(Y)      # Make deep copy of any object Y: copy all nested parts
We’ll explore lists and dictionaries in more depth, and revisit the concept of
shared references and copies, in Chapters 8 and 9. For now, keep in mind that
objects that can be changed in place—that is, mutable objects—are always open
to these kinds of effects in any code they pass through. In Python, this includes
lists, dictionaries, sets, and some objects defined with class statements. If this is
not desired behavior, simply copy your objects as needed.
```
[^111]
**Annotation:** This excerpt demonstrates 'deep copy' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 7: String Fundamentals** *(pp.211–265)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^112]

**Annotation:** Forward reference: Chapter 7 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 8: Lists and Dictionaries** *(pp.266–315)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^113]

**Annotation:** Forward reference: Chapter 8 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 9: Tuples, Files, and Everything Else** *(pp.316–360)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^114]

**Annotation:** Forward reference: Chapter 9 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 7: String Fundamentals

*Source: Learning Python, 6th Edition, pages 211–265*

### Chapter Summary
Here, we will revisit them
to fill in details we skipped earlier Key topics include sequences, unicode, and module. Covers method, expression. [^115]

### Concept-by-Concept Breakdown
#### **None** *(p.232)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.232, lines 12–19)*:
```
example, in the slicing expression S[::−1], the first two bounds default to
sequence length–1 and –1 (they really default to None and None, but that’s
unimportant here), and a stride of −1 indicates that the slice should go from right
to left instead of the usual left to right. In much simpler terms, the effect is to
reverse the sequence:
>>> S = 'hello'
>>> S[::−1]                            # Reversing items
'olleh'
```
[^116]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Args** *(p.241)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.241, lines 24–31)*:
```
S.replace(old, new [, count])
S.format(fmtstr, *args, **kwargs)
S.rfind(sub [, start [, end]])
S.format_map(mapping)
S.rindex(sub [, start [, end]])
S.index(sub [, start [, end]])
S.rjust(width [, fill])
S.isalnum()
```
[^117]
**Annotation:** This excerpt demonstrates 'args' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.257)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.257, lines 9–16)*:
```
explicit in intent; and avoids the value-or-tuple quirk of %: substituted values are
just arguments, whether one or many.
On the other hand, the new technique still relies on “printf” concepts like type
codes and formatting specifications. Moreover, it largely overlaps with
formatting expressions; often yields more verbose code; and in practice can be
just as complex in most roles. And if we’re all being honest, the value-or-tuple
quirk of the % expression is much more of a concern in theory than practice.
Luckily, the two are similar enough that many core concepts overlap.
```
[^118]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 6 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Array** *(p.239)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.239, lines 5–12)*:
```
NOTE
Except for bytearray: As previewed in Chapter 4 and to be covered in Chapter 37, Python has
a string type known as bytearray, which is mutable and so may be changed in place.
bytearray objects aren’t really text strings; they’re sequences of small, 8-bit integers.
However, they support most of the same operations as normal strings and print as ASCII
characters when displayed. Accordingly, they provide another option for large amounts of
simple 8-bit text that must be changed frequently. Richer Unicode text and str strings in
general, though, require techniques shown here.
```
[^119]
**Annotation:** This excerpt demonstrates 'array' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.213)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.213, lines 1–8)*:
```
anything that can be encoded as text or bytes. In the text department, this
includes symbols and words (e.g., your name), contents of text files loaded into
memory, internet addresses, Python source code, and so on. Strings can also be
used to hold the raw bytes used for media files and network transfers, and both
the encoded and decoded forms of non-ASCII Unicode text.
You may have used strings in other languages, too. Python’s strings serve the
same role as character arrays in languages such as C, but they are a somewhat
higher-level tool than arrays. Unlike in C, strings in Python come with a
```
[^120]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 19 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.239)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.239, lines 22–28)*:
```
As introduced in Chapter 4, methods are simply functions that are associated
with and act upon particular objects. Technically, they are attributes attached to
objects that happen to reference callable functions which always have an implied
subject. In finer-grained detail, functions are packages of code, and method calls
combine two operations at once—an attribute fetch and a call:
Attribute fetches
An expression of the form object.attribute means “fetch the value of
```
[^121]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Binary Mode** *(p.221)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.221, lines 26–33)*:
```
to process binary files that contain any sorts of binary byte values. When opened
in binary modes, files return raw bytes from the external file as bytes—a string
variant that supports most of the syntax and tools in this chapter (you’ll find
more on files and bytes in Chapters 4, 9, and 37).
Two limits in Table 7-2 merit callouts. First of all, octal escapes with values too
large for a byte issue warnings as of Python 3.12 and will be errors soon—
despite the fact that these escapes in text strings denote code points, not bytes:
>>> '\400'
```
[^122]
**Annotation:** This excerpt demonstrates 'binary mode' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Boolean** *(p.228)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.228, lines 5–12)*:
```
search. For substrings, in is much like the str.find() method covered later in
this chapter, but it returns a Boolean result instead of the substring’s position
(don’t be alarmed if the following’s print indents your prompt; its end=' '
changes the default newline character at the end of the display to a space):
>>> myjob = 'hacker'
>>> for c in myjob:                     # Step through items, print each + ' '      
...     print(c, end=' ')               # Suppress newlines after each item
...
```
[^123]
**Annotation:** This excerpt demonstrates 'boolean' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.222)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.222, lines 1–8)*:
```
'Ā'
This seems unlikely to break much code, but the last entry in Table 7-2 may: if
Python does not recognize the character after a \ as being a valid escape code, it
simply keeps the backslash in the resulting string—at least for the moment:
>>> x = 'C:\py\code'    
<stdin>:1: SyntaxWarning: invalid escape sequence '\p'
>>> x                         # Keeps \ literally (and displays it as \\)
'C:\\py\\code'
```
[^124]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.213)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.213, lines 14–21)*:
```
cannot be changed in place. In fact, strings are the first representative of the
larger class of objects called sequences that we will explore here. Pay attention
to the sequence operations covered in this chapter, because they will work the
same on other sequence types you’ll meet later, such as lists and tuples.
As a first step, Table 7-1 previews common string literals and operations
discussed in this chapter, by abstract example (don’t expect its code snippets to
run!). As it shows, empty strings are written as a pair of quotation marks (single
or double) with nothing in between, and there are a variety of ways to code
```
[^125]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.216)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.216, lines 6–13)*:
```
though they must match, and must be straight quotes (beware tools that
autocorrect to slanted quotes!). That is, string literals can be written enclosed in
either two single or two double straight quotes—the two forms work the same
and return the same type of object. For example, the following two strings,
coded at the usual REPL, are identical once they are read by Python:
$ python3
>>> 'python', "python"
('python', 'python')
```
[^126]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Collections** *(p.228)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.228, lines 26–33)*:
```
Indexing and Slicing
Because strings are ordered collections (a.k.a. sequences) of characters, we can
access their components by position. As introduced in Chapter 4, characters in a
string are fetched by indexing—providing the numeric offset of the desired
component in square brackets after the string. You get back the one-character
string at the specified position.
As in most C-like languages, Python offsets start at 0 and end at one less than the
length of the string (and the “start at 0” part may be a short-lived hurdle if you’re
```
[^127]
**Annotation:** This excerpt demonstrates 'collections' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Csv** *(p.247)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.247, lines 5–12)*:
```
run fast and can handle basic text-extraction chores. Comma-separated text data
is also part of the CSV file format; for a more advanced tool on this front, see
also the csv module in Python’s standard library.
Other Common String Methods
Other string methods have more focused purposes—for example, to strip off
whitespace at the end of a line of text, perform case conversions, test content,
and test for a substring at the end or front:
>>> line = "Python's strings are awesome!\n"
```
[^128]
**Annotation:** This excerpt demonstrates 'csv' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Def** *(p.254)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.254, lines 7–14)*:
```
these extra tools, a simple %s in the format string will be replaced by the
corresponding value’s default print string, regardless of its type.
Advanced formatting expression examples
Formatting target syntax is documented in full in the Python standard manuals
and other reference resources, but to demonstrate common usage, let’s explore a
few examples. The first formats integers using the default, and then in a six-
character field with left justification and zero padding:
>>> x = 1234
```
[^129]
**Annotation:** This excerpt demonstrates 'def' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Dictionary** *(p.255)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.255, lines 16–23)*:
```
for more insight.
Dictionary-based formatting expressions
As a more advanced extension, % string formatting also allows conversion targets
on the left to refer to the keys in a dictionary coded on the right and use the
corresponding values. Syntactically, this form requires () key references on the
left of %, and a single dictionary (or other mapping) on the right. Functionally, it
allows formatting to be used as a basic template tool. You’ve met dictionaries
only briefly thus far in Chapter 4, but the following demos the idea:
```
[^130]
**Annotation:** This excerpt demonstrates 'dictionary' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 8: Lists and Dictionaries** *(pp.266–315)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, array.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^131]

**Annotation:** Forward reference: Chapter 8 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 9: Tuples, Files, and Everything Else** *(pp.316–360)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, array.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^132]

**Annotation:** Forward reference: Chapter 9 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 10: Introducing Python Statements** *(pp.361–395)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^133]

**Annotation:** Forward reference: Chapter 10 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 8: Lists and Dictionaries

*Source: Learning Python, 6th Edition, pages 266–315*

### Chapter Summary
This chapter covers lists and dictionaries. Key topics include sequence, collection, and list comprehensions. Covers method. [^134]

### Concept-by-Concept Breakdown
#### **None** *(p.309)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.309, lines 5–12)*:
```
>>> D
{'c': None, 'o': None, 'd': None, 'e': None}
>>> D = {k: None for k in 'code'}
>>> D
{'c': None, 'o': None, 'd': None, 'e': None}
Like its list and set relatives, dictionary comprehensions support additional
syntax not shown here, including if clauses to filter values out of results, and
nested for loops. Unfortunately, to truly understand dictionary comprehensions,
```
[^135]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 9 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.289)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.289, lines 19–26)*:
```
but other objects work in sorts too), and by default sorts in ascending order. You
can modify sort behavior by passing in keyword arguments—a special
name=value syntax in function calls that we’ve used in earlier chapters, gives
values by name, and is often used for configuration options.
In sorts, the reverse argument allows sorts to be made in descending instead of
ascending order, and the key argument gives a one-argument function that
returns the value to be used in sorting—the string object’s standard lower case
converter in the following (though its newer casefold may handle some types
```
[^136]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Array** *(p.281)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.281, lines 16–23)*:
```
in place.
Arrays of object references
Technically, Python lists contain zero or more references to other objects.
Lists might remind you of arrays of pointers (addresses) if you have a
background in some other languages, and fetching an item from a Python list
is about as fast as indexing a C array. In fact, lists really are arrays inside the
standard CPython interpreter, not linked structures. As we learned in
Chapter 6, though, Python always follows a reference to an object whenever
```
[^137]
**Annotation:** This excerpt demonstrates 'array' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.315)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.315, lines 6–13)*:
```
use them on dictionaries.
Assigning to new indexes adds entries
Keys can be created when you write a dictionary literal (embedded in the
code of the literal itself), or when you assign values to new keys of an
existing dictionary object individually. The end result is the same.
Keys need not always be strings
Our examples so far have used strings as keys, but any other immutable
objects work just as well. For instance, you can use integers as keys, which
```
[^138]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 19 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.288)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.288, lines 32–36)*:
```
Methods were introduced in Chapter 7. In brief, they are functions (really, object
attributes that reference functions) that are associated with and act upon
particular subject objects (the objects through which they are called). Methods
provide type-specific tools; the list methods presented here, for instance, are
generally available only for lists.
```
[^139]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.276)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.276, lines 10–17)*:
```
code to make a new object containing the new value. The major core types in
Python break down as follows:
Immutables (numbers, strings, tuples, frozensets)
None of the object types in the immutable category support in-place changes,
though we can always run expressions to make new objects and assign their
results to variables as needed.
Mutables (lists, dictionaries, sets, bytearray)
Conversely, the mutable object types can always be changed in place with
```
[^140]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.276)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.276, lines 6–13)*:
```
Mutable Types Can Be Changed in Place
The string’s immutable classification is an important constraint to be aware of,
yet it tends to trip up new users. If an object type is immutable, you cannot
change its value in place; Python raises an error if you try. Instead, you must run
code to make a new object containing the new value. The major core types in
Python break down as follows:
Immutables (numbers, strings, tuples, frozensets)
None of the object types in the immutable category support in-place changes,
```
[^141]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.309)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.309, lines 13–20)*:
```
you need to also know more about iteration statements and concepts in Python,
and this book hasn’t yet disclosed enough information to tell that story well.
You’ll learn much more about all flavors of comprehensions—list, set,
dictionary, and generator—in Chapters 14 and 20, so we’ll defer further details
until later.
Key Insertion Ordering
By now, you’ve probably noticed that dictionaries remember their keys’ order—
no matter what sort of syntax we use to make them. As noted both earlier here
```
[^142]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Closure** *(p.272)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.272, lines 28–30)*:
```
more toward in-program formatting than data-based roles. For more details on
the f-string, see its full disclosure in Python’s language reference manual.
And the Winner Is…
```
[^143]
**Annotation:** This excerpt demonstrates 'closure' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Collections** *(p.297)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.297, lines 3–10)*:
```
Along with lists, dictionaries are one of the most flexible built-in object types in
Python. If you think of lists as order-based collections of objects, you can think
of dictionaries as key-based collections; the chief distinction is that in
dictionaries, items are stored and fetched by key, instead of by positional offset.
While lists can serve roles similar to arrays in other languages, dictionaries can
take the place of records, search tables, and any other sort of aggregation where
item names are more meaningful than item positions.
For example, dictionaries can replace many of the searching algorithms and data
```
[^144]
**Annotation:** This excerpt demonstrates 'collections' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Comprehension** *(p.307)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.307, lines 8–15)*:
```
is yet another that’s even more powerful, as the next section will explain.
Dictionary Comprehensions
Like the set and list comprehensions we met in previous coverage, dictionary
comprehensions run an implied loop, collecting the key/value results of
expressions on each iteration and using them to fill out a new dictionary. A loop
variable allows the comprehension to use loop iteration values along the way.
The net effect lets us create new dictionaries with small bits of code that are
simpler than the full-blown statements we’ll study later in this book.
```
[^145]
**Annotation:** This excerpt demonstrates 'comprehension' as it appears in the primary text. The concept occurs 6 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Constructor** *(p.305)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.305, lines 5–12)*:
```
over time. The following summarizes the most common alternatives; its last two
calls to the dict constructor (really, type name) have the same effect as the
literal and key-assignment forms listed above them:
{'name': 'Pat', 'age': 40}              # 1) Traditional literal expression
D = {}                                  # 2) Assign by keys dynamically
D['name'] = 'Pat'
D['age']  = 40
dict(name='Pat', age=40)                # 3) dict keyword-argument form
```
[^146]
**Annotation:** This excerpt demonstrates 'constructor' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Continue** *(p.277)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.277, lines 9–16)*:
```
strings.
In the next chapter, we’ll continue our types tour with a look at the most general
object collections in Python—lists and dictionaries. As you’ll find, much of what
you’ve learned here will apply to those types as well. And as mentioned earlier,
in the final part of this book we’ll return to Python’s string model to flesh out the
details of Unicode text and binary data, which are of interest to some, but not all,
Python programmers, and depend on tools we haven’t yet studied in full. Before
moving on, though, here’s another chapter quiz to review the material covered
```
[^147]
**Annotation:** This excerpt demonstrates 'continue' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Debugging** *(p.270)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.270, lines 16–23)*:
```
'12_D687 and 455_3207 and 100_1011_0101_1010'
Adding an = after the expression may be useful when you’re debugging code, as
it labels data automatically (though this may be more readable for simple
variable names than larger expressions):
>>> f'{a=:e} and {b=:+012,}'                 # Labeled
'a=3.141560e+00 and b=+001,234,567'
 
>>> f'{a + 1=:e} and {b * 2=:+012,}'
```
[^148]
**Annotation:** This excerpt demonstrates 'debugging' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Def** *(p.300)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.300, lines 1–8)*:
```
D.update(D2)
D.get(key, default?)
D.pop(key, default?)
D.setdefault(key, defa
ult?)
D.popitem()
clear (remove all items),
merge by keys,
```
[^149]
**Annotation:** This excerpt demonstrates 'def' as it appears in the primary text. The concept occurs 7 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 9: Tuples, Files, and Everything Else** *(pp.316–360)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, array.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^150]

**Annotation:** Forward reference: Chapter 9 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 10: Introducing Python Statements** *(pp.361–395)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^151]

**Annotation:** Forward reference: Chapter 10 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 11: Assignments, Expressions, and Prints** *(pp.396–435)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^152]

**Annotation:** Forward reference: Chapter 11 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 9: Tuples, Files, and Everything Else

*Source: Learning Python, 6th Edition, pages 316–360*

### Chapter Summary
This chapter covers tuples, files, and everything else. Key topics include sequences, module, and collection. [^153]

### Concept-by-Concept Breakdown
#### **None** *(p.317)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.317, lines 17–24)*:
```
empty except for the two positions (2,3,4) and (7,8,9). The keys are tuples
that record the coordinates of nonempty slots. Rather than allocating a large and
mostly empty three-dimensional matrix to hold these values, we can use a simple
two-item dictionary. In this scheme, accessing an empty slot triggers a
nonexistent key exception, as these slots are not physically stored:
>>> Matrix[(2,3,6)]
KeyError: (2, 3, 6)
Avoiding missing-key errors
```
[^154]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Utf-8** *(p.342)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.342, lines 12–19)*:
```
File iterators read line by line
open('f.txt', encoding='utf-8')
Unicode text files (using str strings)
open('f.bin', 'rb')
Bytes files (using bytes strings)
codecs.open('f.txt',…)
Alternative Unicode text-file interface
Opening Files
```
[^155]
**Annotation:** This excerpt demonstrates 'UTF-8' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.343)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.343, lines 7–14)*:
```
in this book.
The second argument to open, processing mode, is typically the string 'r' to
open for text input (the default), 'w' to create and open for text output, or 'a' to
open for appending text to the end (e.g., for adding to logfiles). The processing
mode argument can specify additional options:
Adding a b to the mode string (e.g., 'wb') allows for processing binary
file content. End-of-line translations and Unicode encodings used for
text are turned off.
```
[^156]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 6 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Array** *(p.317)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.317, lines 4–11)*:
```
In a similar way, dictionary keys are also commonly leveraged to implement
sparse—mostly empty—data structures, such as multidimensional arrays where
only a few positions have values stored in them:
>>> Matrix = {}
>>> Matrix[(2, 3, 4)] = 88
>>> Matrix[(7, 8, 9)] = 99
>>> 
>>> X = 2; Y = 3; Z = 4               # A ; separates statements: see Chapter 10
```
[^157]
**Annotation:** This excerpt demonstrates 'array' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.329)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.329, lines 1–8)*:
```
{'name': 'Pat', 'age': 40.5, 'jobs': ['dev']}
In practice, dictionaries tend to be best for data with labeled components, as
well as structures that can benefit from quick, direct lookups by name,
instead of slower linear (left-to-right) searches. As we’ve seen, they also
may be better for sparse collections and collections that grow flexibly.
Python programmers also have access to the sets we studied in Chapter 5,
which are much like the keys of a valueless dictionary; they don’t map keys
to values, but can often be used like dictionaries for fast lookups when there
```
[^158]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 14 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.321)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.321, lines 11–18)*:
```
>>> K.sort()
AttributeError: 'dict_keys' object has no attribute 'sort'
>>> list(K)[0], list(K).sort()
('a', None)
Unlike lists, though, dictionary views don’t take up space for their full results,
and are not carved in stone when created—they dynamically reflect future
changes made to the dictionary after the view object has been created:
>>> D = {'a': 1, 'b': 2, 'c': 3}
```
[^159]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Binary Mode** *(p.352)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.352, lines 27–34)*:
```
utility. To store a dictionary in a file, for instance, we pickle it directly after
using binary mode to open the file:
>>> D = {'a': 1, 'b': 2}
>>> F = open('datafile.pkl', 'wb')
>>> import pickle
>>> pickle.dump(D, F)                          # Pickle almost any object to file
>>> F.close()
Then, to get the dictionary back later, we simply use pickle again to re-create it,
```
[^160]
**Annotation:** This excerpt demonstrates 'binary mode' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.340)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.340, lines 11–18)*:
```
{'name': 'Pat', 'age': 40.5, 'jobs': ['dev', 'mgr']}
As you can see, named tuples are a tuple/class/dictionary hybrid. They also
represent a classic trade-off. In exchange for their extra utility, they require extra
code to use (the two startup lines in the preceding examples that import the type
and make the class) and incur some performance costs to work this magic. Still,
they are an example of the kind of custom data types that we can build on top of
built-in types like tuples when extra utility is desired. They are also extensions,
not core types—they live in the standard library and fall into the same category
```
[^161]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.345)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.345, lines 3–10)*:
```
allows your scripts to jump around to read and write at specific locations.
close may be optional: auto-close on collection
Calling the file close method terminates your connection to the external file,
releases its system resources, and flushes its buffered output to disk if any is
still in memory. As discussed in Chapter 6, an object’s memory space is
automatically reclaimed as soon as the object is no longer referenced
anywhere in the program. When file objects are reclaimed, Python also
automatically closes them if they are still open (this also happens to open
```
[^162]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 10 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Collections** *(p.329)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.329, lines 4–11)*:
```
instead of slower linear (left-to-right) searches. As we’ve seen, they also
may be better for sparse collections and collections that grow flexibly.
Python programmers also have access to the sets we studied in Chapter 5,
which are much like the keys of a valueless dictionary; they don’t map keys
to values, but can often be used like dictionaries for fast lookups when there
is no associated value, especially in search routines:
>>> D = {}
>>> D['state1'] = True                 # A visited-state dictionary
```
[^163]
**Annotation:** This excerpt demonstrates 'collections' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Comprehension** *(p.337)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.337, lines 5–12)*:
```
[21, 22, 23, 24, 25]
List comprehensions are really sequence operations—they always build new
lists, but they may be used to iterate over any sequence objects, including tuples,
strings, and other lists. As you’ll see later in the book, they even work on some
things that are not physically stored sequences—any iterable objects will do,
including files, which are automatically read line by line. Given this, they may
be better called iteration tools.
Notice that you’d have to convert the prior example’s list result back to a tuple if
```
[^164]
**Annotation:** This excerpt demonstrates 'comprehension' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Context Manager** *(p.356)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.356, lines 11–18)*:
```
database tools in Chapter 1.
File Context Managers
You’ll also want to watch for Chapter 34’s in-depth discussion of the file’s
context manager support. Though more a feature of exception processing than
files themselves, it allows us to wrap file-processing code in a logic layer that
ensures that the file will be closed (and if needed, have its output flushed to disk)
automatically on statement exit, instead of relying on the auto-close during
garbage collection or manual close calls. As a preview:
```
[^165]
**Annotation:** This excerpt demonstrates 'context manager' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Csv** *(p.356)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.356, lines 1–8)*:
```
And the csv module parses and creates comma-separated value (CSV) data in
files and strings; it doesn’t map as directly to Python objects (and requires post-
parse conversions), but is another way to map value to and from files:
>>> import csv
>>> rdr = csv.reader(open('csvdata.txt'))
>>> for row in rdr: print(row)
...
['a', 'bbb', 'cc', 'dddd']
```
[^166]
**Annotation:** This excerpt demonstrates 'csv' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Def** *(p.360)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.360, lines 16–23)*:
```
class MySequence:
    def __getitem__(self, index):
        # Called on self[index], others
    def __add__(self, other):
        # Called on self + other
    def __iter__(self):
        # Preferred in iterations
and so on. We can also make the new object mutable or not by selectively
```
[^167]
**Annotation:** This excerpt demonstrates 'def' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Descriptor** *(p.357)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.357, lines 24–28)*:
```
default to the UI where a script is run (see “Print Operations” for details)
Descriptor files in the os module
Integer file handles that support lower-level tools such as read-only access
(see also the “x” mode modifier in open for exclusive creation)
Sockets, pipes, and FIFOs
```
[^168]
**Annotation:** This excerpt demonstrates 'descriptor' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 10: Introducing Python Statements** *(pp.361–395)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^169]

**Annotation:** Forward reference: Chapter 10 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 11: Assignments, Expressions, and Prints** *(pp.396–435)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^170]

**Annotation:** Forward reference: Chapter 11 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 12: if Tests and Syntax Rules** *(pp.436–465)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^171]

**Annotation:** Forward reference: Chapter 12 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 10: Introducing Python Statements

*Source: Learning Python, 6th Edition, pages 361–395*

### Chapter Summary
This chapter covers introducing python statements. Key topics include sequence, module, and data structure. Covers statement. [^172]

### Concept-by-Concept Breakdown
#### **None** *(p.371)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.371, lines 2–9)*:
```
therefore false—object of the same type.
The None object
As shown in the last row in Table 9-4, Python also provides a special object
called None, which is always considered to be false. None was introduced briefly
in Chapter 4; it is the only value of a special data type in Python and typically
serves as an empty placeholder (much like a NULL pointer in C).
For example, recall that for lists you cannot assign to an offset unless that offset
already exists—the list does not magically grow if you attempt an out-of-bounds
```
[^173]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 17 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.380)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.380, lines 27–28)*:
```
should become (1, 5, 6) in the process.
3. What is the default for the processing mode argument in a file open
```
[^174]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.392)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.392, lines 1–8)*:
```
assert
Debugging checks
assert X > Y, 'X too small'
with
Context managers
with open('data') as file: process(fi
le)
del
```
[^175]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 19 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Assert** *(p.392)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.392, lines 1–8)*:
```
assert
Debugging checks
assert X > Y, 'X too small'
with
Context managers
with open('data') as file: process(fi
le)
del
```
[^176]
**Annotation:** This excerpt demonstrates 'assert' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Async** *(p.391)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.391, lines 36–43)*:
```
cal x; x = 2
async
Coroutine designator
async def consumer(a, b): await produ
cer()
await
Coroutine transfer
await asyncio.sleep(1)
```
[^177]
**Annotation:** This excerpt demonstrates 'async' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Asyncio** *(p.391)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.391, lines 42–49)*:
```
Coroutine transfer
await asyncio.sleep(1)
import
Module access
import sys
from
Attribute access
from sys import stdin as f
```
[^178]
**Annotation:** This excerpt demonstrates 'asyncio' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.385)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.385, lines 12–19)*:
```
where it used to be.
The del statement deletes offsets, keys, attributes, and names. Use it on
your list to delete an item (e.g., del L[0]). What happens if you delete
an entire slice (del L[1:])? What happens when you assign a
nonsequence to a slice (L[1:2]=1)?
4. Tuple assignment: Type the following lines:
>>> X = 'code'
>>> Y = 'hack'
```
[^179]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Await** *(p.391)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.391, lines 38–45)*:
```
Coroutine designator
async def consumer(a, b): await produ
cer()
await
Coroutine transfer
await asyncio.sleep(1)
import
Module access
```
[^180]
**Annotation:** This excerpt demonstrates 'await' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Boolean** *(p.372)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.372, lines 9–16)*:
```
intent clearer.
Results of Boolean tests run interactively print as the words True and
False, instead of as 1 and 0, to make the type of result clearer.
You are not required to use only Boolean types in logical statements such as if;
all objects are still inherently true or false, and all the Boolean concepts
mentioned in this chapter still work as described if you use other types. Python
also provides a bool built-in function that can be used to extract the Boolean
value of an object. You can use this to explicitly check if an object is true—that
```
[^181]
**Annotation:** This excerpt demonstrates 'boolean' as it appears in the primary text. The concept occurs 7 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.391)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.391, lines 12–19)*:
```
if 'python' not in text: pass
break
Loop exit
while True: if exittest(): break
continue
Loop continue
while True: if skiptest(): continue
def
```
[^182]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.391)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.391, lines 49–56)*:
```
from sys import stdin as f
class
Building objects
class Subclass(Superclass): classAttr
= [] def method(self): pass
try/except/final
ly
Catching exceptions,
```
[^183]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.394)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.394, lines 25–28)*:
```
if x < y
Technically speaking, because every expression can be enclosed in parentheses,
including them will not hurt in this Python code, and they are not treated as an
error if present.
```
[^184]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Collections** *(p.368)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.368, lines 6–13)*:
```
errors. By proxy, this also applies to sorts, which use comparisons
internally: nonnumeric mixed-type collections cannot be sorted sans
conversions.
In general, comparisons of structured objects proceed as though you had written
the objects as literals and compared all their parts one at a time from left to right.
In later chapters, you’ll also see that class-based objects can change the way they
are compared. Here, the following sections provide a few more details on
Python’s built-in comparisons.
```
[^185]
**Annotation:** This excerpt demonstrates 'collections' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Compiled** *(p.373)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.373, lines 1–8)*:
```
program units (e.g., functions and modules) or interpreter internals (e.g., stack
frames and compiled code).
The main point to notice here is that everything processed in a Python program is
an object type. This is sometimes called a “first class” object model, because all
objects are on equal footing with respect to your code. For instance, you can pass
a class to a function, assign it to a variable, stuff it in a list or dictionary, and so
on.
Type Objects
```
[^186]
**Annotation:** This excerpt demonstrates 'compiled' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Constructor** *(p.373)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.373, lines 20–27)*:
```
Technically speaking, these names reference classes, and calls to these names are
really object constructor calls, not simply conversion functions, though you can
treat them as simple functions for basic usage.
In addition, the types standard-library module provides additional type names
for types that are not available as built-ins (e.g., types.FunctionType is the is
the type of functions), and the isinstance built-in function checks types with
consideration of inheritance in OOP—a topic we’ll reach later on our Python
journey. Because types can be customized with OOP in Python, though, the
```
[^187]
**Annotation:** This excerpt demonstrates 'constructor' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 11: Assignments, Expressions, and Prints** *(pp.396–435)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^188]

**Annotation:** Forward reference: Chapter 11 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 12: if Tests and Syntax Rules** *(pp.436–465)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^189]

**Annotation:** Forward reference: Chapter 12 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 13: while and for Loops** *(pp.466–500)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^190]

**Annotation:** Forward reference: Chapter 13 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 11: Assignments, Expressions, and Prints

*Source: Learning Python, 6th Edition, pages 396–435*

### Chapter Summary
This chapter covers assignments, expressions, and prints. Key topics include sequence, data structure, and mappings. Covers statement, loop. [^191]

### Concept-by-Concept Breakdown
#### **None** *(p.413)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.413, lines 2–9)*:
```
statements, semicolons at the end of each statement, and braces around
a nested block of code. Python requires none of these (but adds a :).
2. The end of a line terminates the statement that appears on that line.
Alternatively, if more than one statement appears on the same line, they
can be separated with semicolons; similarly, if a statement spans many
lines, you must terminate it by closing a bracketed syntactic pair.
3. The statements (code lines) in a nested block are all indented the same
number of tabs or spaces.
```
[^192]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Annotation** *(p.419)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.419, lines 1–8)*:
```
NOTE
Name annotations: Basic assignment statements can also have an annotation expression
introduced by a colon immediately after the target on the left. This statement form allows only
a single target, and is used for type hinting, described near the end of Chapter 6. As noted
there, because this is optional, convoluted, completely unused by Python, and fundamentally at
odds with the language’s core idiom, we’re skipping it in this book. See Python’s docs for
more details if you ever stumble in the wild onto the curious case of type declarations in a
dynamically typed language.
```
[^193]
**Annotation:** This excerpt demonstrates 'annotation' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.429)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.429, lines 21–28)*:
```
Function headers, where single *X and **X starred names collect
unmatched positional and keyword arguments in a tuple and
dictionary, respectively
Function calls, where single *X and **X starred expressions unpack
iterables and mappings into individual positional and keyword
arguments, respectively
As of Python 3.5, function calls (the latter listed item) support any number of
*X and **X unpacking expressions, and any number of *X and **X starred
```
[^194]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.415)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.415, lines 1–8)*:
```
Names must be assigned before being referenced. It’s an error to use
a name to which you haven’t yet assigned a value. Python raises an
exception if you try, rather than returning some sort of ambiguous
default value. This turns out to be crucial in Python because names are
not predeclared—if Python provided default values for unassigned
names used in your program instead of treating them as errors, it would
be much more difficult for you to spot name typos in your code.
Some operations perform assignments implicitly. In this section,
```
[^195]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 21 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.418)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.418, lines 14–21)*:
```
basics. In short, it assigns a single target to a single value, where the target may
be a name, index, slice, or attribute, and the value is any expression:
$ python3
>>> L = [1, 2]             # Name target
>>> L[0] = 3               # Index target
>>> L[-1:] = [4, 5]        # Slice target
>>> L
[3, 4, 5]
```
[^196]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.404)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.404, lines 7–14)*:
```
    reply = input('Enter text:')
    if reply == 'stop': break
    print(reply.upper())
This code makes use of a few new ideas and some we’ve already explored:
The code leverages the Python while loop, Python’s most general
looping statement. We’ll study the while statement in more detail later,
but in short, it consists of the word while, followed by an expression
that is interpreted as a true or false result, followed by a nested block of
```
[^197]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Bytecode** *(p.410)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.410, lines 33–36)*:
```
the string is a statement instead of an expression and has no result), and its compile call
precompiles frequently used code strings to bytecode objects for speed. Run a help on any of
these for more details. We’ll also use exec to import modules by name string in Chapter 25—
an example of its more dynamic roles.
```
[^198]
**Annotation:** This excerpt demonstrates 'bytecode' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.398)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.398, lines 27–33)*:
```
nested if statement (if (y)) in C, even though it looks visually as though it is
associated with the outer test (if (x)). This is a classic pitfall in the C language,
and it can lead to the reader completely misinterpreting the code and changing it
incorrectly in ways that might not be uncovered until the Mars rover crashes into
a giant rock!
This cannot happen in Python—because indentation is significant, the way the
code looks is the way it will work. Consider an equivalent Python statement:
```
[^199]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.401)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.401, lines 10–17)*:
```
single statement span across multiple lines. To make this work, you simply have
to enclose part of your statement in a bracketed pair—parentheses (()), square
brackets ([]), or curly braces ({}). Any code enclosed in these constructs can
cross multiple lines: your statement doesn’t end until Python reaches the line
containing the closing part of the pair. For instance, to continue a list literal:
mylist = [1111,           # Continuation lines
          2222,           # Any code in (), [], {} 
          3333]
```
[^200]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Collections** *(p.420)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.420, lines 18–25)*:
```
tuple or list of targets), the right side may be any iterable object, not just any
sequence. This is a more general category that includes collections both physical
(e.g., lists) and virtual (e.g., a file’s lines), which was first defined in Chapter 4
and has popped up in passing ever since. We’ll firm up this term when we
explore iterables in Chapters 14 and 20, and apply it to unpack a range iterable
in the next section. For now, the “sequence” in assignment is best associated
with what’s on the left of the =.
Advanced sequence-assignment patterns
```
[^201]
**Annotation:** This excerpt demonstrates 'collections' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Comprehension** *(p.401)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.401, lines 20–27)*:
```
surrounding dictionaries (as well as set literals and dictionary and set
comprehensions) allow them to span lines this way, too, and parentheses handle
tuples, function calls, and expressions. The indentation of the continuation lines
does not matter, though common sense dictates that the lines should be aligned
somehow for readability. Any # comments are ignored as usual in continuation
lines too, and nested brackets must all be closed before the continuation-line run
ends.
Parentheses are the catchall device—because any expression can be wrapped in
```
[^202]
**Annotation:** This excerpt demonstrates 'comprehension' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Continue** *(p.401)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.401, lines 13–20)*:
```
cross multiple lines: your statement doesn’t end until Python reaches the line
containing the closing part of the pair. For instance, to continue a list literal:
mylist = [1111,           # Continuation lines
          2222,           # Any code in (), [], {} 
          3333]
Because this code is enclosed in a square brackets pair, Python simply keeps
reading on the next line until it encounters the closing bracket. The curly braces
surrounding dictionaries (as well as set literals and dictionary and set
```
[^203]
**Annotation:** This excerpt demonstrates 'continue' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Def** *(p.415)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.415, lines 3–10)*:
```
exception if you try, rather than returning some sort of ambiguous
default value. This turns out to be crucial in Python because names are
not predeclared—if Python provided default values for unassigned
names used in your program instead of treating them as errors, it would
be much more difficult for you to spot name typos in your code.
Some operations perform assignments implicitly. In this section,
we’re concerned with the = statement and its := expression relative, but
assignment occurs in many contexts in Python. For instance, you’ll see
```
[^204]
**Annotation:** This excerpt demonstrates 'def' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Dictionary** *(p.401)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.401, lines 19–26)*:
```
reading on the next line until it encounters the closing bracket. The curly braces
surrounding dictionaries (as well as set literals and dictionary and set
comprehensions) allow them to span lines this way, too, and parentheses handle
tuples, function calls, and expressions. The indentation of the continuation lines
does not matter, though common sense dictates that the lines should be aligned
somehow for readability. Any # comments are ignored as usual in continuation
lines too, and nested brackets must all be closed before the continuation-line run
ends.
```
[^205]
**Annotation:** This excerpt demonstrates 'dictionary' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Elif** *(p.407)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.407, lines 18–25)*:
```
        break
    elif not reply.isdigit():
        print('Bad!' * 8)
    else:
        print(int(reply) ** 2)
print('Bye')
We’ll study the if statement in more detail in Chapter 12, but it’s a fairly
lightweight tool for coding logic in scripts. In its full form, it consists of the
```
[^206]
**Annotation:** This excerpt demonstrates 'elif' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 12: if Tests and Syntax Rules** *(pp.436–465)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^207]

**Annotation:** Forward reference: Chapter 12 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 13: while and for Loops** *(pp.466–500)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^208]

**Annotation:** Forward reference: Chapter 13 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 14: Iterations and Comprehensions** *(pp.501–540)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^209]

**Annotation:** Forward reference: Chapter 14 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 12: if Tests and Syntax Rules

*Source: Learning Python, 6th Edition, pages 436–465*

### Chapter Summary
We explored this expression briefly in a spoiler note in the previous chapter Key topics include module, unicode, and sequence. Covers statement, expression. [^210]

### Concept-by-Concept Breakdown
#### **None** *(p.446)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.446, lines 19–26)*:
```
statement instead:
>>> L = L.append(4)           # But append returns None, not L
>>> print(L)                  # So we lose our list!
None
But this doesn’t work: in-place change methods like append, sort, and reverse
always change the list in place, but do not return the list they have changed;
instead, they return the None object. Assigning such an operation’s result back to
the variable name loses your reference to the list (and it’s probably garbage-
```
[^211]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Name__** *(p.442)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.442, lines 25–31)*:
```
required but are followed in normal practice. For instance, because names with
two leading and trailing underscores (e.g., __name__) generally have special
meaning to the Python interpreter, you should avoid this pattern for your own
names except in contexts where it is expected. Here is a list of the conventions
Python follows:
Names that begin with a single underscore (_X) are not imported by a
from module import * statement, described in Chapter 23.
```
[^212]
**Annotation:** This excerpt demonstrates '__name__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.448)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.448, lines 12–19)*:
```
section). Because it is a normal function, though, it can use standard function-
call syntax (including keyword arguments for special operation modes) and may
be both passed around as an object and reassigned to a different implementation.
Call format
Syntactically, calls to the print function have the following form:
print([object, …][, sep=' '][, end='\n'][, file=sys.stdout][, flush=False])
In this notation, items in square brackets are optional and may be omitted in a
given call, and values after = give keyword-argument defaults. In English, this
```
[^213]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 6 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.443)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.443, lines 2–9)*:
```
system-defined names that have special meaning to the interpreter and
provide implementation details in the user-defined OOP classes of
Part VI.
Names that begin with two underscores and do not end with two more
(__X) are localized (“mangled”) to enclosing classes, per the discussion
of pseudoprivate attributes in Chapter 31.
The name that is just a single underscore (_) retains the result of the last
expression when you are working interactively at some REPLs and is a
```
[^214]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 16 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Assert** *(p.441)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.441, lines 1–8)*:
```
assert
del
global
not
with
async
elif
if
```
[^215]
**Annotation:** This excerpt demonstrates 'assert' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Async** *(p.441)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.441, lines 5–12)*:
```
with
async
elif
if
or
yield
In addition to Table 11-3 (and as partly leaked in Chapter 10), the words match,
case, _, and type are soft reserved words: they are reserved only in the context
```
[^216]
**Annotation:** This excerpt demonstrates 'async' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.460)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.460, lines 9–16)*:
```
always be assigned. Python also has ways to hide names in classes and modules, but they’re not the
same as C++’s declarations (if hiding attributes matters to you, see the coverage of _X module names
in Chapter 25, __X class names in Chapter 31, and the Private and Public class decorators example
in Chapter 39).
4  Technically, printing uses the equivalent of str in the internal implementation of Python, but the
effect is the same. Besides this to-string conversion role, str is also the name of the string data type
and can be used to decode Unicode strings from raw bytes with an extra encoding argument, as you’ll
learn in Chapter 37; this latter role is an advanced usage that you can safely ignore here.
```
[^217]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Await** *(p.445)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.445, lines 14–21)*:
```
Yielding expression statements (generators)
await producer()
Pausing for steps to finish (coroutines)
The last three entries in Table 11-4 are somewhat special cases. As you’ll see
later in this chapter, printing in Python is a function call usually coded as a
statement by itself, and important enough to callout here. The yield and await
operations on generator and coroutine functions (discussed in Chapter 20) are
regularly coded as statements as well. All three, though, are really just instances
```
[^218]
**Annotation:** This excerpt demonstrates 'await' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Binary Mode** *(p.456)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.456, lines 15–22)*:
```
4
>>> print(open('temp1', 'rb').read())                      # Binary mode for bytes
b'1 2\r\n'
>>> print(open('temp2', 'rb').read())
b'1 2\r\n'
As you can see, unless you happen to enjoy typing, print operations are often the
best option for displaying text. For another example of the equivalence between
prints and file writes, watch for a print function emulation example in
```
[^219]
**Annotation:** This excerpt demonstrates 'binary mode' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Boolean** *(p.457)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.457, lines 11–18)*:
```
the if statement, Python’s main selection tool; there, we’ll also revisit Python’s
syntax model in more depth and look at the behavior of Boolean expressions, as
well as the match multiple-choice statement. Before we move on, though, the
end-of-chapter quiz will test your knowledge of what you’ve learned here.
Test Your Knowledge: Quiz
1. Name three ways that you can assign three variables to the same value.
2. What’s dangerous about assigning three variables to a mutable object?
3. What’s wrong with saying L = L.sort()?
```
[^220]
**Annotation:** This excerpt demonstrates 'boolean' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.450)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.450, lines 12–19)*:
```
Also by default, print adds an end-of-line character to terminate the output line.
You can suppress this and avoid the line break altogether by passing an empty
string to the end keyword argument, or you can pass a different terminator of
your own including a \n character to break the line manually if desired (the
second of the following is two statements on one line, separated by a semicolon
to demo the effect of custom terminators in the REPL):
>>> print(x, y, z, end='')                        # Suppress line break (see >>>)
python 3.12 ['lp6e']>>>
```
[^221]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.443)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.443, lines 2–9)*:
```
system-defined names that have special meaning to the interpreter and
provide implementation details in the user-defined OOP classes of
Part VI.
Names that begin with two underscores and do not end with two more
(__X) are localized (“mangled”) to enclosing classes, per the discussion
of pseudoprivate attributes in Chapter 31.
The name that is just a single underscore (_) retains the result of the last
expression when you are working interactively at some REPLs and is a
```
[^222]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.454)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.454, lines 25–32)*:
```
>>> print(1, 2, 3)
>>> sys.stdout.close()                  # Flush output to disk
>>> sys.stdout = temp                   # Restore original stream
>>> print('back in the REPL')           # Prints show up here again
back in the REPL
>>> print(open('log.txt').read())       # Result of earlier prints
lp6e was here
1 2 3
```
[^223]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Comprehension** *(p.438)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.438, lines 27–30)*:
```
Besides file reads and similar roles, the := can be leveraged to reuse results in
literals and get last results in comprehensions and other iteration tools, and can
even be nested in f-strings and itself—with requisite parentheses:
>>> [val := 'Py!', val * 2, val * 3]               # Reusing a value
```
[^224]
**Annotation:** This excerpt demonstrates 'comprehension' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Continue** *(p.440)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.440, lines 35–42)*:
```
and
continue
for
lambda
try
as
def
from
```
[^225]
**Annotation:** This excerpt demonstrates 'continue' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 13: while and for Loops** *(pp.466–500)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^226]

**Annotation:** Forward reference: Chapter 13 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 14: Iterations and Comprehensions** *(pp.501–540)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^227]

**Annotation:** Forward reference: Chapter 14 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 15: The Documentation Interlude** *(pp.541–565)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^228]

**Annotation:** Forward reference: Chapter 15 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 13: while and for Loops

*Source: Learning Python, 6th Edition, pages 466–500*

### Chapter Summary
This chapter covers while and for loops. Key topics include sequences, mappings, and list comprehensions. Covers statement, loop, expression. [^229]

### Concept-by-Concept Breakdown
#### **None** *(p.489)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.489, lines 1–8)*:
```
X = A or B or C or None
assigns X to the first nonempty (that is, true) object among A, B, and C, or to
None if all of them are empty. This works because the or operator returns
one of its two objects, and it turns out to be a fairly common coding
paradigm in Python: to select a nonempty object from among a fixed-size
set, simply string them together in an or expression. In simpler form, this is
also commonly used to designate a default—the following sets X to A if A is
true (nonzero or nonempty), and to default otherwise:
```
[^230]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 6 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Init__** *(p.472)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.472, lines 10–17)*:
```
class Emp:
    def __init__(self, name): self.name = name
pat = Emp('Pat')                         # pat.name becomes 'Pat': see Part VI!
# state = 'Pat' or pat
match state:
    case pat.name as what:               # Match object's attribute, what = 'Pat'
        print('attr', what)
    case Emp(name=what):                 # Match an Emp instance, what = 'Pat'
```
[^231]
**Annotation:** This excerpt demonstrates '__init__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.479)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.479, lines 12–19)*:
```
This also works for list comprehensions enclosed in []; anything in () (tuples,
expressions, function argument and headers, and generators expressions); and
anything in {} (dictionary and set literals and comprehensions). Some of these
are tools we’ll study in later chapters, but this rule naturally covers most
constructs that span lines in practice.
If you’re accustomed to using backslashes to continue lines, you can in Python,
too, but it’s not common practice:
if a == b and c == d and   \
```
[^232]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.472)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.472, lines 2–9)*:
```
can also be capture patterns (possibly after at most one * or **), and may use |
ors, or _ wildcards. The case header [*a, 2 | 3, _], for example, is a valid
sequence pattern, but has little to do with list literals.
Attribute and instance patterns require knowledge you haven’t yet gained (a
recurring theme in Python today), but they check for attribute values and
inheritance-tree membership, and some of their components are nested patterns
again, which may be literals, captures, and more. As a preview—which you can
revisit after reading Part VI:
```
[^233]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 21 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.472)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.472, lines 4–11)*:
```
sequence pattern, but has little to do with list literals.
Attribute and instance patterns require knowledge you haven’t yet gained (a
recurring theme in Python today), but they check for attribute values and
inheritance-tree membership, and some of their components are nested patterns
again, which may be literals, captures, and more. As a preview—which you can
revisit after reading Part VI:
class Emp:
    def __init__(self, name): self.name = name
```
[^234]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Boolean** *(p.481)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.481, lines 13–20)*:
```
actually uses these tools, so we’ll rehash these ideas with additional info. All
told, Python’s Boolean operators are a bit different from their counterparts in
some other languages. In Python:
All objects have an inherent Boolean true or false value.
Any nonzero number or nonempty object is true.
Zero numbers, empty objects, and the special object None are
considered false.
Comparisons and equality tests are applied recursively to data
```
[^235]
**Annotation:** This excerpt demonstrates 'boolean' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.494)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.494, lines 1–8)*:
```
break, continue, pass, and the Loop else
Now that we’ve seen a few Python loops in action, it’s time to take a look at two
simple statements that have a purpose only when nested inside loops—the break
and continue statements. While we’re looking at oddballs, we will also study
the loop else clause here because it is intertwined with break, as well as
Python’s empty placeholder statement pass, which is not tied to loops but falls
into the category of simple one-word statements. In Python:
break
```
[^236]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 9 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.472)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.472, lines 9–16)*:
```
revisit after reading Part VI:
class Emp:
    def __init__(self, name): self.name = name
pat = Emp('Pat')                         # pat.name becomes 'Pat': see Part VI!
# state = 'Pat' or pat
match state:
    case pat.name as what:               # Match object's attribute, what = 'Pat'
        print('attr', what)
```
[^237]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.479)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.479, lines 11–18)*:
```
     'program']                  # Open pairs may span lines
This also works for list comprehensions enclosed in []; anything in () (tuples,
expressions, function argument and headers, and generators expressions); and
anything in {} (dictionary and set literals and comprehensions). Some of these
are tools we’ll study in later chapters, but this rule naturally covers most
constructs that span lines in practice.
If you’re accustomed to using backslashes to continue lines, you can in Python,
too, but it’s not common practice:
```
[^238]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Comprehension** *(p.479)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.479, lines 11–18)*:
```
     'program']                  # Open pairs may span lines
This also works for list comprehensions enclosed in []; anything in () (tuples,
expressions, function argument and headers, and generators expressions); and
anything in {} (dictionary and set literals and comprehensions). Some of these
are tools we’ll study in later chapters, but this rule naturally covers most
constructs that span lines in practice.
If you’re accustomed to using backslashes to continue lines, you can in Python,
too, but it’s not common practice:
```
[^239]
**Annotation:** This excerpt demonstrates 'comprehension' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Continue** *(p.494)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.494, lines 1–8)*:
```
break, continue, pass, and the Loop else
Now that we’ve seen a few Python loops in action, it’s time to take a look at two
simple statements that have a purpose only when nested inside loops—the break
and continue statements. While we’re looking at oddballs, we will also study
the loop else clause here because it is intertwined with break, as well as
Python’s empty placeholder statement pass, which is not tied to loops but falls
into the category of simple one-word statements. In Python:
break
```
[^240]
**Annotation:** This excerpt demonstrates 'continue' as it appears in the primary text. The concept occurs 6 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Def** *(p.466)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.466, lines 1–8)*:
```
And the try statement is a general way to handle dictionary-based defaults by
catching and handling the errors they’d otherwise trigger (for more on
exceptions, see Chapter 11’s overview and Part VII’s full treatment):
>>> choice = 'GEM'
>>> try:
...     print(branch[choice])
... except KeyError:
...     print('Bad choice')
```
[^241]
**Annotation:** This excerpt demonstrates 'def' as it appears in the primary text. The concept occurs 7 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Dictionary** *(p.466)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.466, lines 1–8)*:
```
And the try statement is a general way to handle dictionary-based defaults by
catching and handling the errors they’d otherwise trigger (for more on
exceptions, see Chapter 11’s overview and Part VII’s full treatment):
>>> choice = 'GEM'
>>> try:
...     print(branch[choice])
... except KeyError:
...     print('Bad choice')
```
[^242]
**Annotation:** This excerpt demonstrates 'dictionary' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Docstring** *(p.474)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.474, lines 18–25)*:
```
the current line.
Docstrings are ignored but are saved and displayed by tools. Python
supports an additional comment form called documentation strings
(docstrings for short), which, unlike # comments, are retained at
runtime for inspection. Docstrings are simply strings that show up at the
top of program files and some statements. Their content is ignored, but
they are attached to objects and may be displayed with tools covered
later in this book.
```
[^243]
**Annotation:** This excerpt demonstrates 'docstring' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Elif** *(p.467)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.467, lines 18–25)*:
```
statement to Python. At this level, it works very much like “switch” statements
in other languages and can be used instead of both if/elif/else combos and
dictionary indexing in some contexts. In its full-blown form, however, match
implements something known as structural pattern matching, which quickly
falls off a complexity cliff, and seems a highly convoluted answer to a question
that most Python programmers never asked. Especially for newcomers, it’s a lot
to justify.
Because of all that, this section is going to focus on the basic roles of match, and
```
[^244]
**Annotation:** This excerpt demonstrates 'elif' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 14: Iterations and Comprehensions** *(pp.501–540)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^245]

**Annotation:** Forward reference: Chapter 14 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 15: The Documentation Interlude** *(pp.541–565)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^246]

**Annotation:** Forward reference: Chapter 15 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 16: Function Basics** *(pp.566–600)*

This later chapter builds upon the concepts introduced here, particularly: None, __init__, argument.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^247]

**Annotation:** Forward reference: Chapter 16 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __init__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 14: Iterations and Comprehensions

*Source: Learning Python, 6th Edition, pages 501–540*

### Chapter Summary
Although
that’s true in this example, the else provides explicit syntax for this coding
pattern (it’s more obviously a search-failure clause here), and such an explicit
empty test may not apply in some cases Key topics include sequence, protocol, and generator. Covers loop. [^248]

### Concept-by-Concept Breakdown
#### **None** *(p.537)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.537, lines 1–8)*:
```
>>> I = iter(L)
>>> while (X := next(I, None)) != None:        # Same effect, less code
        print(X ** 2, end=' ')                 # Assuming None is safe!
Though also uncommon, iter accepts a second sentinel argument to signal stop
from a callable. This very different mode provides an arguably tricky way to use
for to read files by blocks—but requires info on functions or lambda, which we
don’t yet have:
>>> f = open('data.txt')
```
[^249]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Args** *(p.519)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.519, lines 13–20)*:
```
(7, 8, 9)
>>> list(zip(T1, T2, T3))                   # 3 args of 3 vals => 3 3-item tuples
[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
And formally speaking, for N arguments that contain M items, zip gives us an
M-long series of N-ary tuples:
>>> list(zip(T1, T2))                       # 2 args of 3 vals => 3 2-item tuples
[(1, 4), (2, 5), (3, 6)]
When argument lengths differ, zip truncates the series of result tuples at the
```
[^250]
**Annotation:** This excerpt demonstrates 'args' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.519)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.519, lines 7–14)*:
```
In addition, zip is not just for two-item pairs: it accepts any number of
arguments, of any size. The following, for example, builds a list of three-item
tuples for three arguments, with items from each sequence—essentially
projecting by columns:
>>> T1, T2, T3 = (1, 2, 3), (4, 5, 6), (7, 8, 9)
>>> T3
(7, 8, 9)
>>> list(zip(T1, T2, T3))                   # 3 args of 3 vals => 3 3-item tuples
```
[^251]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.504)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.504, lines 1–8)*:
```
Tuple (sequence) assignment in for loops
If you’re iterating through a sequence of tuples, the loop target itself can actually
be a tuple of targets. This is just another case of the tuple-unpacking assignment
we studied in Chapter 11 at work. Remember, the for loop assigns items in the
sequence object to the target, and assignment works the same everywhere:
>>> T = [(1, 2), (3, 4), (5, 6)]
>>> for (a, b) in T:                   # Tuple assignment at work
        print(a, b)
```
[^252]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 15 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.502)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.502, lines 10–17)*:
```
After the loop this variable normally still refers to the last item visited, which is
the last item in the sequence unless the loop exits early with a break statement.
The for statement also supports an optional else block, which works exactly as
it does in a while loop—it’s executed if the loop exits without running into a
break statement (i.e., if all items in the sequence have been visited). The break
and continue statements introduced earlier also work the same in a for loop as
they do in a while. Given all that, the for loop’s complete format can be
described this way:
```
[^253]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Bytecode** *(p.532)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.532, lines 1–8)*:
```
while version must run Python bytecode through the Python virtual machine.
Anytime we trade Python code for C code, speed tends to increase. This is not an
absolute truth, though; again, we’ll explore timing techniques in Chapter 21 for
measuring the relative speed of alternatives like these, though the following note
ruins some of the surprise for the impatient.
NOTE
Spoiler alert: Per calls to min(timeit.repeat(code, repeat=50, number=10)) in CPython
3.12 on macOS, the file iterator is still slightly faster than readlines, which is faster than the
```
[^254]
**Annotation:** This excerpt demonstrates 'bytecode' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.501)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.501, lines 18–25)*:
```
strings, lists, tuples, sets, dictionaries, and all other built-in iterables, as well as
new user-defined objects that you’ll learn how to create later with classes. We
met for briefly in Chapter 4 and have used it in conjunction with sequence
object types; let’s expand on its usage more formally here.
General Format
The Python for loop begins with a header line that specifies an assignment
target (or targets), along with the object you want to step through. The header is
followed by a block of (normally indented) statements that you want to repeat:
```
[^255]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.518)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.518, lines 31–32)*:
```
clincher, though, is that this is not really equivalent to zip—for reasons
disclosed in the next section.
```
[^256]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Collections** *(p.510)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.510, lines 6–13)*:
```
Python—its iteration tools automate much of the work you do to loop over
collections in lower-level languages like C.
Still, there are situations where you will need to iterate in more specialized ways.
For example, what if you need to visit every second or third item in a list, or
change the list along the way? How about traversing more than one sequence in
parallel, in the same for loop? What if you need indexes too?
You can always code such unique iterations with a while loop and manual
indexing, but Python provides a set of built-ins that allow you to specialize the
```
[^257]
**Annotation:** This excerpt demonstrates 'collections' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Comprehension** *(p.517)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.517, lines 9–16)*:
```
Here again, though, the range solution may not be ideal either. A list
comprehension expression of the form:
>>> [x + 1 for x in L]
[13, 23, 33, 43, 53]
likely runs faster today and would do similar work, albeit without changing the
original list in place (we could assign the expression’s new list object result back
to L, but this would not update any other references to the original list). Because
this is such a central looping concept, we’ll save a complete exploration of list
```
[^258]
**Annotation:** This excerpt demonstrates 'comprehension' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Constructor** *(p.520)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.520, lines 26–30)*:
```
this context, and simply pass the zipped keys/values lists to the built-in dict
constructor call:
>>> D3 = dict(zip(keys, vals))
>>> D3
{'app': 1, 'script': 3, 'program': 5}
```
[^259]
**Annotation:** This excerpt demonstrates 'constructor' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Continue** *(p.523)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.523, lines 3–10)*:
```
We looked at the while and for loop statements in depth, and we learned about
their associated else clauses. We also studied the break and continue
statements, which have meaning only inside loops, and met several built-ins
commonly used in for loops, including range, zip, and enumerate, although
some of the details regarding their roles as iterables were intentionally cut short.
In the next chapter, we continue the iteration story by discussing list
comprehensions and the iteration protocol in Python—concepts strongly related
to for loops. There, we’ll also fill in the rest of the picture behind the iterable
```
[^260]
**Annotation:** This excerpt demonstrates 'continue' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Def** *(p.536)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.536, lines 19–26)*:
```
For full fidelity, it should also be noted that for loops and other iteration tools
can sometimes work differently for user-defined classes—repeatedly indexing an
object instead of running the iteration protocol—but they prefer the iteration
protocol when supported (more on this story when we study operator
overloading in Chapter 30).
Though not commonly used, it’s also worth noting that next accepts an optional
second default argument for an exit value; if passed, it’s returned at the end
instead of raising a stop exception:
```
[^261]
**Annotation:** This excerpt demonstrates 'def' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Default Argument** *(p.536)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.536, lines 24–31)*:
```
Though not commonly used, it’s also worth noting that next accepts an optional
second default argument for an exit value; if passed, it’s returned at the end
instead of raising a stop exception:
>>> L = [1]
>>> I = iter(L)                                # Result instead of exception
>>> next(I, 'end of list')
1
>>> next(I, 'end of list')
```
[^262]
**Annotation:** This excerpt demonstrates 'default argument' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Dictionary** *(p.520)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.520, lines 2–9)*:
```
More zip roles: dictionaries
Fine points aside, parallel traversals with zip are also useful in dictionary
construction. We met this technique in Chapter 8, but here’s a quick refresher in
the context of looping statements. As we learned earlier, you can always create a
dictionary by calling dict, assigning to keys over time, or coding a dictionary
literal like the following:
>>> D1 = {'app': 1, 'script': 3, 'program':5}          # Or dict(key=value,…)
>>> D1
```
[^263]
**Annotation:** This excerpt demonstrates 'dictionary' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 15: The Documentation Interlude** *(pp.541–565)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^264]

**Annotation:** Forward reference: Chapter 15 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 16: Function Basics** *(pp.566–600)*

This later chapter builds upon the concepts introduced here, particularly: None, args, argument.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^265]

**Annotation:** Forward reference: Chapter 16 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, args appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 17: Scopes** *(pp.601–635)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^266]

**Annotation:** Forward reference: Chapter 17 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 15: The Documentation Interlude

*Source: Learning Python, 6th Edition, pages 541–565*

### Chapter Summary
Standard-library iterables in Python
Finally, while out of scope here, and technically part of its standard library
instead of its language, Python provides additional tools that support the iteration
protocol and thus may also be used in for loops and other iteration tools Key topics include list comprehensions, protocol, and module. Covers comprehension. [^267]

### Concept-by-Concept Breakdown
#### **None** *(p.541)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.541, lines 32–35)*:
```
iterable for which a passed-in function returns True. In the following, we’re
leveraging concepts we’ve already learned—True includes nonempty and
nonzero objects, the bool built-in returns a single object’s truth value, and the
str string’s isdigit method is true for all-digit text:
```
[^268]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.556)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.556, lines 10–17)*:
```
reduce, all of the tools in the following examples accept any iterable as an
argument and use the iteration protocol to scan it, but return a single result:
>>> sum(range(5))                # Punt (requires numbers)
10
>>> any(open('data.txt'))        # Any/all lines true (nonempty)
True
>>> all(open('data.txt'))        # Mostly pointless for files
True
```
[^269]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.551)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.551, lines 3–10)*:
```
for simple types of iterations; for more involved work, a simpler for statement
structure will probably be easier to understand and modify in the future. As usual
in programming, if something is difficult for you to understand, it’s probably not
the best idea.
Comprehensions Cliff-Hanger
Because comprehensions are generally better taken in multiple doses, we’ll cut
this story short here for now. We’ll revisit list comprehensions in Chapter 20 in
the context of functional programming tools, and will define their syntax more
```
[^270]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 14 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.563)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.563, lines 1–8)*:
```
To find out what attributes are provided in objects of built-in types, run dir on a
literal, an existing instance, or the name of the desired type. For example, to see
all text-string attributes, you can pass an empty or the type name str:
>>> dir('')
['__add__', …more names here…, 'zfill']
>>> dir(str) == dir('')
True
The dir result for any built-in type includes a set of attributes that are related to
```
[^271]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 7 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Await** *(p.542)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.542, lines 10–17)*:
```
emulated roughly with list comprehensions and more closely with Chapter 20’s
generator expressions; but to grok the following code in full, we have to await
this chapter’s presentation of comprehensions coming up soon:
>>> [ord(x) for x in 'py3']
[112, 121, 51]
>>> [x for x in ['lp6e', '2024'] if x.isdigit()]
['2024']
Multiple-pass versus single-pass iterables
```
[^272]
**Annotation:** This excerpt demonstrates 'await' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Bytecode** *(p.565)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.565, lines 28–35)*:
```
syntax warning (and eventual error!) for unrecognized escapes each
time code is run or recompiled to bytecode (see Chapter 7’s coverage of
new \ deprecations in Python 3.12).
Content: docstrings can contain any sort of text, including the class’s
Unicode escape and raw emoji (per the Unicode intro in Chapter 4 and
the whole story in Chapter 37). Notice that the \U Unicode escape
requires backslashes to be used, so it precludes using raw strings to
avoid syntax errors in the future (use \\).
```
[^273]
**Annotation:** This excerpt demonstrates 'bytecode' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.564)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.564, lines 2–9)*:
```
Part VI will have more to say about constructors and operator overloading
methods when we discuss classes.
The dir function is mostly a memory jogger—it provides a list of attribute
names, but it does not tell you anything about what those names mean. For such
extra information, we need to move on to the next documentation source.
NOTE
Attributes in IDEs: Some GUIs for Python work, including IDLE, have features that list
attributes on objects automatically, which can be viewed as alternatives to dir. IDLE, for
```
[^274]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.548)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.548, lines 16–23)*:
```
they’re wrapped in a collection like a tuple or list.
One fine point here: recall from Chapter 9 that file objects close themselves
automatically in CPython when garbage-collected if still open. Hence, these list
comprehensions will also automatically close the file when their temporary file
object is garbage-collected after the expression runs. Outside CPython, though,
you may want to code these to close manually if this is run in a loop, to ensure
that file resources are freed immediately: open before the comprehension, and
close after. See Chapter 9 for more on file close calls if you need a refresher on
```
[^275]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Compiled** *(p.546)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.546, lines 16–23)*:
```
than manual for loop statements (often 2X as stated earlier) because their
iterations are performed at the speed of optimized (and usually compiled) code
inside the interpreter, rather than with manual Python code. Especially for larger
data sets, there is often a major performance advantage to using this expression.
List Comprehensions and Files
Let’s work through another common application of list comprehensions to
explore them in more detail. Recall that the file object has a readlines method
that loads the file into a list of line strings all at once:
```
[^276]
**Annotation:** This excerpt demonstrates 'compiled' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Comprehension** *(p.551)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.551, lines 1–8)*:
```
Beyond this complexity level, though, list comprehension expressions can
sometimes become too compact for their own good. In general, they are intended
for simple types of iterations; for more involved work, a simpler for statement
structure will probably be easier to understand and modify in the future. As usual
in programming, if something is difficult for you to understand, it’s probably not
the best idea.
Comprehensions Cliff-Hanger
Because comprehensions are generally better taken in multiple doses, we’ll cut
```
[^277]
**Annotation:** This excerpt demonstrates 'comprehension' as it appears in the primary text. The concept occurs 11 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Constructor** *(p.564)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.564, lines 1–8)*:
```
calling one of these invokes its constructor to generate an instance of that type.
Part VI will have more to say about constructors and operator overloading
methods when we discuss classes.
The dir function is mostly a memory jogger—it provides a list of attribute
names, but it does not tell you anything about what those names mean. For such
extra information, we need to move on to the next documentation source.
NOTE
Attributes in IDEs: Some GUIs for Python work, including IDLE, have features that list
```
[^278]
**Annotation:** This excerpt demonstrates 'constructor' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Continue** *(p.549)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.549, lines 11–18)*:
```
character matches; if not, the line is omitted from the result list, and the iteration
continues. This is a fairly big expression, but it’s easy to understand if we
translate it to its simple for loop statement equivalent:
>>> res = []
>>> for line in open('data.txt'):
        if line[0] in 'LP':
            res.append(line.rstrip())
   
```
[^279]
**Annotation:** This excerpt demonstrates 'continue' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Def** *(p.557)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.557, lines 16–23)*:
```
again in Chapter 30 when we study classes. As you’ll see later:
User-defined functions can be turned into iterable generator functions,
with yield statements.
List comprehensions morph into iterable generator expressions when
coded in parentheses.
User-defined classes are made iterable with __iter__ or __getitem__
in operator overloading.
In particular, user-defined iterables defined with classes allow arbitrary objects
```
[^280]
**Annotation:** This excerpt demonstrates 'def' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Dictionary** *(p.551)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.551, lines 12–19)*:
```
turn out to be just as related to functions as they are to looping statements.
List comprehensions are also related to—and predate—the set and dictionary
comprehensions introduced in this book’s prior part, as well as the generator
expression you’ll meet later that produces items on request instead of building a
list. All share the same syntax, but are coded slightly differently and produce
different sorts of stuff:
[x + 10 for x in L if x > 0]         # List comprehension
{x + 10 for x in L if x > 0}         # Set comprehension
```
[^281]
**Annotation:** This excerpt demonstrates 'dictionary' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Docstring** *(p.564)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.564, lines 13–20)*:
```
on IDLE.
Docstrings and __doc__
Besides # comments, Python supports documentation that is automatically
attached to objects and retained at runtime for inspection. Syntactically, such
comments are coded as string literals of any type, except bytes and f-strings.
They are located at the tops of code components (module files and function and
class statements), and before any other executable code (# comments, including
Unix-style #! lines, are OK before them). When present, the text of such strings,
```
[^282]
**Annotation:** This excerpt demonstrates 'docstring' as it appears in the primary text. The concept occurs 6 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 16: Function Basics** *(pp.566–600)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^283]

**Annotation:** Forward reference: Chapter 16 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 17: Scopes** *(pp.601–635)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^284]

**Annotation:** Forward reference: Chapter 17 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 18: Arguments** *(pp.636–680)*

This later chapter builds upon the concepts introduced here, particularly: argument, as, attribute.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^285]

**Annotation:** Forward reference: Chapter 18 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts argument, as appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 16: Function Basics

*Source: Learning Python, 6th Edition, pages 566–600*

### Chapter Summary
This chapter covers function basics. Key topics include module, generator, and decorators. Covers function, module, statement. [^286]

### Concept-by-Concept Breakdown
#### **None** *(p.582)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.582, lines 8–15)*:
```
list.append and list.sort methods presented in Chapter 8 do not
return values (other than None), so you should call them without
assigning the result. It’s not uncommon for beginners to say something
like mylist = mylist.append(X) to try to get the result of an append,
but this assigns mylist to None, not to the modified list (in fact, you’ll
lose your reference to the list altogether).
Always use parentheses to call a function. You must add parentheses
after a function name to call it, whether it takes arguments or not (e.g.,
```
[^287]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Pythonpath** *(p.576)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.576, lines 29–32)*:
```
started—but that may be meaningless when started from a Windows Start button.
Change your PYTHONPATH setting to include other code folders as needed, per
Appendix A.
Second, although Pydoc can render docs for both importable modules and
```
[^288]
**Annotation:** This excerpt demonstrates 'PYTHONPATH' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Init__** *(p.576)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.576, lines 8–15)*:
```
$ ls …foldepath…/pydoc_data          # Pydoc's CSS customization file is in here
__init__.py        topics.py
__pycache__        _pydoc.css
On Windows, use py and dir instead of python3 and ls. This uses the Python -
c command-line argument to submit code to be run as a string, which is handy
for short bits of one-off code like this; here, the two statements separated by a
semicolon run the same as they would if they were typed one at a time at a
REPL’s >>> prompt.
```
[^289]
**Annotation:** This excerpt demonstrates '__init__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Main__** *(p.577)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.577, lines 14–21)*:
```
when a file is run, not when it is imported (e.g., by nesting it under a test for
variable __name__ being '__main__'). If scripts use these protocols, they’re
safe to view in Pydoc, because it won’t run any top-level code as an inadvertent
side effect of viewing docs.
Finally, Pydoc has additional tools we’ll skip here for space, including a -w
switch for saving HTML docs to a file for later viewing, and a plain-text mode
run from a command line with just a topic name that works the same as help in
a REPL. Again, run Pydoc without any command-line arguments for its full set
```
[^290]
**Annotation:** This excerpt demonstrates '__main__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Name__** *(p.577)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.577, lines 14–21)*:
```
when a file is run, not when it is imported (e.g., by nesting it under a test for
variable __name__ being '__main__'). If scripts use these protocols, they’re
safe to view in Pydoc, because it won’t run any top-level code as an inadvertent
side effect of viewing docs.
Finally, Pydoc has additional tools we’ll skip here for space, including a -w
switch for saving HTML docs to a file for later viewing, and a plain-text mode
run from a command line with just a topic name that works the same as help in
a REPL. Again, run Pydoc without any command-line arguments for its full set
```
[^291]
**Annotation:** This excerpt demonstrates '__name__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Annotation** *(p.597)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.597, lines 7–14)*:
```
types. This makes code flexible by design.
Attributes, annotations, and decorators support advanced roles.
Functions can optionally be augmented with both user-defined attributes
and other tools that extend their roles. Annotations of arguments and
results, for example, can serve a variety of goals. Among these, type
hinting (noted in Chapter 6) gives suggested object types but is unused
by Python itself and simply serves as a weighty form of documentation,
which we won’t cover further in this book. More usefully, functions can
```
[^292]
**Annotation:** This excerpt demonstrates 'annotation' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Args** *(p.596)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.596, lines 26–31)*:
```
also pass arguments by name with name=value keyword syntax and
unpack arbitrarily many arguments to send with *args and **args
starred-value notation. Function definitions use the same syntax forms
to specify argument defaults and collect arbitrarily many arguments
received.
Arguments, return values, and variables are not declared. As with
```
[^293]
**Annotation:** This excerpt demonstrates 'args' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.596)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.596, lines 14–21)*:
```
functions of all kinds:
Arguments are passed by assignment (object reference). In Python,
arguments are passed to functions by assignment—which, as we’ve
learned, means by object reference. As you’ll see, in Python’s model the
caller and function share objects by references, but there is no name
aliasing. Changing an argument name within a function does not also
change the corresponding name in the caller, but changing passed-in
mutable objects in place can change objects shared by the caller, and
```
[^294]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 10 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.596)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.596, lines 1–8)*:
```
it left off. Functions known as generators may also use the yield
statement to send back a value and suspend their state such that they
may be resumed later, to produce a series of results over time. Along
with their generator expression kin, such functions save space and
avoid delays just like the built-in iterables we met in the prior part of
this book.
await/async pause a waiting function so that other tasks may run.
Functions known as coroutines can suspend their execution until a
```
[^295]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 17 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Async** *(p.592)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.592, lines 17–24)*:
```
(i ** 2 for i in range(x))
async/await
async def consumer(a, b): await producer(b)
Decorators and
annotations
@tracer def func(a: 'hack' = None) -> None
Why Use Functions?
Before we get into the details, let’s establish a clearer picture of what functions
```
[^296]
**Annotation:** This excerpt demonstrates 'async' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.566)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.566, lines 1–8)*:
```
The whole point of this documentation protocol is that your comments are
retained for inspection in __doc__ attributes after the file is loaded. Thus, to
display the docstrings associated with the module and the two code components
it defines, we simply import the file and print their __doc__ attributes, where
Python has saved the text. Assuming this module is located in the directory in
which we’re currently working (and deferring to Chapter 3’s note about imports
and directories for background info on why that matters):
$ python3
```
[^297]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Await** *(p.592)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.592, lines 17–24)*:
```
(i ** 2 for i in range(x))
async/await
async def consumer(a, b): await producer(b)
Decorators and
annotations
@tracer def func(a: 'hack' = None) -> None
Why Use Functions?
Before we get into the details, let’s establish a clearer picture of what functions
```
[^298]
**Annotation:** This excerpt demonstrates 'await' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.570)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.570, lines 20–27)*:
```
FUNCTIONS
    __breakpointhook__ = breakpointhook(...)
    …more omitted…
DATA
    __stderr__ = <_io.TextIOWrapper name='<stderr>' mode='w' encoding='utf...
    …more omitted…
FILE
    (built-in)
```
[^299]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Breakpoint** *(p.570)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.570, lines 20–27)*:
```
FUNCTIONS
    __breakpointhook__ = breakpointhook(...)
    …more omitted…
DATA
    __stderr__ = <_io.TextIOWrapper name='<stderr>' mode='w' encoding='utf...
    …more omitted…
FILE
    (built-in)
```
[^300]
**Annotation:** This excerpt demonstrates 'breakpoint' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Bytecode** *(p.567)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.567, lines 10–17)*:
```
board as this note is being written, plans to remove leading indentation from docstrings, mostly
to save space in bytecode files and memory. Even before this mod, though, you won’t normally
see the indents in docs, because tools like Pydoc already strip and reformat, as you’ll learn
shortly.
Docstring standards
As mentioned earlier, common practice today recommends hash-mark comments
for only smaller-scale documentation about an expression, statement, or small
group of statements. Docstrings are better used for higher-level and broader
```
[^301]
**Annotation:** This excerpt demonstrates 'bytecode' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 17: Scopes** *(pp.601–635)*

This later chapter builds upon the concepts introduced here, particularly: None, __main__, __name__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^302]

**Annotation:** Forward reference: Chapter 17 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __main__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 18: Arguments** *(pp.636–680)*

This later chapter builds upon the concepts introduced here, particularly: __name__, annotation, args.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^303]

**Annotation:** Forward reference: Chapter 18 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts __name__, annotation appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 19: Advanced Function Topics** *(pp.681–720)*

This later chapter builds upon the concepts introduced here, particularly: None, __name__, annotation.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^304]

**Annotation:** Forward reference: Chapter 19 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __name__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 17: Scopes

*Source: Learning Python, 6th Edition, pages 601–635*

### Chapter Summary
This chapter covers scopes. Key topics include module, namespace, and closures. Covers function, module, variable. [^305]

### Concept-by-Concept Breakdown
#### **Legb Rule** *(p.616)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.616, lines 4–11)*:
```
such nonlocals and globals in order to change them.
Python’s name-resolution scheme is usually called the LEGB rule, after the
names of the scopes it searches:
When you use an unqualified name (not after a “.”) inside a function,
Python searches up to four scopes—the local (L) scope of the function
itself, then the local scopes of any enclosing (E) defs and lambdas, then
the global (G) scope of the surrounding module, and finally the built-in
(B) scope—and stops at the first place the name is found. If the name is
```
[^306]
**Annotation:** This excerpt demonstrates 'LEGB rule' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **None** *(p.610)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.610, lines 8–15)*:
```
normally happen during an import operation.
3. A def function returns the None object by default if the control flow
falls off the end of the function body without running into a return
statement. Such functions are usually called with expression statements,
as assigning their None results to variables is generally pointless. A
return statement with no expression in it also returns None. A lambda
implicitly returns its expression’s result, so it has no default.
4. The function body (the code nested inside the function def statement or
```
[^307]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Main__** *(p.613)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.613, lines 13–20)*:
```
by Python like open and zip. This includes code typed at the REPL: the
interactive prompt is technically a module named __main__ that prints results
and doesn’t correspond to a real file; in all other ways, though, it’s like the top
level of a module file.
Functions, though, provide nested namespaces (scopes) that localize the names
they use, such that names inside a function won’t clash with those outside it (in a
module or another function). Specifically, functions define a local scope and
modules define a global scope with the following properties:
```
[^308]
**Annotation:** This excerpt demonstrates '__main__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Name__** *(p.630)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.630, lines 3–10)*:
```
   import sys                           # Import system table
   thismod = sys.modules['thismod']     # Get module object (or use __name__)
   thismod.var += 1                     # Change global var
def test():
   print(var)
   local(); glob1(); glob2(); glob3()
   print(var)
When we import and call this module’s test to invoke its other functions, this
```
[^309]
**Annotation:** This excerpt demonstrates '__name__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.602)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.602, lines 4–11)*:
```
function’s name. The parentheses may optionally contain one or more object
arguments, to be passed (i.e., assigned) to the names in the function’s header:
>>> times(2, 4)            # Arguments in parentheses
8
This expression passes two arguments to times. As mentioned previously,
arguments are passed by assignment, so in this case the name x in the function
header is assigned the object 2, y is assigned 4, and the function’s body is run.
For this function, the body is just a def’s return statement or a lambda’s
```
[^310]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Array** *(p.610)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.610, lines 21–28)*:
```
types only. Without such checks, the function would likely be able to
process an entire array of object types—any objects that support the
interface expected by the function will work. (The term interface means
the set of methods and expression operators the function’s code runs.)
1  This code will always work if we intersect files’ contents obtained with file.readlines(). It may
not work to intersect lines in open input files directly, though, depending on the file object’s
implementation of the in operator or general iteration. Files must generally be rewound (e.g., with a
file.seek(0) or another open) after they have been read to end-of-file once, and so are single-pass
```
[^311]
**Annotation:** This excerpt demonstrates 'array' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.615)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.615, lines 1–8)*:
```
Beyond those basics, there are three subtleties worth underscoring. First, as
noted, code typed at the Python interactive prompt lives in a module, too, and
follows the normal scope rules: names assigned there are global variables,
accessible to the entire interactive session. You’ll learn more about modules in
the next part of this book.
Second, also bear in mind that any type of assignment classifies a name as local
or global, based on where the assignment appears. This includes = statements
and := expressions; module names in import; function and argument names in
```
[^312]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 23 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Assert** *(p.621)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.621, lines 15–22)*:
```
>>> dir(builtins)
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 
'BaseExceptionGroup', 'BlockingIOError', 'BrokenPipeError', 'BufferError',
…many more names omitted: 158 total in 3.12…
'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 
'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 
'super', 'tuple', 'type', 'vars', 'zip']
The names in this list constitute the built-in scope in Python. Roughly the first
```
[^313]
**Annotation:** This excerpt demonstrates 'assert' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Assertion** *(p.621)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.621, lines 15–22)*:
```
>>> dir(builtins)
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 
'BaseExceptionGroup', 'BlockingIOError', 'BrokenPipeError', 'BufferError',
…many more names omitted: 158 total in 3.12…
'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 
'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 
'super', 'tuple', 'type', 'vars', 'zip']
The names in this list constitute the built-in scope in Python. Roughly the first
```
[^314]
**Annotation:** This excerpt demonstrates 'assertion' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.619)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.619, lines 4–11)*:
```
generate instances, which inherit names assigned in the class and record per-
object state as per-instance attributes of their own. As you’ll also learn in
Chapter 29, although the LEGB rule is used to resolve names used in both the
top level of a class itself as well as the top level of method functions nested
within it, classes themselves are skipped by scope lookups—their names must be
fetched as object attributes. Hence, because Python searches enclosing functions
for referenced names, but not enclosing classes, the LEGB rule sketched in
Figure 17-1 still applies to OOP code.
```
[^315]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.604)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.604, lines 7–14)*:
```
possible to test for types with tools like the type built-in function, doing so
breaks your code’s flexibility. By and large, we code to object interfaces in
Python, not data types.
Of course, some programs have unique requirements, and this polymorphic
model of programming means we have to test our code to detect some errors that
statically typed compiled languages might be able to detect earlier. In exchange
for an initial bit of extra testing, though, we radically reduce the amount of code
we have to write, and radically increase our code’s flexibility. As you’ll come to
```
[^316]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.618)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.618, lines 26–32)*:
```
these expressions follow the usual LEGB lookup rules.
It’s also worth noting that the class statement you’ll meet in Part VI creates a
new local scope, too, for the names assigned inside the top level of its block. As
for def, names assigned inside a class don’t clash with names elsewhere, and
follow the LEGB lookup rule, where the class block is the L level. As for
imported modules, these class-local names also morph into class object attributes
after the class statements ends. For all practical purposes, classes are a local
```
[^317]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 7 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.630)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.630, lines 22–29)*:
```
As we’ve seen, global allows us to easily change names in a module outside a
function. It has a close relative named nonlocal that can be used to change
names in enclosing functions, too—but to understand how that can be useful, we
first need to explore function nesting in general, the topic we turn to next.
Nested Functions and Scopes
So far, this chapter has largely omitted one part of Python’s scope rules on
purpose, because it’s relatively uncommon to encounter it in practice. However,
it’s time to take a deeper look at layer E in the LEGB lookup rule. This layer was
```
[^318]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Closure** *(p.635)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.635, lines 1–8)*:
```
storage area for the enclosing scope names they use. It’s available as the
__closure__ attribute of such functions (and fetching cell_contents after
indexing this tuple yields a state item), but we don’t need to understand Python
internals to use closures in our code.
This is also a somewhat advanced technique that you may not see commonly in
most code, and may be more popular among programmers with backgrounds in
functional programming languages. On the other hand, enclosing scopes are
often employed by the lambda function-creation expressions introduced in the
```
[^319]
**Annotation:** This excerpt demonstrates 'closure' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Compiled** *(p.601)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.601, lines 7–14)*:
```
Apart from their runtime flavor (which tends to seem most novel to
programmers with backgrounds in compiled languages), Python functions are
straightforward to use. Let’s code a first real example to demonstrate the
fundamentals, from both sides of the function equation: definition (the def or
lambda that creates a function) and calls (the expressions that tell Python to run
the function’s body).
Definition
Here’s a definition typed interactively that defines a function named times,
```
[^320]
**Annotation:** This excerpt demonstrates 'compiled' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 18: Arguments** *(pp.636–680)*

This later chapter builds upon the concepts introduced here, particularly: LEGB rule, __name__, argument.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^321]

**Annotation:** Forward reference: Chapter 18 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts LEGB rule, __name__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 19: Advanced Function Topics** *(pp.681–720)*

This later chapter builds upon the concepts introduced here, particularly: None, __name__, argument.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^322]

**Annotation:** Forward reference: Chapter 19 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __name__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 20: Comprehensions and Generations** *(pp.721–755)*

This later chapter builds upon the concepts introduced here, particularly: LEGB rule, None, __name__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^323]

**Annotation:** Forward reference: Chapter 20 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts LEGB rule, None appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 18: Arguments

*Source: Learning Python, 6th Edition, pages 636–680*

### Chapter Summary
This chapter covers arguments. Key topics include module, closures, and collection. Covers function, variable. [^324]

### Concept-by-Concept Breakdown
#### **Legb Rule** *(p.648)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.648, lines 9–16)*:
```
    X = 88
    def f2():               # Remember enclosing scope X per LEGB rule
        print(X + 1)        # And likewise for lambda
    f2()
That said, flat is generally better than nested again, and function nesting in some
such code makes programs more complex than they need be. The following, for
instance, is an equivalent of the prior examples that avoids nesting altogether.
Notice the forward reference to f2 inside f1 in this code—it’s OK to call a
```
[^325]
**Annotation:** This excerpt demonstrates 'LEGB rule' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Name__** *(p.679)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.679, lines 14–21)*:
```
def tracer(func, *pargs, **kargs):         # Accept arbitrary arguments
   print('calling:', func.__name__)
   return func(*pargs, **kargs)           # Pass along arbitrary arguments
def func(a, b, c, d):
   return a + b + c + d
print(tracer(func, 1, 2, c=3, d=4))
This code uses the built-in __name__ attribute attached to every function (as you
might expect, it’s the function’s name string), and uses stars to collect and then
```
[^326]
**Annotation:** This excerpt demonstrates '__name__' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Annotation** *(p.671)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.671, lines 1–8)*:
```
simply additional syntax for arguments and does not augment or change argument-ordering
rules. The function itself can also have an annotation value, given as def f(…)->annot, and
Python attaches all annotation values to the function object. See the discussion of function
annotation in Chapter 19 for more details, and the section on their role in unused type hinting
in Chapter 6.
Keyword and Default Examples
Argument passing is simpler in code than the preceding descriptions may imply.
First off, if you don’t use any special matching syntax, Python matches names by
```
[^327]
**Annotation:** This excerpt demonstrates 'annotation' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Args** *(p.675)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.675, lines 1–8)*:
```
When this function is called, Python collects all the positional arguments into a
new tuple and assigns the variable args to that tuple. Because it is a normal
tuple object, it can be indexed, stepped through with a for loop, and so on:
>>> f()
()
>>> f(1)
(1,)
>>> f(1, 2, 3, 4)
```
[^328]
**Annotation:** This excerpt demonstrates 'args' as it appears in the primary text. The concept occurs 9 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.666)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.666, lines 1–8)*:
```
argument values (passed in a call) to argument names (listed in a function
definition) by position, from left to right.
Keywords: matched by argument name
Alternatively, callers can explicitly specify which argument in the function is
to receive a value, by giving the definition’s name for the argument with
name=value syntax.
Defaults: specify values for optional arguments that aren’t passed
Functions themselves can specify default values for arguments to receive if
```
[^329]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 21 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Array** *(p.659)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.659, lines 25–31)*:
```
Objects such as lists and dictionaries are also passed by object
reference, which has similar consequences to passing arrays as pointers
in C: mutable objects can be changed in place within the function, with
side effects like those for C’s arrays.
If you’ve never used C, Python’s argument-passing mode will seem simpler still
—it involves just the assignment of object references to names, and it works the
same whether the objects are mutable or not.
```
[^330]
**Annotation:** This excerpt demonstrates 'array' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.659)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.659, lines 1–8)*:
```
Assigning to argument names inside a function does not affect the
caller. Per assignment norms, when the function is run by a call,
argument names in the function header simply become new names in
the local scope of the function. There is no aliasing between function
argument names and variable names in the caller’s scope.
Changing a mutable object argument in a function may impact the
caller. On the other hand, as arguments are simply references to passed-
in objects, functions can change passed-in mutable objects in place, and
```
[^331]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 24 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Async** *(p.657)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.657, lines 15–18)*:
```
commonly used for long-running tasks in GUIs, to implement nonblocking IO, and to utilize CPU
capacity. Threading is also well beyond this language book’s scope (a property it shares with async
functions, which are nevertheless part of Python syntax today, as you’ll learn in Chapter 20). See
Python’s library manual for more details.
```
[^332]
**Annotation:** This excerpt demonstrates 'async' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.643)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.643, lines 8–15)*:
```
object. For per-call roles, globals don’t fit the bill.
Function Attributes: Changeable, Per-Call, Explicit
As another state-retention option, we can often achieve the same effect as
nonlocals with function attributes—user-defined names attached to functions
explicitly. When you attach user-defined attributes to nested functions generated
by factory functions, they can also serve as per-call, multiple copy, and writeable
state, just like nonlocal scope closures. Such user-defined attribute names won’t
clash with names Python creates itself, and as for nonlocal, need be used only
```
[^333]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 9 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.668)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.668, lines 15–22)*:
```
only in calls
The argument-matching modes listed in this table break down between function
calls and definitions as follows:
In a function call (the first four rows of the table)
Simple values are matched to definition arguments by position, but using the
name=value form tells Python to match arguments by name instead; these
are called keyword arguments. Any number of *iterable or **dict forms
can be used in a call, allowing us to bundle many positional or keyword
```
[^334]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.645)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.645, lines 15–22)*:
```
This exploits the mutability of lists, and like function attributes, relies on the fact that in-place
object changes do not classify a name as local. This is perhaps more obscure than either
function attributes or nonlocal, though—it’s a technique that predates others, and seems to lie
today somewhere on the spectrum from arcane hack to dated workaround. You’re probably
better off using named function attributes than lists and numeric offsets this way (but you can’t
control what others code).
Classes: Changeable, Per-Call, OOP
Another standard prescription for changeable state information in Python is to
```
[^335]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 8 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.640)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.640, lines 34–35)*:
```
appear anywhere in the hierarchy of enclosing functions—not just one level up
—and the closest appearance is used. Even so, because such code seems unlikely
```
[^336]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Closure** *(p.636)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.636, lines 7–14)*:
```
to crop up in practice. Per coding aphorism, flat is better than nested, and this
still holds generally true even with nested scope closures in the toolbox. Except
in limited contexts, your life (and the lives of your fellow travelers in the
software realm) will generally be better if you minimize nesting in function
definitions.
The nonlocal Statement
In the prior section, we saw how nested functions can reference variables in an
enclosing function’s scope, even if that function has already returned. As
```
[^337]
**Annotation:** This excerpt demonstrates 'closure' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Collections** *(p.666)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.666, lines 17–24)*:
```
Function calls can also use the one or two * syntax to unpack argument
collections into separate arguments. This is the inverse of a * in a function
definition—in the definition it means collect arbitrarily many arguments,
while in the call it means unpack arbitrarily many arguments, and pass them
individually as discrete values.
Keyword-only arguments: arguments that must be passed by name
Function definitions can also use a * in their headers to specify arguments
that must be passed by name as keyword arguments, not position. This is
```
[^338]
**Annotation:** This excerpt demonstrates 'collections' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Comprehension** *(p.649)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.649, lines 23–30)*:
```
<function makeActions.<locals>.<lambda> at 0x101ae7ec0>
Interestingly, this can also be coded as a list comprehension, where a lambda can
be used as the collection result, and the list comprehension serves as a local
scope for its loop variable:
>>> acts = [(lambda x: i ** x) for i in range(5)]
>>> acts[0]
<function <lambda> at 0x10de6bce0>
Either way, though, this doesn’t quite work—because the enclosing scope
```
[^339]
**Annotation:** This excerpt demonstrates 'comprehension' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 19: Advanced Function Topics** *(pp.681–720)*

This later chapter builds upon the concepts introduced here, particularly: __name__, annotation, args.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^340]

**Annotation:** Forward reference: Chapter 19 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts __name__, annotation appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 20: Comprehensions and Generations** *(pp.721–755)*

This later chapter builds upon the concepts introduced here, particularly: LEGB rule, __name__, annotation.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^341]

**Annotation:** Forward reference: Chapter 20 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts LEGB rule, __name__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 21: Modules: The Big Picture** *(pp.756–785)*

This later chapter builds upon the concepts introduced here, particularly: LEGB rule, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^342]

**Annotation:** Forward reference: Chapter 21 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts LEGB rule, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 19: Advanced Function Topics

*Source: Learning Python, 6th Edition, pages 681–720*

### Chapter Summary
This chapter covers advanced function topics. Key topics include module, sequences, and package. Covers function. [^343]

### Concept-by-Concept Breakdown
#### **None** *(p.692)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.692, lines 7–14)*:
```
…and the same for others…
Notice that none of these four variants tests for the case where no arguments are
passed in. They could, but there’s probably no point in doing so here—in all four
solutions, Python will automatically raise an exception to signal the error if no
arguments are sent. The first variant raises an exception when we try to fetch
argument 0, the second when Python detects an argument list mismatch, and the
third and fourth when we try to return item 0 post sort.
This is exactly what we want to happen—because these functions support any
```
[^344]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Name__** *(p.691)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.691, lines 25–32)*:
```
for func in (min1, min2, min3, min4):           # Test all 4 functions
   print(func.__name__ + '...')
   print(func(3, 4.0, 1, 2))                   # Mixed numerics
   print(func('bb', 'aa'))                     # Strings: code points
   print(func([2, 2], [1, 1], [3, 3]))         # Lists: recursive
   print(func(*'hack'))                        # Unpacked characters
This script’s testing code uses the __name__ attribute we met earlier, along with
a for loop to run each function one at a time (remember, functions are objects
```
[^345]
**Annotation:** This excerpt demonstrates '__name__' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Repr__** *(p.720)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.720, lines 2–9)*:
```
overloading methods in classes such as __setattr__ and __getattribute__
and even __repr__ have the potential to recursively loop if used incorrectly.
Recursion is a powerful tool, but it tends to be best when both understood and
expected!
Function Tools: Attributes, Annotations, Etc.
Let’s move on to a category of tools that may seem less ethereal than recursion
to some earthlings. As we’ve seen in this part of the book, functions in Python
are much more than code-generation specifications for a compiler—they are full-
```
[^346]
**Annotation:** This excerpt demonstrates '__repr__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Annotation** *(p.720)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.720, lines 5–12)*:
```
expected!
Function Tools: Attributes, Annotations, Etc.
Let’s move on to a category of tools that may seem less ethereal than recursion
to some earthlings. As we’ve seen in this part of the book, functions in Python
are much more than code-generation specifications for a compiler—they are full-
blown objects, stored in pieces of memory all their own. As such, they can be
freely passed around a program and called indirectly. They also support
operations that have little to do with calls at all, including attributes and
```
[^347]
**Annotation:** This excerpt demonstrates 'annotation' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Args** *(p.699)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.699, lines 2–9)*:
```
import sys
def print3(*args, **kargs):
   sep  = kargs.pop('sep', ' ')
   end  = kargs.pop('end', '\n')
   file = kargs.pop('file', sys.stdout)
   if kargs: raise TypeError(f'extra keywords: {kargs}')
   output = ''
   first  = True
```
[^348]
**Annotation:** This excerpt demonstrates 'args' as it appears in the primary text. The concept occurs 10 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.682)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.682, lines 2–9)*:
```
>>> kwonly(1)
TypeError: kwonly() missing 1 required keyword-only argument: 'c'
>>> kwonly(1, 2, 3)
TypeError: kwonly() takes 1 positional argument but 3 were given
>>> def badmix(b=2, c, d=5): …
SyntaxError: parameter without a default follows parameter with a default
Finally, note that keyword-only arguments must be specified after a single star,
not two—nothing can appear after the **args arbitrary-keywords form, and,
```
[^349]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 16 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Array** *(p.708)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.708, lines 9–16)*:
```
a state-retention tool in the same category as other local variables. Despite the
array of options, good function designs prefer to use only arguments for inputs
and return statements for outputs, whenever possible.
Figure 19-1. Function execution environment
Of course, there are plenty of exceptions to the preceding design rules, including
some related to Python’s OOP support. As you’ll see in Part VI, Python classes
depend on changing a passed-in mutable object—class functions set attributes of
an automatically passed-in argument called self to change per-object state
```
[^350]
**Annotation:** This excerpt demonstrates 'array' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.684)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.684, lines 1–8)*:
```
TypeError: mostlypos() got some positional-only arguments passed as keyword 
arguments: 'b'
>>> mostlypos(c=3, b=2, a=1)
TypeError: mostlypos() got some positional-only arguments passed as keyword 
arguments: 'a, b'
To define a function that allows only positional arguments, simply code the slash
at the end:
>>> def allpos(a, b, c, /): print(a, b, c)
```
[^351]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 17 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.720)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.720, lines 1–8)*:
```
recursion in your programs. As you’ll also see later in the book, some operator-
overloading methods in classes such as __setattr__ and __getattribute__
and even __repr__ have the potential to recursively loop if used incorrectly.
Recursion is a powerful tool, but it tends to be best when both understood and
expected!
Function Tools: Attributes, Annotations, Etc.
Let’s move on to a category of tools that may seem less ethereal than recursion
to some earthlings. As we’ve seen in this part of the book, functions in Python
```
[^352]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.694)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.694, lines 22–29)*:
```
       for other in args[1:]:           # For all other args
           if x not in other: break     # Item in each one?
       else:                            # No: break out of loop
           res.append(x)                # Yes: add items to end
   return res
def union(*args):
   res = []
   for seq in args:                     # For all args
```
[^353]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.719)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.719, lines 13–20)*:
```
More recursion examples
Although this section’s example is artificial, it is representative of a larger class
of programs; inheritance trees and module import chains, for example, can
exhibit similarly general structures, and computing tools such as permutations
can require arbitrarily many nested loops. In fact, we’ll use recursion again in
such roles later in this book:
In Chapter 20’s permute.py, to shuffle arbitrary sequences
In Chapter 25’s reloadall.py, to traverse import chains
```
[^354]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.685)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.685, lines 11–18)*:
```
Definition Ordering
In function definitions, argument lists are enclosed in parentheses in a def
statement and coded before a colon in a lambda expression, but follow the same
format in both. In short, they consist of four optional parts that must appear in
the following order, where position means a simple value in calls, and keyword
means a name=value pair:
1. One or more arguments that must be passed by position only, followed
by a single /
```
[^355]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Comprehension** *(p.706)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.706, lines 13–20)*:
```
continues the advanced themes here with an exploration of generator functions
and expressions and a revival of list comprehensions in the context of the
functional tools we will study here.
Function Design Concepts
Now that we’ve studied function essentials in Python, let’s open this chapter
with some perspective. When you start using functions in earnest, you’re faced
with choices about how to glue components together—for instance, how to
decompose a task into purposeful functions (known as cohesion), and how your
```
[^356]
**Annotation:** This excerpt demonstrates 'comprehension' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Continue** *(p.694)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.694, lines 20–27)*:
```
   for x in args[0]:                    # Scan first sequence
       if x in res: continue            # Skip duplicates in [0]
       for other in args[1:]:           # For all other args
           if x not in other: break     # Item in each one?
       else:                            # No: break out of loop
           res.append(x)                # Yes: add items to end
   return res
def union(*args):
```
[^357]
**Annotation:** This excerpt demonstrates 'continue' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Decorator** *(p.687)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.687, lines 15–22)*:
```
SyntaxError: parameter without a default follows parameter with a default
Not shown here, def can also be preceded by a decorator (e.g., @value), and, as
noted earlier, any of its arguments may be followed by annotations (e.g.,
:value)—extensions we’ll explore in the next chapter and later in this book.
Neither of these impact argument ordering or matching, and neither work in
lambda due to its limited syntax.
Calls Ordering
On the other side of the fence, the syntax is similar but the rules differ. In
```
[^358]
**Annotation:** This excerpt demonstrates 'decorator' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 20: Comprehensions and Generations** *(pp.721–755)*

This later chapter builds upon the concepts introduced here, particularly: None, __name__, annotation.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^359]

**Annotation:** Forward reference: Chapter 20 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __name__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 21: Modules: The Big Picture** *(pp.756–785)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^360]

**Annotation:** Forward reference: Chapter 21 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 22: Module Coding Basics** *(pp.786–820)*

This later chapter builds upon the concepts introduced here, particularly: None, args, argument.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^361]

**Annotation:** Forward reference: Chapter 22 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, args appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 20: Comprehensions and Generations

*Source: Learning Python, 6th Edition, pages 721–755*

### Chapter Summary
This chapter covers comprehensions and generations. Key topics include list comprehension, decorators, and sequence. Covers function, lambda, expression. [^362]

### Concept-by-Concept Breakdown
#### **Legb Rule** *(p.731)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.731, lines 1–8)*:
```
def, which automatically sees names in enclosing functions, the module, and the
built-in scope—via the LEGB rule we studied in Chapter 17:
>>> def editions(title):                          # title in enclosing scope
        return (lambda e: title + ', ' + e)       # Return a function object
>>> labeler = editions('Learning Python')         # Make+save nested function
>>> labeler('6E')                                 # '6E' passed to e in lambda
'Learning Python, 6E'
With those basic lambda “hows” in hand, the natural next question is “why,”
```
[^363]
**Annotation:** This excerpt demonstrates 'LEGB rule' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **None** *(p.724)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.724, lines 8–15)*:
```
Naturally, all of this works the same for functions made with lambda:
>>> F = lambda: None
>>> len(dir(F))
38
>>> F.book = 'LP6E'
>>> F.book
'LP6E'
As covered in Chapter 17, such attributes can be used to attach state information
```
[^364]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Eq__** *(p.723)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.723, lines 3–10)*:
```
>>> dir(func.__code__)
['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__',
…more omitted: 48 total…
'co_posonlyargcount', 'co_qualname', 'co_stacksize', 'co_varnames', 'replace']
>>> func.__code__.co_varnames
('a', 'b')
>>> func.__code__.co_argcount
1
```
[^365]
**Annotation:** This excerpt demonstrates '__eq__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Name__** *(p.722)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.722, lines 22–29)*:
```
function objects. For instance, we can also inspect their attributes generically:
>>> func.__name__
'func'
>>> dir(func)
'__annotations__', '__builtins__', '__call__', '__class__', '__closure__',
…more omitted: 38 total…
'__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__type_params__']
Introspection—internals access—tools like this allow us to explore
```
[^366]
**Annotation:** This excerpt demonstrates '__name__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Str__** *(p.722)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.722, lines 27–32)*:
```
…more omitted: 38 total…
'__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__type_params__']
Introspection—internals access—tools like this allow us to explore
implementation details. For example, functions have attached code objects,
which provide details on aspects such as the functions’ local variables and
arguments:
```
[^367]
**Annotation:** This excerpt demonstrates '__str__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Annotation** *(p.726)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.726, lines 1–8)*:
```
reserved word can’t be used as an argument name); and the values of annotation
keys are assigned to the results of the annotation expressions:
>>> func.__annotations__
{'a': 'hack', 'b': (1, 10), 'c': <class 'float'>, 'return': <class 'int'>}
Because they are just Python objects attached to a Python object, annotations are
straightforward to process. The following annotates just two of three arguments
and steps through the attached annotations generically:
>>> def func(a: 'python', b, c: 3.12):
```
[^368]
**Annotation:** This excerpt demonstrates 'annotation' as it appears in the primary text. The concept occurs 11 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Args** *(p.728)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.728, lines 1–8)*:
```
def echo(F):
    def proxy(*args): 
        print('calling', F.__name__)       # Add actions here
        return F(*args)                    # Run decorated function
    return proxy
@echo
def func(x, y):                            # Rebinds func = echo(func)
    print('I am running...', x, y)         # func is run by the proxy closure
```
[^369]
**Annotation:** This excerpt demonstrates 'args' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.725)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.725, lines 8–15)*:
```
annotations today (more on this ahead).
We studied the formal rules for arguments in function definitions in the
preceding chapter. Annotations don’t modify these rules but simply extend their
syntax to allow extra expressions to be associated with named arguments and
function results. Consider the following nonannotated function, coded with three
arguments and a returned result:
>>> def func(a, b, c):
        return a + b + c
```
[^370]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 9 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Array** *(p.752)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.752, lines 4–11)*:
```
are nested—though use cases for the following sort of code, apart perhaps from
the multidimensional arrays ahead, start to become more and more difficult to
imagine at this level:
>>> [x + y for x in 'orm' if x in 'ro' for y in 'ORM' if y > 'M']
['oO', 'oR', 'rO', 'rR']
>>> [x + y + z for x in 'hack' if x > 'c'
               for y in 'CODE' if y in 'OD'
               for z in '123'  if z > '1']
```
[^371]
**Annotation:** This excerpt demonstrates 'array' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.721)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.721, lines 1–8)*:
```
reassign that object to other names freely and call it through any reference:
>>> def exclaim(message):              # Name exclaim assigned to function object
        print(message + '!')
>>> exclaim('Direct call')             # Call object through original name
Direct call!
>>> x = exclaim                        # Now x references the function too
>>> x('Indirect call')                 # Call object through name x by adding ()
Indirect call!
```
[^372]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 15 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Async** *(p.747)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.747, lines 10–17)*:
```
Finally, this chapter provides just enough of an intro to get you started with
async coroutines—tools that build on generators, but assume knowledge of
parallel programming, which is outside the scope of this book and the needs of
most Python learners. You won’t become an async master here, but you’ll get a
head start for further explorations.
Iteration and generation in Python also encompasses user-defined classes, but
we’ll defer that final part of this story until Part VI, when we study operator
overloading. The next chapter continues threads spun here by timing the relative
```
[^373]
**Annotation:** This excerpt demonstrates 'async' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.724)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.724, lines 5–12)*:
```
['count', 'handles']
If you’re careful not to name attributes the same way as Python, you can safely
use the function’s namespace as though it were your own namespace or scope.
Naturally, all of this works the same for functions made with lambda:
>>> F = lambda: None
>>> len(dir(F))
38
>>> F.book = 'LP6E'
```
[^374]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 7 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Boolean** *(p.740)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.740, lines 4–11)*:
```
[1, 2, 3, 4]
We met filter briefly earlier in the sidebar “Why You Will Care: Booleans”
and while exploring iterables in Chapter 14. Items in the sequence or iterable for
which the function returns a true result are added to the result list. Like map, this
function is roughly equivalent to a for loop, but it is built-in, concise, and often
fast:
>>> res = []
>>> for x in range(−5, 5):                   # The statement equivalent of filter
```
[^375]
**Annotation:** This excerpt demonstrates 'boolean' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.726)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.726, lines 3–10)*:
```
>>> func.__annotations__
{'a': 'hack', 'b': (1, 10), 'c': <class 'float'>, 'return': <class 'int'>}
Because they are just Python objects attached to a Python object, annotations are
straightforward to process. The following annotates just two of three arguments
and steps through the attached annotations generically:
>>> def func(a: 'python', b, c: 3.12):
        return a + b + c
>>> func(1, 2, 3)
```
[^376]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class Method** *(p.746)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.746, lines 1–8)*:
```
This is especially useful for accessing the special self instance argument
that is a local variable in enclosing class method functions (which we’ll
study in Part VI, so take this as preview only):
class MyGui:
    def makewidgets(self):
        Button(command=lambda: self.onPress('Tapped!'))
    def onPress(self, message):
        …use message…
```
[^377]
**Annotation:** This excerpt demonstrates 'class method' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 21: Modules: The Big Picture** *(pp.756–785)*

This later chapter builds upon the concepts introduced here, particularly: LEGB rule, None, argument.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^378]

**Annotation:** Forward reference: Chapter 21 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts LEGB rule, None appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 22: Module Coding Basics** *(pp.786–820)*

This later chapter builds upon the concepts introduced here, particularly: None, args, argument.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^379]

**Annotation:** Forward reference: Chapter 22 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, args appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 23: Module Packages** *(pp.821–850)*

This later chapter builds upon the concepts introduced here, particularly: None, __name__, args.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^380]

**Annotation:** Forward reference: Chapter 23 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __name__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 21: Modules: The Big Picture

*Source: Learning Python, 6th Edition, pages 756–785*

### Chapter Summary
This book demonstrates advanced comprehensions to teach, but in the real world, programming is not about being clever and obscure—it’s about how
clearly your program communicates its purpose Key topics include generator, list comprehension, and protocol. Covers generator, function, expression. [^381]

### Concept-by-Concept Breakdown
#### **Legb Rule** *(p.780)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.780, lines 31–33)*:
```
a further nested special-case scope, but other names referenced within these
expressions follow the usual LEGB rules. In the following generator, for
example, Z is localized in the comprehension, but Y and X are found in the
```
[^382]
**Annotation:** This excerpt demonstrates 'LEGB rule' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **None** *(p.764)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.764, lines 16–23)*:
```
the regular G.__next__() method (or its next(G) equivalent) is called to
advance, the yield simply returns None. For example:
>>> def gen():
       for i in range(10):
           X = yield i
           print('=>', X)
>>> G = gen()
>>> next(G)              # Must call next() first, to start generator
```
[^383]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.782)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.782, lines 22–29)*:
```
some more complete examples. In Chapter 18, we wrote a testing function,
based on earlier code in Chapter 13, that scrambled the order of arguments used
to verify generalized intersection and union functions. There, it was noted that
this might be better coded as a generator of values. Now that we’ve learned how
to write generators, this serves to illustrate a practical application.
One note up front: because they slice and concatenate objects, all the examples
in the section (including the permutations at the end) work only on sequences
like strings and lists, not on arbitrary iterables like files, maps, and other
```
[^384]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.785)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.785, lines 12–19)*:
```
minimize memory space requirements, and divide the work into shorter time
slices. As full functions, they are also very general. Moreover, because iteration
tools work the same whether stepping through a real list or a generator of values,
the function can select between the two codings freely, and even change
strategies in the future without impacting callers.
Generator expressions
As we’ve also seen, generator expressions—comprehensions in parentheses
instead of square brackets—also generate values on request and retain their local
```
[^385]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 10 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Async** *(p.765)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.765, lines 7–14)*:
```
like a tool called coroutines, a role eventually subsumed in part by the upcoming
async. Hence, we won’t delve further here; see Python’s standard manuals for
more information, and watch for more on exceptions in Part VII.
Note, though, that while Python provides a next(X) convenience built-in that
calls the X.__next__() method of an object, other generator methods, like send,
must be called as methods of generator objects directly (e.g., G.send(X)). This
makes sense if you realize that these extra methods are implemented on built-in
generator objects only, whereas the __next__ method applies to all iterable
```
[^386]
**Annotation:** This excerpt demonstrates 'async' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.760)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.760, lines 17–24)*:
```
automatically raising a StopIteration exception. A generator’s return can
also give an object that becomes the value attribute of the StopIteration
exception, but it’s ignored by iteration tools and uncommon. From the caller’s
perspective, the generator’s __next__ method simply starts or resumes the
function and runs until either the next yield result is returned, or a
StopIteration is raised.
The net effect is that generator functions, coded as def statements containing
yield statements, are automatically made to support the iteration methods
```
[^387]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Await** *(p.767)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.767, lines 3–10)*:
```
Exercises”, and stay tuned for a glimpse of async def coroutines ahead—whose
await is something like a generator yield from, with a delegation to an event
loop to allow other tasks to be run during pauses. Here, let’s move on to a tool
close enough to yield to be called a fraternal twin.
Generator Expressions: Iterables Meet Comprehensions
Because the delayed evaluation of generator functions was so useful, later
Pythons eventually combined the notions of iterables and comprehensions in a
new tool: generator expressions. Syntactically, generator expressions are just
```
[^388]
**Annotation:** This excerpt demonstrates 'await' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Bytecode** *(p.757)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.757, lines 15–22)*:
```
comprehensions run at compiled-language speed inside the interpreter, which is
generally faster than running for loop bytecode within the PVM.
Also in the plus column, list comprehensions offer a code conciseness that’s
compelling and even warranted when that reduction in size doesn’t also imply a
reduction in meaning for the next programmer; many find the expressiveness of
comprehensions to be a powerful ally; and because map and list comprehensions
are both expressions, they also can show up syntactically in places that for loop
statements cannot, such as in lambda and object literals.
```
[^389]
**Annotation:** This excerpt demonstrates 'bytecode' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.779)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.779, lines 1–8)*:
```
Finally, although beyond the scope of this chapter, it is also possible to
implement arbitrary user-defined generator objects with classes that conform to
the iteration protocol. Such classes define __iter__ and __next__ methods
explicitly to support the protocol:
class SomeIterable:
    def __iter__(...): ...     # On iter(): return self or supplemental object
    def __next__(...): ...     # On next(): coded here, or in another class
As the prior section suggested, these classes usually return their objects directly
```
[^390]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 7 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.767)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.767, lines 5–12)*:
```
loop to allow other tasks to be run during pauses. Here, let’s move on to a tool
close enough to yield to be called a fraternal twin.
Generator Expressions: Iterables Meet Comprehensions
Because the delayed evaluation of generator functions was so useful, later
Pythons eventually combined the notions of iterables and comprehensions in a
new tool: generator expressions. Syntactically, generator expressions are just
like normal list comprehensions, and support all their syntax—including if
filters and for loop nesting—but they are enclosed in parentheses instead of
```
[^391]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Closure** *(p.779)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.779, lines 20–27)*:
```
set and dictionary comprehensions we met earlier in Chapter 14 and Part II. For
reference and closure, here’s a summary of all the comprehension forms in
Python:
>>> [x * x for x in range(10)]               # List comprehension: builds list
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]         # Fixed order, made all at once
>>> (x * x for x in range(10))               # Generator expression: yields items
<generator object <genexpr> at 0x100a1f920>
>>> {x * x for x in range(10)}               # Set comprehension: builds set
```
[^392]
**Annotation:** This excerpt demonstrates 'closure' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Compiled** *(p.757)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.757, lines 14–21)*:
```
difference can vary per usage and Python, but is due to the fact that map and list
comprehensions run at compiled-language speed inside the interpreter, which is
generally faster than running for loop bytecode within the PVM.
Also in the plus column, list comprehensions offer a code conciseness that’s
compelling and even warranted when that reduction in size doesn’t also imply a
reduction in meaning for the next programmer; many find the expressiveness of
comprehensions to be a powerful ally; and because map and list comprehensions
are both expressions, they also can show up syntactically in places that for loop
```
[^393]
**Annotation:** This excerpt demonstrates 'compiled' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Comprehension** *(p.757)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.757, lines 1–8)*:
```
world, programming is not about being clever and obscure—it’s about how
clearly your program communicates its purpose. Writing tricky comprehensions
may be a fun academic recreation, but it doesn’t work in programs that others
will someday need to understand.
In other words, the age-old acronym KISS applies here as always: Keep It
Simple—traditionally followed either by a word that is now too sexist, or
another that is too colorful for a G-rated book like this. If you have to translate
code to simpler statements to understand it, it should probably be simpler
```
[^394]
**Annotation:** This excerpt demonstrates 'comprehension' as it appears in the primary text. The concept occurs 9 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Continue** *(p.759)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.759, lines 24–31)*:
```
state to enable the function to resume from where it left off. When resumed, the
function continues execution immediately after the last yield run. From the
function’s perspective, this allows its code to produce a series of values over
time, rather than computing them all at once and sending them back in
something like a list.
Iteration protocol integration
To truly understand generator functions, you need to know that they are closely
bound up with the notion of the iteration protocol in Python. As we’ve seen,
```
[^395]
**Annotation:** This excerpt demonstrates 'continue' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Coroutine** *(p.765)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.765, lines 6–13)*:
```
Together with send, these are advanced features added to make generators more
like a tool called coroutines, a role eventually subsumed in part by the upcoming
async. Hence, we won’t delve further here; see Python’s standard manuals for
more information, and watch for more on exceptions in Part VII.
Note, though, that while Python provides a next(X) convenience built-in that
calls the X.__next__() method of an object, other generator methods, like send,
must be called as methods of generator objects directly (e.g., G.send(X)). This
makes sense if you realize that these extra methods are implemented on built-in
```
[^396]
**Annotation:** This excerpt demonstrates 'coroutine' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 22: Module Coding Basics** *(pp.786–820)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^397]

**Annotation:** Forward reference: Chapter 22 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 23: Module Packages** *(pp.821–850)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^398]

**Annotation:** Forward reference: Chapter 23 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 24: Advanced Module Topics** *(pp.851–885)*

This later chapter builds upon the concepts introduced here, particularly: None, argument, as.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^399]

**Annotation:** Forward reference: Chapter 24 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, argument appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 22: Module Coding Basics

*Source: Learning Python, 6th Edition, pages 786–820*

### Chapter Summary
This chapter covers module coding basics. Key topics include generator, sequence, and coroutine. Covers function, generator, comprehension. [^400]

### Concept-by-Concept Breakdown
#### **None** *(p.796)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.796, lines 6–13)*:
```
   return res
def mymapPad(*seqs, pad=None):
   seqs = [list(S) for S in seqs]
   res  = []
   while any(seqs):
       res.append(tuple((S.pop(0) if S else pad) for S in seqs))
   return res
S1, S2 = 'abc', 'xyz123'
```
[^401]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Pythonpath** *(p.787)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.787, lines 16–23)*:
```
package has already done the former). Alternatively, you can modify the module
import search path’s PYTHONPATH setting to include any folder—as you’ll learn
when we cover modules in full after the next chapter.
Permutating Sequences
Generators have many other real-world applications—consider parsing
attachments in an email message or computing points to be plotted in a GUI.
Moreover, other types of sequence scrambles serve central roles in other
applications, from searches to mathematics. As is, our sequence scrambler of the
```
[^402]
**Annotation:** This excerpt demonstrates 'PYTHONPATH' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Enter__** *(p.807)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.807, lines 18–25)*:
```
__aexit__ methods, the same way that the normal with statement calls the
context-manager protocol’s __enter__ and __exit__.
Having said that, we unfortunately won’t study either the normal with or its
method protocols until Part VII, because they require knowledge of classes and
OOP (yet again, Python’s toolset assumes you must already know Python to use
Python!), so you’ll have to take this on faith for now. In the following code,
though, it’s enough to know that using a TaskGroup asynchronous context
manager in concert with async with will automatically await results from all of
```
[^403]
**Annotation:** This excerpt demonstrates '__enter__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Exit__** *(p.807)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.807, lines 18–25)*:
```
__aexit__ methods, the same way that the normal with statement calls the
context-manager protocol’s __enter__ and __exit__.
Having said that, we unfortunately won’t study either the normal with or its
method protocols until Part VII, because they require knowledge of classes and
OOP (yet again, Python’s toolset assumes you must already know Python to use
Python!), so you’ll have to take this on faith for now. In the following code,
though, it’s enough to know that using a TaskGroup asynchronous context
manager in concert with async with will automatically await results from all of
```
[^404]
**Annotation:** This excerpt demonstrates '__exit__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Args** *(p.819)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.819, lines 7–14)*:
```
timer = time.perf_counter                         # See also time.process_time()
def once(func, *pargs, **kargs):                  # Collect arguments for func
   """
   Time to run func(...) one time.
   Returns (time, result).
   """
   start   = timer()
   result  = func(*pargs, **kargs)               # Unpack arguments for func
```
[^405]
**Annotation:** This excerpt demonstrates 'args' as it appears in the primary text. The concept occurs 16 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.820)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.820, lines 3–10)*:
```
The repetitions count is no longer hardcoded, but passed in as a required
argument (or arguments) before the test function and its own arguments,
to allow repetitions to vary per call.
The range call’s construction and iteration costs are no longer charged
to timed functions, because timing has been factored out to the separate
once function that times just the subject function.
Any number of both positional and keyword arguments for the timed
function are now collected and unpacked with starred-argument syntax.
```
[^406]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 7 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.802)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.802, lines 1–8)*:
```
The async def syntax is always required for functions that use await, as well
as aync for and async with demoed ahead. Because async def is required to
both use and define awaitable coroutines, it tends to spread viruslike throughout
code (in fact, some tools now come with libraries in two separate forms,
asynchronous and not).
Also in the following, producer uses await to suspend itself until the sleep
expires. await is similar to a yield from, but the event loop is free to pause the
coroutine running the await and resume another if the awaited result is not
```
[^407]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 37 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Async** *(p.808)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.808, lines 1–8)*:
```
async with asyncio.TaskGroup() as tg:
        tasks = [tg.create_task(producer(f'async task {i+1}')) for i in range(3)]
    for task in tasks:
        print(task.result())
    print('Stop  at', now())
asyncio.run(main())
The net effect runs all three producer calls concurrently in two seconds as
before:
```
[^408]
**Annotation:** This excerpt demonstrates 'async' as it appears in the primary text. The concept occurs 19 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Asyncio** *(p.802)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.802, lines 12–19)*:
```
async def producer(label):                     # await requires async
    await asyncio.sleep(2)                     # Call nonblocking/awaitable sleep
    return f'All done, {label}, {now()}'       # Result of await expression
async def main():
    print('Start =>', now())
    task1 = asyncio.create_task(producer(f'async task 1'))
    task2 = asyncio.create_task(producer(f'async task 2'))
    task3 = asyncio.create_task(producer(f'async task 3'))
```
[^409]
**Annotation:** This excerpt demonstrates 'asyncio' as it appears in the primary text. The concept occurs 7 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Await** *(p.802)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.802, lines 1–8)*:
```
The async def syntax is always required for functions that use await, as well
as aync for and async with demoed ahead. Because async def is required to
both use and define awaitable coroutines, it tends to spread viruslike throughout
code (in fact, some tools now come with libraries in two separate forms,
asynchronous and not).
Also in the following, producer uses await to suspend itself until the sleep
expires. await is similar to a yield from, but the event loop is free to pause the
coroutine running the await and resume another if the awaited result is not
```
[^410]
**Annotation:** This excerpt demonstrates 'await' as it appears in the primary text. The concept occurs 20 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.815)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.815, lines 8–9)*:
```
generators no longer propagate exit exceptions from code they run; and
Python mods can and do break code—both subtly and repeatedly!
```
[^411]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.792)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.792, lines 24–31)*:
```
expressions. As you’ll see in Part VI, value generation can also be coded as
iterable objects with classes. Class-based iterables can produce items on request
too, and are more explicit than the magic objects and methods produced for
generator functions and expressions.
Part of programming is finding a balance among trade-offs like these, and there
are no absolute rules here. While the benefits of generators may sometimes
justify their use, maintainability counts too. Like comprehensions, generators
also offer an expressiveness and code economy that’s hard to resist if you
```
[^412]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.816)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.816, lines 3–10)*:
```
Now that we’ve fully explored function coding and iteration tools, we’re going
to take a short side trip to put both of them to work. This chapter closes out the
function part of this book with a larger case study that times the relative
performance of the iteration tools we’ve met so far, in both standard Python and
one of its alternatives.
Along the way, this case study surveys Python’s code-timing tools, discusses
benchmarking techniques in general, and develops code that’s more realistic and
useful than most of what we’ve seen up to this point. We’ll also measure the
```
[^413]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Collections** *(p.820)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.820, lines 11–18)*:
```
They must be sent individually, not in a sequence or dictionary, though
callers can unpack argument collections into individual arguments with
stars in the top-level call.
All functions in this module return one of the timed function’s return
values so callers can verify that the function worked. The return value is
provided in a two-item result tuple, along with the requested time result.
New best-of modes return minimum times to address fluctuations on the
host device, per the next paragraph.
```
[^414]
**Annotation:** This excerpt demonstrates 'collections' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Compiled** *(p.800)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.800, lines 5–12)*:
```
Like the yield and yield from that this model extend, async def causes a
function to be compiled specially: when called, instead of running its body, such
a function returns an awaitable object that supports an expected method-based
protocol.
To invoke this object, functions await results explicitly, or use an async for or
async with that does so implicitly. Moreover, an event loop must be launched
to run the show at large. Although the event loop runs just one task at a time
(they’re not truly parallel), it can switch to other tasks when a task runs an await
```
[^415]
**Annotation:** This excerpt demonstrates 'compiled' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 23: Module Packages** *(pp.821–850)*

This later chapter builds upon the concepts introduced here, particularly: None, args, argument.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^416]

**Annotation:** Forward reference: Chapter 23 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, args appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 24: Advanced Module Topics** *(pp.851–885)*

This later chapter builds upon the concepts introduced here, particularly: None, PYTHONPATH, args.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^417]

**Annotation:** Forward reference: Chapter 24 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, PYTHONPATH appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 25: Debugging and Testing** *(pp.886–920)*

This later chapter builds upon the concepts introduced here, particularly: None, PYTHONPATH, argument.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^418]

**Annotation:** Forward reference: Chapter 25 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, PYTHONPATH appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 23: Module Packages

*Source: Learning Python, 6th Edition, pages 821–850*

### Chapter Summary
This chapter covers module packages. Key topics include module, generator, and list comprehensions. Covers function, loop, module. [^419]

### Concept-by-Concept Breakdown
#### **None** *(p.849)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.849, lines 1–8)*:
```
>>> print(x)
None
Functions such as this without a return are Python’s equivalent of what are
called “procedures” in some languages. They’re usually invoked as statements,
and the None results are ignored, as they do their business without computing a
useful result.
This is worth remembering, because Python won’t tell you if you try to use the
result of a function that doesn’t return one. As we noted in Chapter 11, for
```
[^420]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Main__** *(p.845)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.845, lines 29–33)*:
```
>>> def selector():
        import __main__         # Import enclosing module
        print(__main__.X)       # Qualify to get to global version of name
        X = 88                  # Unqualified X classified as local
        print(X)                # Prints local version of name
```
[^421]
**Annotation:** This excerpt demonstrates '__main__' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Name__** *(p.822)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.822, lines 23–30)*:
```
       results.append(result)
       print(f'{test.__name__:<9}: '
             f'{besttime:.5f} => [{result[0]}…{result[-1]}]')
   # Verify
   print('Results differ!'
          if any(result != results[0] for result in results[1:])
          else 'All results same.')
Fine points here: this module’s runner function displays context with sys tools
```
[^422]
**Annotation:** This excerpt demonstrates '__name__' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Args** *(p.829)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.829, lines 20–27)*:
```
timer = time.perf_counter
def once(func, /, *pargs, **kargs):
   start   = timer()
   result  = func(*pargs, **kargs)
   elapsed = timer() - start
   return (elapsed, result)
def total(func, /, *pargs, _reps=100_000, **kargs):
   total = 0
```
[^423]
**Annotation:** This excerpt demonstrates 'args' as it appears in the primary text. The concept occurs 14 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.829)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.829, lines 6–13)*:
```
Most obviously, its functions require passing in repetition counts as first
arguments, and provide no defaults for them—a minor point, perhaps, but less
than ideal in a general-purpose tool. To do better, it could allow repetition counts
to be passed in as keyword arguments with defaults, much the same way we did
for the print emulators of Chapter 18.
Here, though, these arguments’ names would have to be distinct to avoid
clashing with those of the timed function (e.g., _reps instead of reps). While
we’re at it, the function object could also be a positional-only argument to
```
[^424]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 7 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.845)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.845, lines 1–8)*:
```
a value
You get the name-usage error shown here, but the reason is subtle. Python reads
and compiles this code when it’s typed interactively or imported from a module.
While compiling, Python sees the assignment to X and decides that X will be a
local name everywhere in the function. But when the function is actually run,
because the assignment hasn’t yet happened when the print executes, Python
says you’re using an undefined name. According to its name rules, it should say
this; the local X is used before being assigned. In fact, any assignment in a
```
[^425]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 16 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.822)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.822, lines 31–33)*:
```
documented in Python’s manuals, and steps through all the passed-in functions,
printing the __name__ of each (as we’ve seen, this is a built-in attribute that
gives a function’s name). The test-runner code also saves results to verify that
```
[^426]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.832)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.832, lines 15–22)*:
```
strings; the latter can hold multiple statements if they use ; separators or \n
characters for line breaks, and spaces or tabs to indent statements in nested
blocks (e.g., \n\t). Tests may also give setup actions, and can be launched from
both command lines and API calls, and from both scripts and the REPL.
API-calls mode
For example, the timeit module’s repeat call returns a list giving the total time
taken to run a test a number of times, for each of repeat runs—the min of this
list yields the best time among the runs, and helps filter out system load
```
[^427]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.844)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.844, lines 9–16)*:
```
Local Names Are Detected Statically
As you’ve learned, Python classifies names assigned in a function as locals by
default; they live in the function’s scope and exist only while the function is
running. What you may not realize is that Python detects locals statically, when
it compiles the def’s code, rather than by noticing assignments as they happen at
runtime. This leads to one of the most common oddities posted on the Python
newsgroup by beginners.
Normally, a name that isn’t assigned in a function is looked up in the enclosing
```
[^428]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.833)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.833, lines 29–33)*:
```
quotes, and escapes. For instance, a code string cannot embed the same quotes
used to enclose it without also escaping them. You can avoid this potential
downside by timing callables, though they’re limited to zero arguments.
Command-line mode
The timeit module also can be run as a script from a command line—either by
```
[^429]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Closure** *(p.847)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.847, lines 7–14)*:
```
they run into it. There are better ways to retain state between calls in Python
(e.g., using the nested scope closures and function attributes we met in this part,
and the classes we will study in Part VI).
Moreover, mutable defaults can be overridden by real values, and are tricky to
remember (and to understand at all). They depend upon the timing of default
object construction. In the prior example, there is just one list object for the
default value—the one created when the def is executed. You don’t get a new
list every time the function is called, so the list grows with each new append; it
```
[^430]
**Annotation:** This excerpt demonstrates 'closure' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Compiled** *(p.825)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.825, lines 11–18)*:
```
PyPy is roughly 5X quicker than CPython here (and up to 10X), though its
timing results can vary widely if its JIT has not yet compiled code in full (and a
future and currently hypothetical CPython JIT may or may not even the race):
$ pypy3 timer_tests.py 
Python 3.10.14 on darwin
forLoop  : 0.04329 => [0...9999]
listComp : 0.01876 => [0...9999]
mapCall  : 0.04132 => [0...9999]
```
[^431]
**Annotation:** This excerpt demonstrates 'compiled' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Comprehension** *(p.824)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.824, lines 22–29)*:
```
All results same.
In short, map calls are faster than list comprehensions, which are quicker than
for loops, and both generator expressions and functions come in last and
roughly tied for slowest. Perhaps surprisingly, generator expressions run much
slower than equivalent list comprehensions today. As warned in the prior
chapter, although wrapping a generator expression in a list call makes it
functionally equivalent to a list comprehension, the internal implementations of
the two expressions appear to differ:
```
[^432]
**Annotation:** This excerpt demonstrates 'comprehension' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Decorator** *(p.831)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.831, lines 23–30)*:
```
NOTE
Decorator timers preview: Notice how we must pass functions into the timers manually here.
In Chapter 39, we’ll code decorator-based timer alternatives with which timed functions are
called normally, but require extra @ preamble syntax where defined. Decorators may be more
useful to instrument functions with timing logic when they are already being used within a
larger system, and don’t as easily support the specific test-call patterns assumed here—when
decorated, every call to the function runs the timing logic, which is either a plus or minus
depending on your goals.
```
[^433]
**Annotation:** This excerpt demonstrates 'decorator' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Def** *(p.846)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.846, lines 10–17)*:
```
general, though.
Defaults and Mutable Objects
As noted briefly in Chapters 17 and 18, mutable values for default arguments
can retain state between calls, though this is often unexpected. In general, default
argument values are evaluated and saved once when a def statement is run, not
each time the resulting function is later called. Internally, Python saves one
object per default argument, attached to the function itself.
That’s usually what you want—because defaults are evaluated at def time, they
```
[^434]
**Annotation:** This excerpt demonstrates 'def' as it appears in the primary text. The concept occurs 14 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 24: Advanced Module Topics** *(pp.851–885)*

This later chapter builds upon the concepts introduced here, particularly: None, __main__, __name__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^435]

**Annotation:** Forward reference: Chapter 24 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __main__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 25: Debugging and Testing** *(pp.886–920)*

This later chapter builds upon the concepts introduced here, particularly: None, __main__, __name__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^436]

**Annotation:** Forward reference: Chapter 25 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __main__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 26: OOP: The Big Picture** *(pp.921–945)*

This later chapter builds upon the concepts introduced here, particularly: None, __main__, __name__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^437]

**Annotation:** Forward reference: Chapter 26 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __main__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 24: Advanced Module Topics

*Source: Learning Python, 6th Edition, pages 851–885*

### Chapter Summary
Chapter Summary
This chapter rounded out our look at functions and built-in iteration tools with a
larger case study that measured the performance of iteration alternatives and
other tools we’ve met along the way, as well as one alternative Python
implementation Key topics include modules, packages, and namespaces. Covers module, function. [^438]

### Concept-by-Concept Breakdown
#### **None** *(p.857)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.857, lines 8–15)*:
```
12. Computing factorials: Finally, a computer-science classic (but
demonstrative nonetheless). We employed the notion of factorials in
Chapter 20’s coverage of permutations: N!, computed as N*(N-1)*(N-
2)*...1. For instance, 6! is 6*5*4*3*2*1, or 720. Code and time four
functions that, for a call fact(N), each return N!. Code these four
functions (1) as a recursive countdown per Chapter 19; (2) using the
functional reduce call per Chapter 19; (3) with a simple iterative
counter loop per Chapter 13; and (4) using the math.factorial library
```
[^439]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Pythonpath** *(p.873)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.873, lines 24–31)*:
```
module search path. Module imports and file access are disjoint ideas.
Any PYTHONPATH directories (configurable)
Next, Python searches all directories listed in your PYTHONPATH environment
variable setting, from left to right (assuming you have set this at all: it’s not
generally preset for you). In brief, PYTHONPATH is simply a list of user-
defined and platform-specific names of directories that contain Python
source code or bytecode files. You can add all the directories from which you
wish to be able to import, and Python will extend the module search path to
```
[^440]
**Annotation:** This excerpt demonstrates 'PYTHONPATH' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Main__** *(p.859)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.859, lines 13–20)*:
```
__name__ and __all__ attributes, package imports, relative import syntax,
namespace packages, the __getattr__ hook, the __main__.py file, and so on.
Because modules and classes are really just glorified namespaces, this part
formalizes namespace concepts as well.
Module Essentials
In simple and concrete terms, modules typically correspond to Python source
code files. Each file of code is a module automatically, and modules import other
modules to use the names they define. Modules might also correspond to
```
[^441]
**Annotation:** This excerpt demonstrates '__main__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Name__** *(p.859)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.859, lines 12–19)*:
```
also flesh out module fine points omitted so far—you’ll learn about reloads, the
__name__ and __all__ attributes, package imports, relative import syntax,
namespace packages, the __getattr__ hook, the __main__.py file, and so on.
Because modules and classes are really just glorified namespaces, this part
formalizes namespace concepts as well.
Module Essentials
In simple and concrete terms, modules typically correspond to Python source
code files. Each file of code is a module automatically, and modules import other
```
[^442]
**Annotation:** This excerpt demonstrates '__name__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Args** *(p.854)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.854, lines 30–31)*:
```
functions (either interactively or in a module file that can be imported):
def f1(a, b): print(a, b)            # Normal args
```
[^443]
**Annotation:** This excerpt demonstrates 'args' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.853)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.853, lines 6–13)*:
```
1. The basics: At the Python interactive prompt, write a function named
echo that prints its single argument to the screen and call it
interactively, passing a variety of object types: string, integer, list,
dictionary. Then, try calling it without passing any argument. What
happens? What happens when you pass two arguments?
2. Arguments: Write a function called adder in a Python module file
named adder1.py. The function should accept two arguments and return
the sum (or concatenation) of the two. Then, add code at the bottom of
```
[^444]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 11 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.852)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.852, lines 4–11)*:
```
seem always quickest, perhaps due to function-level optimizations.
At least that’s the case today on the Python versions tested, on the test
machine used, and for the type of code timed—these results may vary if
any of these three variables differ. Use the homegrown timer or
standard library timeit to test your use cases for more relevant results.
Also keep in mind that iteration is just one component of a program’s
time: more code gives a more complete picture.
2. In general, PyPy 7.3 (implementing Python 3.10) is substantially faster
```
[^445]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 13 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.864)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.864, lines 6–13)*:
```
Load the file b.py (unless it’s already loaded), and give me access to all its
attributes through the name b.
To satisfy such goals, import (and, as you’ll see later, from) statements execute
and load other files on request. More formally, in Python, cross-file module
linking is not resolved until such import statements are executed at runtime;
their net effect is to assign module names—simple variables like b—to loaded
module objects. In fact, the module name used in an import statement serves
two purposes: it identifies the external file to be loaded (by base name b here),
```
[^446]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 6 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.856)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.856, lines 1–8)*:
```
print(num, 'has factor', x)
        break                             # Exit now and skip else
    x -= 1
else:                                     # Normal exit, when x reaches 1
    print(num, 'is prime')
Package this code as a reusable function in a module file (num should be
a passed-in argument), and add some calls to the function at the bottom
of your file to test. While you’re at it, experiment with replacing the
```
[^447]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Bytecode** *(p.868)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.868, lines 1–8)*:
```
When you first import a module, Python compiles the module’s .py source code
file to bytecode, and saves the bytecode in a file with a .pyc extension if
possible. On later program runs, Python will load the bytecode from its .pyc file
and skip the compile step, as long as the bytecode file uses a compatible format
and was made by the importing Python, and you have not edited and saved the
source code file since the bytecode file was made.
Importantly, if you change a module’s source code, its bytecode file will be re-
created the next time you run a program that imports the module. This ensures
```
[^448]
**Annotation:** This excerpt demonstrates 'bytecode' as it appears in the primary text. The concept occurs 16 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.851)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.851, lines 10–17)*:
```
organizational unit in Python programs, and the structure in which functions
reside. After that, we will explore classes, which are largely packages of
functions with special first arguments. As you’ll see, classes can implement
objects that tap into the iteration protocol, just like the generators and iterables
we used here. In fact, everything we have learned in this part of the book will
apply when functions take the guise of class methods.
Before moving on to modules, though, be sure to work through this chapter’s
quiz, as well as the exercises for this part of the book, to practice what you’ve
```
[^449]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class Method** *(p.851)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.851, lines 14–21)*:
```
we used here. In fact, everything we have learned in this part of the book will
apply when functions take the guise of class methods.
Before moving on to modules, though, be sure to work through this chapter’s
quiz, as well as the exercises for this part of the book, to practice what you’ve
learned about functions here.
Test Your Knowledge: Quiz
1. What conclusions can you draw from this chapter about the relative
speed of Python iteration tools?
```
[^450]
**Annotation:** This excerpt demonstrates 'class method' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.861)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.861, lines 19–24)*:
```
feature—everything “lives” in a module. Because both the code you run and
the objects you create are always implicitly enclosed in modules, modules
group components by nature.
At least that’s the abstract story. To truly understand the role of modules in a
Python system, we need to digress for a moment and explore the general
structure of a Python program.
```
[^451]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Compiled** *(p.879)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.879, lines 8–15)*:
```
Really, imports are the point of interface to a host of external components—
source code, bytecode, compiled extensions, ZIP files, Java classes, and more.
Python automatically selects any type that matches a module’s name. For
example, an import statement of the form import b might today load or resolve
to any of the following:
A source code file named b.py
A bytecode file in __pycache__ named b.cpython-312.pyc or similar
A bytecode file named b.pyc if no b.py source code file was located
```
[^452]
**Annotation:** This excerpt demonstrates 'compiled' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Comprehension** *(p.851)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.851, lines 24–27)*:
```
Test Your Knowledge: Answers
1. In CPython today, list comprehensions are often the quickest of the
bunch; map beats list comprehensions in Python when all tools must call
built-in functions; for loops tend to be slower than comprehensions;
```
[^453]
**Annotation:** This excerpt demonstrates 'comprehension' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 25: Debugging and Testing** *(pp.886–920)*

This later chapter builds upon the concepts introduced here, particularly: None, PYTHONPATH, __main__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^454]

**Annotation:** Forward reference: Chapter 25 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, PYTHONPATH appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 26: OOP: The Big Picture** *(pp.921–945)*

This later chapter builds upon the concepts introduced here, particularly: None, PYTHONPATH, __main__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^455]

**Annotation:** Forward reference: Chapter 26 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, PYTHONPATH appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 27: Class Coding Basics** *(pp.946–985)*

This later chapter builds upon the concepts introduced here, particularly: None, PYTHONPATH, __main__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^456]

**Annotation:** Forward reference: Chapter 27 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, PYTHONPATH appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 25: Debugging and Testing

*Source: Learning Python, 6th Edition, pages 886–920*

### Chapter Summary
This chapter covers debugging and testing. Key topics include module, packages, and namespace. Covers module, statement. [^457]

### Concept-by-Concept Breakdown
#### **None** *(p.912)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.912, lines 4–11)*:
```
or the container of a launched program’s top-level file), along with the standard
library’s containers, and the site-packages third-party install root. While none of
these components require search-path mods, your module search path must
include all the directories containing leftmost components in your code’s
package-import statements.
Creating Packages
To make packages of your own, you’ll bundle module files and nested folders in
a package folder. A package folder can also optionally contain an __init__.py file
```
[^458]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Pythonpath** *(p.911)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.911, lines 22–29)*:
```
But you can add a path like C:\Users\me\mycode or /Users/me/mycode to either
your PYTHONPATH environment variable, a strategically placed .pth file, or
sys.path itself in manual code, and then say this in your script:
import dir1.dir2.mod                         # OK: variables and periods
In effect, entries on the module search path provide platform-specific directory
prefixes, which lead to the leftmost names of package paths in import and from
statements. These import statements themselves provide the remainder of the
directory path in a platform-neutral fashion.
```
[^459]
**Annotation:** This excerpt demonstrates 'PYTHONPATH' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Init__** *(p.916)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.916, lines 1–8)*:
```
Using the updated package
These special __init__.py files are optional in each folder of a package. Because
they are run on the first import of or through a folder level, though, they provide
a natural hook for kicking off package-specific initializations (hence their
abbreviated names). In fact, their assignments serve to initialize the namespace
that corresponds to a folder on your device—as for files, they create attributes of
the package’s module object:
$ python3
```
[^460]
**Annotation:** This excerpt demonstrates '__init__' as it appears in the primary text. The concept occurs 12 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Main__** *(p.918)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.918, lines 1–8)*:
```
$ python3 dir1                           # Runs __main__.py (not __init__.py)
Executing dir1.__main__.py
$ python3 dir1/dir2
Executing dir1.dir2.__main__.py
$ python3 dir1/dir2/mod.py               # Runs nested mod.py
Loading dir1.dir2.mod
Package __main__.py files are also run for the Python -m mode, which, as we’ve
seen, locates an item on the module search path and runs it as a top-level script.
```
[^461]
**Annotation:** This excerpt demonstrates '__main__' as it appears in the primary text. The concept occurs 11 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Name__** *(p.896)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.896, lines 12–19)*:
```
>>> spaces.__dict__.keys()
dict_keys(['__name__', '__doc__', '__package__', '__loader__', '__spec__', 
'__file__', '__cached__', '__builtins__', 'sys', 'var', 'func', 'klass'])
The names we assigned in the module file become dictionary keys internally, so
some of the keys here reflect top-level assignments in our file. The value of var,
for example, can be had two ways (though the first is normal):
>>> spaces.var, spaces.__dict__['var']
(23, 23)
```
[^462]
**Annotation:** This excerpt demonstrates '__name__' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.889)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.889, lines 9–16)*:
```
access, too. For instance, names copied with a from become references to shared
objects; much like function arguments, reassigning a copied name has no effect
on the module from which it was copied, but changing a shared mutable object
through a copied name can also change it in the module from which it was
imported. Consider the following file, share.py, in Example 23-3.
Example 23-3. share.py
x = 1
y = [1, 2]
```
[^463]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.892)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.892, lines 2–9)*:
```
must always go through a module’s name to get to its contents: module.attr
will not clash with a variable named attr in your scope. As long as you
understand that this can happen when using from, though, this isn’t a concern in
practice: assigning a variable with from has the same effect as any other
assignment in your code.
On the other hand, the from statement has legitimate issues when used in
conjunction with the reload call, as imported names might reference prior
versions of objects. Moreover, the from * form really can trash namespaces and
```
[^464]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 14 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.897)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.897, lines 13–20)*:
```
See Chapter 7 for other vars roles. You’ll see similar __dict__ dictionaries on
class-related objects in Part VI too. In all cases, attribute fetch is similar to
dictionary indexing, though only the former kicks off inheritance in classes.
Attribute Name Qualification
Speaking of attribute fetch, now that you’re becoming more familiar with
modules, we should firm up the notion of name qualification more formally too.
In Python, you can access the attributes of any object that has attributes using the
qualification (a.k.a. attribute fetch) syntax object.attribute.
```
[^465]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 9 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.907)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.907, lines 12–19)*:
```
directory path leading to the desired module. As you’ll find, package imports
give us a hierarchy that is useful in larger systems and allow us to break conflicts
between same-named modules. Before we move on, though, here’s a quick quiz
on the concepts presented here.
Test Your Knowledge: Quiz
1. How do you make a module?
2. How is the from statement related to the import statement?
3. How is the reload function related to imports?
```
[^466]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Bytecode** *(p.891)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.891, lines 16–23)*:
```
of how many names it copies out of the file. There is no way to load just part of
a module file (e.g., just one function), but because modules are bytecode in
standard Python instead of machine code, the performance implications are
generally negligible.
Potential Pitfalls of the from Statement
One downside of the from statement is that it makes the meaning of a variable
more obscure: name is less useful to the reader than module.name, and may
require a search for the from that loaded it. Because of this, some Python users
```
[^467]
**Annotation:** This excerpt demonstrates 'bytecode' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.894)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.894, lines 5–12)*:
```
happen? The short answer is that every name that is assigned a value at the top
level of a module file (i.e., not nested in a function or class body) becomes an
attribute of that module.
For instance, given an assignment statement such as X = 1 at the top level of a
module file M.py, the name X becomes an attribute of M, which we can refer to
from outside the module as M.X. The name X also becomes a global variable to
other code inside M.py, but we need to firm up the relationship of module
loading and scopes to understand why:
```
[^468]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Collections** *(p.909)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.909, lines 5–12)*:
```
though, is richer than implied up to this point. This chapter extends it to present
module packages—collections of module files that normally correspond to
folders (a.k.a. directories) on your device. It covers four topics:
Package imports, which give part of a folder path leading to a file
Packages themselves, which organize modules into folder bundles
Package-relative imports, which use dots within a package to limit
search
Namespace packages, which build a package that may span multiple
```
[^469]
**Annotation:** This excerpt demonstrates 'collections' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Compiled** *(p.902)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.902, lines 20–27)*:
```
One note here: our use of reload in this book is limited to modules written in
Python. Compiled extension modules coded in a language such as C can be
dynamically loaded by imports at runtime, too, but they are out of scope here
(though most users probably prefer to code customizations in Python anyhow!).
reload Basics
Unlike import and from:
reload is a function in Python, not a statement.
reload is passed an existing module object, not a string name.
```
[^470]
**Annotation:** This excerpt demonstrates 'compiled' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Debugging** *(p.902)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.902, lines 12–19)*:
```
customizations can be tested immediately after reloads, you need to connect only
once while debugging. Long-running servers can update themselves this way,
too.
Because Python is interpreted (more or less), it already gets rid of the
compile/link steps you need to go through to get a C program to run: modules
are loaded dynamically when imported by a running program. Reloading offers a
further performance advantage by allowing you to also change parts of running
programs without stopping.
```
[^471]
**Annotation:** This excerpt demonstrates 'debugging' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Def** *(p.892)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.892, lines 12–19)*:
```
searching external files. In effect, the from * form collapses one namespace into
another, and so defeats the namespace partitioning purpose of modules. We’ll
save demos of these issues for “Module Gotchas” (at the end of this part of the
book), and meet tools that can minimize the from * damage with data hiding in
Chapter 25.
Probably the best real-world advice here is to generally prefer import to from
for simple modules; to explicitly list the variables you want in most from
statements; and to limit the from * form to just one per file, or the REPL’s
```
[^472]
**Annotation:** This excerpt demonstrates 'def' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 26: OOP: The Big Picture** *(pp.921–945)*

This later chapter builds upon the concepts introduced here, particularly: None, PYTHONPATH, __init__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^473]

**Annotation:** Forward reference: Chapter 26 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, PYTHONPATH appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 27: Class Coding Basics** *(pp.946–985)*

This later chapter builds upon the concepts introduced here, particularly: None, PYTHONPATH, __init__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^474]

**Annotation:** Forward reference: Chapter 27 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, PYTHONPATH appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 28: A More Realistic Example** *(pp.986–1020)*

This later chapter builds upon the concepts introduced here, particularly: None, __init__, __main__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^475]

**Annotation:** Forward reference: Chapter 28 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __init__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 26: OOP: The Big Picture

*Source: Learning Python, 6th Edition, pages 921–945*

### Chapter Summary
This chapter covers oop: the big picture. Key topics include packages, module, and namespace. Covers module. [^476]

### Concept-by-Concept Breakdown
#### **None** *(p.934)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.934, lines 26–29)*:
```
directories collected at import time. Because the presence of __init__.py
differentiates package type, none of the directories that make up a namespace
package can have this file, but the content nested within each of them is treated
as a single composite package.
```
[^477]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Pythonpath** *(p.921)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.921, lines 9–16)*:
```
You could try changing sys.path within your script before each import
operation, but that’s both extra work and error-prone. And changing PYTHONPATH
before each Python program run is too tedious, and won’t allow you to use both
versions in a single file in an event. By default, you’re stuck.
This is the issue that packages actually fix. Rather than installing programs in
independent directories listed on the module search path directly and
individually, you can package and install them as subdirectories under a
common root. For instance, you might organize all the code in this example as
```
[^478]
**Annotation:** This excerpt demonstrates 'PYTHONPATH' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Init__** *(p.923)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.923, lines 3–10)*:
```
you, but the next few sections dig deeper for if and when you opt-in.
The Roles of __init__.py Files
Now that we’ve seen the basics and addressed the why of packages, let’s explore
some of the details behind their usage. The __init__.py files in our opening demo
were simple, but these files can contain arbitrary Python code, just like normal
module files. Their names are special because their code is run automatically the
first time a Python program imports a directory, and thus serves primarily as a
hook for performing initialization steps required by the package. These files can
```
[^479]
**Annotation:** This excerpt demonstrates '__init__' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Main__** *(p.929)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.929, lines 2–9)*:
```
Loading dir1.mod
Executing dir1.__main__.py: HACK
$ python3 dir1/__main__.py                  # As folder bundle or explicit file
Loading dir1.mod
Executing dir1.__main__.py: HACK
$ python3 -m dir1                           # Launch with Python -m module switch
Running dir1.__init__.py
ModuleNotFoundError: No module named 'mod'
```
[^480]
**Annotation:** This excerpt demonstrates '__main__' as it appears in the primary text. The concept occurs 12 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Name__** *(p.944)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.944, lines 3–10)*:
```
This chapter concludes this part of the book with an assortment of module-
related topics—data hiding, the __future__ module, the __name__ variable,
name-string imports, the __gettattr__ hook, transitive reloads, and more—
along with the usual set of gotchas and exercises related to what we’ve covered
in this part of the book. Along the way, we’ll build some useful tools that
combine functions and modules. Like functions, modules are more effective
when their interfaces are well-defined, so this chapter also briefly reviews
module design concepts.
```
[^481]
**Annotation:** This excerpt demonstrates '__name__' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.945)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.945, lines 16–23)*:
```
of course, but you should try to communicate results through devices
such as function arguments and return values, not cross-module
changes. Otherwise, your globals’ values become dependent on the
order of arbitrarily remote assignments in other files, and your modules
become harder to understand and reuse.
As a summary, Figure 25-1 sketches the environment in which modules operate.
Modules contain variables, functions, and classes, and import other modules for
the tools they define. Functions have local variables of their own, as do classes
```
[^482]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.926)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.926, lines 1–8)*:
```
as package components, and only in from statements, not import:
from . import module           # Import a module in this package (only)
from .module import name       # Import a name from a module in this package
from .. import module          # Import a module sibling of the parent folder
from ..module import name      # Import a name from a parent-sibling module
This syntax wouldn’t make sense in import, because that statement assigns
modules to simple names, not paths. In a from, though, when the source of the
import begins with (or is only) dots like this, the import is known as relative—it
```
[^483]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 11 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.936)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.936, lines 9–16)*:
```
until a lower-level import occurs. The new namespace package is a module
object that does not have a __file__ attribute, but has a __path__ set to an
iterable of the directory path strings that were found and recorded during the
candidates scan by step 3.
This __path__ attribute is then used as the set of candidates for later and deeper
accesses, to search the one or more component folders of the namespace
package. That is, each recorded entry on a namespace package’s __path__ is
searched whenever further-nested items are requested, instead of the sole
```
[^484]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.927)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.927, lines 12–19)*:
```
This in turn makes the package more self-contained: without relative imports,
such an unrelated module might break the package’s code; with them, packages
are less reliant on client search-path settings that they cannot predict or control.
The downside is that this model is an all-or-nothing proposition. You essentially
must choose a mode for your files—package or program. Relative imports give
visibility to the package itself, but cannot be used in nonpackage mode, and
absolute imports can be used in nonpackage mode, but do not give visibility to
the package itself. This combination seems a catch-22 that limits your code’s
```
[^485]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.945)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.945, lines 3–10)*:
```
thumb, they should be as independent of global variables used within
other modules as possible, except for functions and classes imported
from them. The only things a module should share with the outside
world are the tools it uses, and the tools it defines.
Maximize module cohesion: unified purpose. Also like functions, you
can minimize a module’s couplings by maximizing its cohesion. If all
the components of a module share a general purpose, they’re less likely
to depend on external names.
```
[^486]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.941)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.941, lines 18–25)*:
```
attribute hook, and name-string imports, and codes useful module tools along the
way. As usual, though, let’s close out this chapter first with a short quiz to
review what you’ve learned here.
Test Your Knowledge: Quiz
1. What is the purpose of an __init__.py file in a module package
directory?
2. How can you avoid repeating the full package path every time you
reference a package’s content?
```
[^487]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Constructor** *(p.925)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.925, lines 13–20)*:
```
Classes conflation caution: As a preview, package __init__.py files are not the same as the
class __init__ constructor methods you’ll meet in the next part of this book. The former are
files of code run when imports first step through a package folder in a program run, while the
latter are functions called whenever an instance is created. Both have initialization roles and
are optional, but they are otherwise very different—despite their names.
Package-Relative Imports
The coverage of package imports so far has focused on importing package files
from outside the package. Within the package itself, imports of same-package
```
[^488]
**Annotation:** This excerpt demonstrates 'constructor' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Continue** *(p.936)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.936, lines 1–8)*:
```
3. If directory/name is found and is a directory, it is recorded and the
scan continues with the next directory in the search’s set of candidates.
4. If none of the above was found, the scan continues with the next
directory in the search’s set of candidates.
If this search’s candidate scan completes without returning a regular package or
module by steps 1 or 2, and at least one directory was recorded by step 3, then a
namespace package is created and returned. Else an error is reported.
The creation of the namespace package happens immediately and is not deferred
```
[^489]
**Annotation:** This excerpt demonstrates 'continue' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Def** *(p.945)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.945, lines 5–12)*:
```
from them. The only things a module should share with the outside
world are the tools it uses, and the tools it defines.
Maximize module cohesion: unified purpose. Also like functions, you
can minimize a module’s couplings by maximizing its cohesion. If all
the components of a module share a general purpose, they’re less likely
to depend on external names.
Modules should rarely change other modules’ variables. We
illustrated this with code in Chapter 17, but it’s worth repeating here:
```
[^490]
**Annotation:** This excerpt demonstrates 'def' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Else** *(p.921)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.921, lines 26–33)*:
```
        other.py
    mycode/                     # Here or elsewhere
        myfile.py               # Your new code here
Now, add just the common root directory to your search path. If your code’s
imports are all relative to this common root, you can import either system’s
utility file with a package import—the enclosing directory name makes the path
(and hence, the module reference) unique. In fact, you can import both utility
files in the same module, if you use an import statement and repeat the full path
```
[^491]
**Annotation:** This excerpt demonstrates 'else' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 27: Class Coding Basics** *(pp.946–985)*

This later chapter builds upon the concepts introduced here, particularly: None, PYTHONPATH, __init__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^492]

**Annotation:** Forward reference: Chapter 27 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, PYTHONPATH appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 28: A More Realistic Example** *(pp.986–1020)*

This later chapter builds upon the concepts introduced here, particularly: None, __init__, __main__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^493]

**Annotation:** Forward reference: Chapter 28 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __init__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 29: Class Coding Details** *(pp.1021–1060)*

This later chapter builds upon the concepts introduced here, particularly: None, __init__, __main__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^494]

**Annotation:** Forward reference: Chapter 29 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __init__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 27: Class Coding Basics

*Source: Learning Python, 6th Edition, pages 946–985*

### Chapter Summary
This chapter covers class coding basics. Key topics include module, package, and namespace. Covers module, function. [^495]

### Concept-by-Concept Breakdown
#### **None** *(p.949)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.949, lines 33–37)*:
```
(virtual hack) 'HACK'
>>> gamod.nonesuch         
AttributeError: nonesuch is undefined
>>> dir(gamod)
['code', 'hack', 'test', 'var']
```
[^496]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Pythonpath** *(p.967)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.967, lines 1–8)*:
```
folder to your PYTHONPATH setting per Chapter 22. Copying files in either
direction is subpar, and simply running in the Chapter21 folder won’t work
because the reloader script’s Chapter25 folder is “home.” Note that we give a
module name in this mode, not a filename; because the script imports the module
using the search path just like import, the .py extension is omitted:
$ pwd                                      # In Chapter 25's code folder
/Users/me/…/LP6E/Chapter25
$ export PYTHONPATH=../Chapter21           # Extend path: your shell may vary
```
[^497]
**Annotation:** This excerpt demonstrates 'PYTHONPATH' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Init__** *(p.968)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.968, lines 26–33)*:
```
>>> import dir1.dir2.mod                   # A package in Chapter 24's folder
Running dir1.__init__.py
Running dir1.dir2.__init__.py
Loading dir1.dir2.mod
>>> reload_all(dir1)                       # Reloads all on path: mods in mods
reloading dir1
Running dir1.__init__.py
reloading dir1.dir2
```
[^498]
**Annotation:** This excerpt demonstrates '__init__' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Main__** *(p.955)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.955, lines 1–8)*:
```
$ python3 minmax.py
I am: __main__
1
6
If we import the file, though, its name is not __main__, so we must explicitly
call the function to make it run:
$ python3
>>> import minmax
```
[^499]
**Annotation:** This excerpt demonstrates '__main__' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Name__** *(p.953)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.953, lines 2–9)*:
```
likely to encounter in the wild—both for testing and dual usage.
For instance, one of the most common ways you’ll see the __name__ test applied
is for self-test code. In short, you can package code that tests a module’s exports
in the module itself by wrapping it in a __name__ test at the bottom of the file.
This way, you can use the file in clients by importing it, but also test its logic by
running it from the system shell or other launching scheme.
Coding self-test code at the bottom of a file under the __name__ test is probably
the most common and simplest unit-testing protocol in Python. It’s much more
```
[^500]
**Annotation:** This excerpt demonstrates '__name__' as it appears in the primary text. The concept occurs 9 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Args** *(p.954)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.954, lines 1–8)*:
```
def minmax(test, *args):
    res = args[0]
    for arg in args[1:]:
        if test(arg, res):
            res = arg
    return res
def lessthan(x, y): return x < y
def grtrthan(x, y): return x > y
```
[^501]
**Annotation:** This excerpt demonstrates 'args' as it appears in the primary text. The concept occurs 6 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.966)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.966, lines 3–10)*:
```
top-level script only, and its tester function uses sys.argv to inspect
command-line arguments and importlib to import a module by name string
passed in as a function or command-line argument. Review earlier coverage for
more info if needed.
One curious bit: notice how this code’s tryreload wraps the basic reload call
in a try statement to catch exceptions. Reloads may fail for many reasons, and
it’s best to be defensive when using system interfaces. As you’ll see in a
moment, for example, an unreloadable monitoring module added to sys in
```
[^502]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 6 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.976)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.976, lines 1–8)*:
```
When this file is imported (or run as a standalone program), Python executes its
statements from top to bottom. The first call to func1 fails because the func1
def hasn’t run yet. The call to func2 inside func1 works as long as func2’s def
has been reached by the time func1 is called—and it hasn’t when the second
top-level func1 call is run. The last call to func1 at the bottom of the file works
because func1 and func2 have both been assigned.
Mixing defs with top-level code is not only difficult to read, but it’s also
dependent on statement ordering. As a rule of thumb, if you need to mix
```
[^503]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 18 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.958)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.958, lines 1–8)*:
```
__dict__ attribute we explored in Chapter 23. As we’ve also seen, Python’s
vars built-in is an alternative way to access __dict__, and its sys.modules
dictionary records all loaded modules by import-name string. In addition, its
getattr built-in lets us fetch attributes from their string names—it’s like saying
object.attr, but attr is an expression that produces a string at runtime.
Hence, all the following expressions reach the same attribute and object named
name after importing M and sys:
M.name                              # Qualify object by attribute
```
[^504]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 6 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.946)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.946, lines 7–14)*:
```
In Python, data hiding in modules is a convention, not a syntactical constraint. If
you want to break a module by trashing its names, you can, but most
programmers don’t count this as a life goal. Some purists object to this liberal
attitude toward data hiding, claiming that it means Python can’t implement
encapsulation. However, encapsulation in Python is more about packaging than
about restricting. We’ll expand on this idea in the next part in relation to classes,
which also have no privacy syntax but can often emulate its effect in code.
Minimizing from * Damage: _X and __all__
```
[^505]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Bytecode** *(p.962)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.962, lines 11–18)*:
```
Chapters 3, 5, 9, and 10. exec compiles a string of code and passes it to the
Python interpreter to be executed. In Python, the bytecode compiler is available
at runtime, so you can write programs that construct and run other programs like
this. By default, exec runs the code in the current scope (as if pasted there), but
you can get more specific by passing in optional namespace dictionaries. It also
has security issues noted earlier in the book, which may be moot in a code string
you are building yourself.
Direct Calls: Two Options
```
[^506]
**Annotation:** This excerpt demonstrates 'bytecode' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.949)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.949, lines 3–10)*:
```
interfaces.
These functions also shadow same-named tools in classes and are meant in part
to obviate a long-standing and obscure trick that reset a module’s object in the
sys.modules table to an instance of a class with these same methods. This, of
course, means that these functions may make more sense after we study classes
in Part VI, but the artificial module in Example 25-3 demos the basics.
Example 25-3. gamod.py
var = 2                                   # Real attribute returned directly
```
[^507]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.963)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.963, lines 25–31)*:
```
To tie together and apply some of the topics we’ve studied, this section develops
a module tool that serves as a larger case study to close out this chapter and part.
We explored module reloads in Chapter 23, as a way to pick up changes in code
without stopping and restarting a program or REPL. When reloading a module,
though, Python reloads only that particular module’s file; it doesn’t
automatically reload modules that the file being reloaded happens to import.
For example, if you reload some module A, and A imports modules B and C, the
```
[^508]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Collections** *(p.972)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.972, lines 16–23)*:
```
reloading tkinter
reloading collections
reloading collections.abc 
…etc…
$ python3 reloadall2.py tkinter
reloading tkinter
reloading collections
reloading collections.abc 
```
[^509]
**Annotation:** This excerpt demonstrates 'collections' as it appears in the primary text. The concept occurs 6 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Def** *(p.976)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.976, lines 2–9)*:
```
statements from top to bottom. The first call to func1 fails because the func1
def hasn’t run yet. The call to func2 inside func1 works as long as func2’s def
has been reached by the time func1 is called—and it hasn’t when the second
top-level func1 call is run. The last call to func1 at the bottom of the file works
because func1 and func2 have both been assigned.
Mixing defs with top-level code is not only difficult to read, but it’s also
dependent on statement ordering. As a rule of thumb, if you need to mix
immediate code with defs, put your defs at the top of the file and your top-level
```
[^510]
**Annotation:** This excerpt demonstrates 'def' as it appears in the primary text. The concept occurs 8 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 28: A More Realistic Example** *(pp.986–1020)*

This later chapter builds upon the concepts introduced here, particularly: None, __init__, __main__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^511]

**Annotation:** Forward reference: Chapter 28 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __init__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 29: Class Coding Details** *(pp.1021–1060)*

This later chapter builds upon the concepts introduced here, particularly: None, __init__, __main__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^512]

**Annotation:** Forward reference: Chapter 29 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __init__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 30: Operator Overloading** *(pp.1061–1100)*

This later chapter builds upon the concepts introduced here, particularly: None, __init__, __main__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^513]

**Annotation:** Forward reference: Chapter 30 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __init__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 28: A More Realistic Example

*Source: Learning Python, 6th Edition, pages 986–1020*

### Chapter Summary
This chapter covers a more realistic example. Key topics include module, namespaces, and operator overloading. Covers class, method, function. [^514]

### Concept-by-Concept Breakdown
#### **Mro** *(p.1015)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1015, lines 18–25)*:
```
this point in the book and in most Python application code. We’ll explore diamonds and the
“MRO” inheritance search order that accommodates them in Chapter 31, but our definition of
inheritance won’t be fully complete until Chapter 40, because it regrettably requires metaclass
info that’s beyond almost all Python programmers’ interest levels and pay grades (thankfully!).
A Second Example
To illustrate the role of inheritance, this next example builds on the previous one.
First, we’ll define a new class, SecondClass, that inherits all of FirstClass’s
names and provides one of its own:
```
[^515]
**Annotation:** This excerpt demonstrates 'MRO' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **None** *(p.1020)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1020, lines 1–8)*:
```
Most operator-overloading methods have no default, and none are
required. If a class does not define or inherit an operator-overloading
method, it just means that the corresponding operation is not supported
for the class’s instances. If there is no __add__, for example, +
expressions raise exceptions. As you’ll learn later, a root class named
object that’s an implicit superclass to every class does provide defaults
for some __X__ methods, but not for many (e.g., object has a default
for print strings, but not +).
```
[^516]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Init__** *(p.999)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.999, lines 21–28)*:
```
class C1(C2, C3):
   def __init__(self, who):     # Set name when constructed
       self.name = who          # Self is either I1 or I2
I1 = C1('sue')                   # Sets I1.name to 'sue'
I2 = C1('bob')                   # Sets I2.name to 'bob'
print(I1.name)                   # Prints 'sue'
If it’s either coded or inherited, Python automatically calls a method named
__init__ each time an instance is generated from a class. The new instance is
```
[^517]
**Annotation:** This excerpt demonstrates '__init__' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Main__** *(p.986)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.986, lines 2–9)*:
```
folder. Finally, also copy mymod.py to the package folder’s
__main__.py and invoke it by running the folder itself; does it make
sense to do that here? Can you still run the nested mymod.py module
itself?
6. Reloads: Experiment with module reloads: if you haven’t already,
perform the tests in Chapter 23’s changer.py (Example 23-10), changing
the called function’s message or behavior repeatedly, without stopping
the Python REPL. Depending on your device, you might edit changer
```
[^518]
**Annotation:** This excerpt demonstrates '__main__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Abstraction** *(p.991)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.991, lines 10–17)*:
```
supports programming better than flat procedural models. Along with the
functional tools we met earlier, it represents a major abstraction step above
computer hardware that helps us build more sophisticated programs.
OOP from 30,000 Feet
Before we dig into what this all means in terms of code, let’s get a better handle
on the general ideas behind OOP. If you’ve never done anything object-oriented
in your life before now, some of the terminology in this chapter may seem a bit
perplexing on the first pass. Moreover, the motivation for these terms may be
```
[^519]
**Annotation:** This excerpt demonstrates 'abstraction' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.998)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.998, lines 6–13)*:
```
Attributes are usually attached to instances by assignments to the
special argument passed to functions coded inside classes, called self.
For example, classes provide behavior for their instances with functions we
create by coding def statements inside class statements. Because such nested
def statements assign function names within the class, they wind up attaching
attributes to the class object that will be inherited by all instances and subclasses
—as is Example 26-2, which lists changed parts in bold.
Example 26-2. classtree2.py
```
[^520]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.1014)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1014, lines 2–9)*:
```
in this chapter.
Classes Are Customized by Inheritance
Let’s move on to the second major distinction of classes. Besides serving as
factories for generating multiple instance objects, classes also allow us to make
changes by introducing new components (called subclasses), instead of changing
existing components in place.
As we’ve seen, instance objects generated from a class inherit the class’s
attributes. Python also allows classes to inherit from other classes, opening the
```
[^521]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 43 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.1013)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1013, lines 6–13)*:
```
—a string and a floating-point number. As with everything else in Python,
instance attributes (sometimes called members) are not predeclared and have no
type constraints; they spring into existence the first time they are assigned
values, just like simple variables. In fact, if we were to call display on one of
our instances before calling setdata, we would trigger an undefined name error
—the attribute named data doesn’t even exist in memory until it is assigned
within the setdata method.
As another way to appreciate how dynamic this model is, consider that we can
```
[^522]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 11 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.1003)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1003, lines 3–10)*:
```
        data = reader.read()
        if not data: break
        data = converter(data)
        writer.write(data)
By passing in instances of subclasses that specialize the required read and
write method interfaces for various data sources, we can reuse the processor
function for any data source we need to use, both now and in the future:
class Reader:
```
[^523]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.1014)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1014, lines 2–9)*:
```
in this chapter.
Classes Are Customized by Inheritance
Let’s move on to the second major distinction of classes. Besides serving as
factories for generating multiple instance objects, classes also allow us to make
changes by introducing new components (called subclasses), instead of changing
existing components in place.
As we’ve seen, instance objects generated from a class inherit the class’s
attributes. Python also allows classes to inherit from other classes, opening the
```
[^524]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 36 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class Method** *(p.996)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.996, lines 16–23)*:
```
This description is technically just the default case (Python has additional
method types you’ll meet later, called static and class methods), but it applies to
the vast majority of the OOP code written in the language. To see how methods
receive their subjects, though, we need to move on to some code.
Coding Class Trees
Although we are speaking in the abstract here, there is tangible code behind all
these ideas, of course. We construct trees and their objects with class
statements and class calls, which we’ll explore in more detail later. In short,
```
[^525]
**Annotation:** This excerpt demonstrates 'class method' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Closure** *(p.990)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.990, lines 16–23)*:
```
gets a namespace of its own for data that varies per object. This is similar to
the per-call state retention of Chapter 17’s closure functions, but is explicit
and natural in classes, and is just one of the things that classes do. Classes
offer a more complete programming solution.
Customization via inheritance
Classes also support the OOP notion of inheritance: we can extend a class by
redefining its attributes outside the class itself in new software components
coded as subclasses. More generally, classes can build up namespace
```
[^526]
**Annotation:** This excerpt demonstrates 'closure' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Collections** *(p.989)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.989, lines 18–25)*:
```
Composition
Pizza-making robots are really collections of components that work together
as a team. For instance, for our robot to be successful, it might need arms to
roll dough, motors to maneuver to the oven, and so on. In OOP parlance, our
robot is an example of composition; it contains other objects that it activates
to do its bidding. Each component might be coded as a class, which defines
its own behavior and relationships.
While you may never build pizza-making robots, general OOP ideas like
```
[^527]
**Annotation:** This excerpt demonstrates 'collections' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Constructor** *(p.1006)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1006, lines 22–29)*:
```
automatically each time an instance of that class is created. It’s known
as the constructor method; it is passed the new instance implicitly, as
well as any arguments passed explicitly to the class name. It’s also the
most commonly used operator-overloading method. If no __init__
method is present, instances simply begin life as empty namespaces.
6. You create a class instance by calling the class name as though it were a
function; any arguments passed into the class name show up as
arguments two and beyond in the __init__ constructor method (if there
```
[^528]
**Annotation:** This excerpt demonstrates 'constructor' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Debugging** *(p.1001)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1001, lines 4–11)*:
```
structure for code that packages and localizes both logic and names, and so aids
in debugging.
To be fair, because methods are simply functions with a special first argument,
we can mimic some of their behavior by manually passing subject objects to
simple functions. The participation of methods in class inheritance, though,
allows us to naturally extend and customize software by coding subclasses with
new methods, rather than modifying code that already works. There is really no
such concept with modules and functions.
```
[^529]
**Annotation:** This excerpt demonstrates 'debugging' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 29: Class Coding Details** *(pp.1021–1060)*

This later chapter builds upon the concepts introduced here, particularly: MRO, None, __init__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^530]

**Annotation:** Forward reference: Chapter 29 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts MRO, None appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 30: Operator Overloading** *(pp.1061–1100)*

This later chapter builds upon the concepts introduced here, particularly: MRO, None, __init__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^531]

**Annotation:** Forward reference: Chapter 30 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts MRO, None appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 31: Designing with Classes** *(pp.1101–1140)*

This later chapter builds upon the concepts introduced here, particularly: MRO, None, __init__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^532]

**Annotation:** Forward reference: Chapter 31 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts MRO, None appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 29: Class Coding Details

*Source: Learning Python, 6th Edition, pages 1021–1060*

### Chapter Summary
This is a common
convention, and explains why b in the listing has a display method; it’s a
ThirdClass object too, because that’s what + returns for this class’s objects Key topics include modules, namespace, and operator overloading. Covers class, method, function. [^533]

### Concept-by-Concept Breakdown
#### **Mro** *(p.1053)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1053, lines 11–18)*:
```
In its defense, the super call has a valid role too—cooperative same-named
method dispatch in multiple inheritance trees—but this relies on the “MRO”
class ordering of Chapter 31, which many find artificial; requires universal
deployment to be used reliably; does not fully support method replacement
and varying argument lists; and to many observers seems an esoteric solution
to a role that is rare in real Python code.
Because of these downsides, this book prefers to call superclasses by explicit
name instead of super, recommends the same policy for newcomers, and
```
[^534]
**Annotation:** This excerpt demonstrates 'MRO' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **None** *(p.1038)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1038, lines 1–8)*:
```
None, we’ll probably want to default pay to 0, too, for consistency (unless some
of the people you know manage to get paid without having jobs). In fact, we
have to specify a default for pay because according to Python’s syntax rules and
Chapter 18, any arguments in a function’s header after the first default must all
have defaults, too. Example 28-3 codes the mod.
Example 28-3. person_3.py (add constructor defaults)
class Person:
   def __init__(self, name, job=None, pay=0):         # Normal function args
```
[^535]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Init__** *(p.1057)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1057, lines 3–10)*:
```
Managers in such a way as to provide a job name automatically. In terms of
code, we want to redefine an __init__ method in Manager that provides the mgr
string for us. And as in giveRaise customization, we also want to run the
original __init__ in Person by calling through the class name, so it still
initializes our objects’ state information attributes.
The mods in Example 28-10 will do the job—we’ve coded the new Manager
constructor and changed the call that creates pat to not pass in the mgr job name.
Example 28-10. person_10.py (add constructor customization in a subclass)
```
[^536]
**Annotation:** This excerpt demonstrates '__init__' as it appears in the primary text. The concept occurs 6 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Main__** *(p.1040)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1040, lines 24–31)*:
```
       self.pay  = pay
if __name__ == '__main__':                  # When run for testing only
   bob = Person('Bob Smith')
   sue = Person('Sue Jones', job='dev', pay=100000)
   print(bob.name, bob.pay)
   print(sue.name, sue.pay)
Now, we get exactly the behavior we’re after—running the file as a top-level
script tests it because its __name__ is __main__, but importing it as a library of
```
[^537]
**Annotation:** This excerpt demonstrates '__main__' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Name__** *(p.1040)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1040, lines 15–22)*:
```
for testing, not when the file is imported. As linear readers of this book have
already learned, that’s exactly what the module __name__ check is designed for.
Example 28-5 shows what this addition looks like—simply add the required test
and indent your self-test code.
Example 28-5. person_5.py (support both imports and run/tests)
class Person:
   def __init__(self, name, job=None, pay=0):
       self.name = name
```
[^538]
**Annotation:** This excerpt demonstrates '__name__' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Repr__** *(p.1047)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1047, lines 1–8)*:
```
__repr__ method, if the object either defines one itself or inherits one from a
superclass. Double-underscored names are inherited just like any other.
Technically, __str__ is preferred by print and str, and __repr__ is used both
as a fallback for these, as well as by interactive echoes and nested appearances.
Although the two can be used to implement different displays in different
contexts (e.g., user- or developer-focused), coding __repr__ alone suffices to
give a single display in all cases. This allows clients to provide an alternative
display with __str__, though this is a moot point for this demo.
```
[^539]
**Annotation:** This excerpt demonstrates '__repr__' as it appears in the primary text. The concept occurs 6 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Str__** *(p.1022)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1022, lines 1–8)*:
```
Current value = "6"
For print, Python passes the object being printed to self in __str__; whatever
string this method returns is taken to be the print string for the object. With
__str__ (or its broader twin __repr__, which we’ll leverage in the next
chapter), we can use a normal print to display objects of this class, instead of
calling the display method. As a contrast, the added mul method also changes
the instance in place for a named call:
>>> print(b)                        # __str__: returns display string
```
[^540]
**Annotation:** This excerpt demonstrates '__str__' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Args** *(p.1050)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1050, lines 20–27)*:
```
call of this form:
instance.method(args…)
is automatically translated by Python into this equivalent form:
class.method(instance, args…)
where the class containing the method to be run is determined by the inheritance
search rule applied to the method’s name. You can code either form in your
script, but there is a slight asymmetry between the two—you must remember to
pass along the instance manually if you call through the class directly.
```
[^541]
**Annotation:** This excerpt demonstrates 'args' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.1037)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1037, lines 6–13)*:
```
class Person:
   def __init__(self, name, job, pay):      # Constructor takes three arguments
       self.name = name                     # Fill out fields when created
       self.job  = job                      # self is the new instance object
       self.pay  = pay
This is a very common coding pattern: we pass in the data to be attached to an
instance as arguments to the constructor method and assign them to self to
retain them permanently. In OO terms, self is the newly created instance object,
```
[^542]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 8 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.1032)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1032, lines 1–8)*:
```
Test Your Knowledge: Answers
1. Classes are always nested inside a module; they are attributes of a
module object. Classes and modules are both namespaces, but classes
correspond to statements (not entire files) and support the OOP notions
of multiple instances, inheritance, and operator overloading (modules
mostly do not). In a sense, a module is like a single-instance class,
without inheritance, which corresponds to an entire file of code.
2. Classes are made by running class statements; instances are created by
```
[^543]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 31 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Assert** *(p.1045)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1045, lines 27–31)*:
```
idea in later chapters, where we’ll explore function decorators and Python’s
assert statement as alternatives that can do the validity test for us automatically
during development. In Chapter 39, for example, we’ll write a tool that lets us
validate with strange incantations like the following:
    @rangetest(percent=(0.0, 1.0))               # Use decorator to validate
```
[^544]
**Annotation:** This excerpt demonstrates 'assert' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.1032)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1032, lines 1–8)*:
```
Test Your Knowledge: Answers
1. Classes are always nested inside a module; they are attributes of a
module object. Classes and modules are both namespaces, but classes
correspond to statements (not entire files) and support the OOP notions
of multiple instances, inheritance, and operator overloading (modules
mostly do not). In a sense, a module is like a single-instance class,
without inheritance, which corresponds to an entire file of code.
2. Classes are made by running class statements; instances are created by
```
[^545]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 12 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.1056)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1056, lines 9–16)*:
```
place for the requirements of Manager’s giveRaise, doing so would
break code that still needs the original Person behavior.
Although we could have simply copied the Person class in its entirety,
renamed the copy to Manager, and changed its giveRaise, doing so
would introduce code redundancy that would double our work in the
future—changes made to Person in the future would not be picked up
automatically, but would have to be manually propagated to Manager’s
code. As usual, the cut-and-paste approach may seem quick now, but it
```
[^546]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.1032)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1032, lines 1–8)*:
```
Test Your Knowledge: Answers
1. Classes are always nested inside a module; they are attributes of a
module object. Classes and modules are both namespaces, but classes
correspond to statements (not entire files) and support the OOP notions
of multiple instances, inheritance, and operator overloading (modules
mostly do not). In a sense, a module is like a single-instance class,
without inheritance, which corresponds to an entire file of code.
2. Classes are made by running class statements; instances are created by
```
[^547]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 22 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class Method** *(p.1021)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1021, lines 30–31)*:
```
>>> b = a + 3                       # __add__: makes a new instance
>>> b.display()                     # b has all ThirdClass methods
```
[^548]
**Annotation:** This excerpt demonstrates 'class method' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 30: Operator Overloading** *(pp.1061–1100)*

This later chapter builds upon the concepts introduced here, particularly: MRO, None, __init__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^549]

**Annotation:** Forward reference: Chapter 30 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts MRO, None appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 31: Designing with Classes** *(pp.1101–1140)*

This later chapter builds upon the concepts introduced here, particularly: MRO, None, __init__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^550]

**Annotation:** Forward reference: Chapter 31 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts MRO, None appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 32: Advanced Class Topics** *(pp.1141–1180)*

This later chapter builds upon the concepts introduced here, particularly: None, __init__, __main__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^551]

**Annotation:** Forward reference: Chapter 32 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __init__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 30: Operator Overloading

*Source: Learning Python, 6th Edition, pages 1061–1100*

### Chapter Summary
This chapter covers operator overloading. Key topics include modules, namespace, and decorators. Covers class, method. [^552]

### Concept-by-Concept Breakdown
#### **Mro** *(p.1094)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1094, lines 17–18)*:
```
grows more convoluted when advanced topics we haven’t yet met are added to
the mix. Metaclasses, diamond-pattern MROs, and descriptors, for example,
```
[^553]
**Annotation:** This excerpt demonstrates 'MRO' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **None** *(p.1079)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1079, lines 9–16)*:
```
$ python3 updatedb.py
Bob Smith     => [Person: job=None, name=Bob Smith, pay=0]
Pat Jones     => [Manager: job=mgr, name=Pat Jones, pay=50000]
Sue Jones     => [Person: job=dev, name=Sue Jones, pay=100000]
$ python3 updatedb.py
Bob Smith     => [Person: job=None, name=Bob Smith, pay=0]
Pat Jones     => [Manager: job=mgr, name=Pat Jones, pay=50000]
Sue Jones     => [Person: job=dev, name=Sue Jones, pay=110000]
```
[^554]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Init__** *(p.1096)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1096, lines 7–14)*:
```
Perhaps the most common places that superclass-method calls show up are in
constructors. The __init__ method, like all attributes, is looked up by
inheritance. This means that at construction time, Python locates and calls just
one __init__, not one in every superclass. If subclass constructors need to
ensure that superclass construction-time logic runs too, they must call the
superclass’s __init__ method explicitly. Calling it through the class name
leverages the same general coding pattern we’ve been using in multiple roles:
>>> class Super:
```
[^555]
**Annotation:** This excerpt demonstrates '__init__' as it appears in the primary text. The concept occurs 7 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Main__** *(p.1062)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1062, lines 12–19)*:
```
           print(person)
if __name__ == '__main__':
   bob = Person('Bob Smith')
   sue = Person('Sue Jones', job='dev', pay=100000)
   pat = Manager('Pat Jones', 50000)
   development = Department(bob, sue)          # Embed objects in a composite
   development.addMember(pat)
   development.giveRaises(.10)                 # Runs embedded objects' giveRaise
```
[^556]
**Annotation:** This excerpt demonstrates '__main__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Name__** *(p.1067)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1067, lines 27–34)*:
```
   def __repr__(self):
       return f'[{self.__class__.__name__}: {self.gatherAttrs()}]'
if __name__ == '__main__':
   class TopTest(AttrDisplay):
       count = 0
       def __init__(self):
           self.attr1 = TopTest.count
           self.attr2 = TopTest.count+1
```
[^557]
**Annotation:** This excerpt demonstrates '__name__' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Repr__** *(p.1063)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1063, lines 8–15)*:
```
Notice how the delegation-based Manager class of Example 28-11 redefines
the __repr__ run by print, instead of allowing it to be caught by
__getattr__ like other attributes. In general, classes cannot intercept and
delegate operator-overloading method attributes used by built-in operations
without redefining them this way. Although we know that __repr__ is the
only such name used in our specific example, this is a broader issue for
delegation-based classes.
Recall that built-in operations like printing and addition implicitly invoke
```
[^558]
**Annotation:** This excerpt demonstrates '__repr__' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Str__** *(p.1068)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1068, lines 15–22)*:
```
[SubTest: attr1=2, attr2=3]
Another design note here: because this class uses __repr__ instead of __str__
its displays are used in all contexts, but its clients also won’t have the option of
providing an alternative low-level display—they can still add a __str__, but this
applies to print and str only. In a more general tool, using __str__ instead
limits a display’s scope, but leaves clients the option of adding a __repr__ for a
secondary display at interactive prompts and nested appearances. We’ll follow
this alternative policy when we code expanded versions of this class in
```
[^559]
**Annotation:** This excerpt demonstrates '__str__' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Args** *(p.1062)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1062, lines 2–9)*:
```
class Department:
   def __init__(self, *args):
       self.members = list(args)               # Manage an objects list
   def addMember(self, person):
       self.members.append(person)
   def giveRaises(self, percent):              # Apply methods to all objects
       for person in self.members:
           person.giveRaise(percent)
```
[^560]
**Annotation:** This excerpt demonstrates 'args' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.1091)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1091, lines 18–25)*:
```
When we call the method by qualifying an instance like this, printer is first
located by inheritance, and then its self argument is automatically assigned the
instance object (x); the text argument gets the string passed at the call
('instance call'). Notice that because Python automatically passes the first
argument to self for us, we can (and must) pass in just one argument. Inside
printer, the name self is used to access or set per-instance data because it
refers back to the instance currently being processed.
As we’ve seen, though, methods may be called in one of two ways—through an
```
[^561]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.1088)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1088, lines 1–8)*:
```
assign the name attr through an instance instead of the class:
>>> x.attr = 64
>>> x.attr, y.attr, SharedData.attr
(64, 32, 32)
Assignments to instance attributes create or change the names in the instance,
not the shared class. More generally, inheritance searches occur only on attribute
references, not on attribute assignments: assigning to an object’s attribute always
changes that object and no other (subject to the note ahead). For example,
```
[^562]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 35 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Assert** *(p.1100)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1100, lines 12–19)*:
```
Class coders sometimes make such subclass requirements more obvious with
assert statements or by raising the built-in NotImplementedError exception
with raise statements. We’ll study statements that may trigger exceptions in
depth in the next part of this book; as a quick preview, here’s the assert scheme
in action:
>>> class Super:
        def delegate(self):
            self.action()
```
[^563]
**Annotation:** This excerpt demonstrates 'assert' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Assertion** *(p.1100)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1100, lines 23–30)*:
```
>>> X.delegate()
AssertionError: action must be defined!
We’ll study assert in Chapters 33 and 34; in short, if its first expression
evaluates to false, it raises an exception with the provided error message. Here,
the expression is always false so as to trigger an error message if a method is not
redefined, and inheritance locates the stub version here. Alternatively, some
classes simply raise a NotImplementedError exception directly in such method
stubs to signal the mistake:
```
[^564]
**Annotation:** This excerpt demonstrates 'assertion' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.1088)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1088, lines 4–11)*:
```
(64, 32, 32)
Assignments to instance attributes create or change the names in the instance,
not the shared class. More generally, inheritance searches occur only on attribute
references, not on attribute assignments: assigning to an object’s attribute always
changes that object and no other (subject to the note ahead). For example,
y.attr is still looked up in the class by inheritance, but the assignment to
x.attr attaches a name to x itself and so replaces the version in the class.
Readers who’ve done OOP before may recognize class attributes like
```
[^565]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 10 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.1070)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1070, lines 2–9)*:
```
expects—if a subclass innocently defines a gatherAttrs name of its own, it will
likely break our class, because the lower version in the subclass will be used
instead of ours.
To see this for yourself, add a gatherAttrs to TopTest in the file’s self-test
code; unless the new method is identical, or intentionally customizes the
original, our tool class will no longer work as planned—self.gatherAttrs
within AttrDisplay searches anew from the TopTest instance:
    class TopTest(AttrDisplay):
```
[^566]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.1069)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1069, lines 1–8)*:
```
file’s self-test code is a class attribute that lives only on the class: it’s assigned in
the class block like methods, and referenced in methods by explicit class name—
much like explicit calls to customized class methods. It’s also inherited by
instances, but inherited class attributes are attached to the class only, not copied
down to instances. There’s more on such nonmethod class attributes in the next
chapter; the main point here is that count won’t be displayed by AttrDisplay.
If you ever do wish to include inherited attributes too, you can climb the
__class__ link to the instance’s class, use the __dict__ there to fetch class
```
[^567]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 21 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 31: Designing with Classes** *(pp.1101–1140)*

This later chapter builds upon the concepts introduced here, particularly: MRO, None, __init__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^568]

**Annotation:** Forward reference: Chapter 31 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts MRO, None appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 32: Advanced Class Topics** *(pp.1141–1180)*

This later chapter builds upon the concepts introduced here, particularly: None, __init__, __main__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^569]

**Annotation:** Forward reference: Chapter 32 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __init__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 33: Exception Basics** *(pp.1181–1215)*

This later chapter builds upon the concepts introduced here, particularly: MRO, None, __init__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^570]

**Annotation:** Forward reference: Chapter 33 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts MRO, None appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 31: Designing with Classes

*Source: Learning Python, 6th Edition, pages 1101–1140*

### Chapter Summary
For instances of subclasses, we still get the exception unless the subclass
provides the expected method to replace the default in the superclass:
>>> class Sub(Super): pass
>>> X = Sub()
>>> X.delegate()
NotImplementedError: action must be defined Key topics include namespaces, module, and generator. Covers class, method, function. [^571]

### Concept-by-Concept Breakdown
#### **Legb Rule** *(p.1103)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1103, lines 20–25)*:
```
enclosing functions from inner to outer (E), then the current global-scope
module (G), then the built-ins module (B)—per the LEGB rule. Notably
absent here, enclosing classes are not searched; class names are referenced as
object attributes instead.
Also per Chapter 17, some special-case constructs localize names further (e.g.,
variables in some comprehensions and some try statement clauses), and nested
```
[^572]
**Annotation:** This excerpt demonstrates 'LEGB rule' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Mro** *(p.1116)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1116, lines 7–14)*:
```
that expose interpreter internals. You’ll see others when we code general-
purpose class display tools in “Multiple Inheritance and the MRO”—there, we
will extend this technique to also display attributes in each object in a class tree
and function as a reusable superclass.
In the last part of this book, we’ll revisit such tools in the context of Python tool
building at large, to code tools that implement attribute privacy, argument
validation, and more. While not in every Python programmer’s job description,
access to internals enables powerful development tools.
```
[^573]
**Annotation:** This excerpt demonstrates 'MRO' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **None** *(p.1129)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1129, lines 18–25)*:
```
>>> X[2:4]                             # Slicing sends __getitem__ a slice object
getitem: slice(2, 4, None)
[7, 8]
>>> X[1:]
getitem: slice(1, None, None)
[6, 7, 8, 9]
>>> X[:-1]
getitem: slice(None, −1, None)
```
[^574]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 8 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Enter__** *(p.1126)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1126, lines 1–8)*:
```
__enter__, __exi
t__
Context manager
(Chapter 34)
__get__, __set__,
__delete__
Descriptor attributes
(Chapter 38)
```
[^575]
**Annotation:** This excerpt demonstrates '__enter__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Eq__** *(p.1125)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1125, lines 35–42)*:
```
__le__, __ge__,
__eq__, __ne__
Comparisons
X < Y, X > Y, 
X <= Y, X >= Y, 
X == Y, X != Y
__radd__
Right-side operators
```
[^576]
**Annotation:** This excerpt demonstrates '__eq__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Init__** *(p.1123)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1123, lines 6–13)*:
```
objects, which makes them consistent, and compatible with more code.
Constructors and Expressions: __init__ and __sub__
As a warm-up, consider the simple class in Example 30-1: its Number class,
coded in module file number.py, provides a method to intercept instance
construction (__init__), as well as one for catching subtraction expressions
(__sub__). Special methods like these are the hooks that let you tie into built-in
operations.
Example 30-1. number.py
```
[^577]
**Annotation:** This excerpt demonstrates '__init__' as it appears in the primary text. The concept occurs 7 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Main__** *(p.1112)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1112, lines 13–20)*:
```
>>> X.__class__                           # Class of instance
<class '__main__.Sub'>
>>> Sub.__bases__                         # Superclasses of class
(<class '__main__.Super'>,)
>>> Super.__bases__                       # Implied above top-levels
(<class 'object'>,)
As classes assign to self attributes, they populate the instance objects—that is,
attributes wind up in the instances’ attribute namespace dictionaries, not in the
```
[^578]
**Annotation:** This excerpt demonstrates '__main__' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Name__** *(p.1114)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1114, lines 20–27)*:
```
def classtree(cls, indent):
   print('.' * indent + cls.__name__)     # Print class name here
   for supercls in cls.__bases__:         # Recur to all superclasses
       classtree(supercls, indent+3)      # May visit super > once
def instancetree(inst):
   print('Tree of', inst)                 # Show instance
   classtree(inst.__class__, 3)           # Climb to its class
def selftest():
```
[^579]
**Annotation:** This excerpt demonstrates '__name__' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Repr__** *(p.1124)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1124, lines 33–40)*:
```
X | Y, X |= Y if no __ior__
__repr__, __str_
_
Printing,
conversions
print(X), X, repr(X), str(X), f'{X!r}'
__call__
Function calls
```
[^580]
**Annotation:** This excerpt demonstrates '__repr__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Args** *(p.1124)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1124, lines 21–28)*:
```
Constructor
Object creation: X = Class(args)
__del__
Destructor
Object reclamation of X
__add__
Operator + (among
others)
```
[^581]
**Annotation:** This excerpt demonstrates 'args' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.1127)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1127, lines 17–24)*:
```
the __getitem__ method inherited by the instance, passing X to the first
argument and the index i in brackets to the second argument.
For example, the following class returns the square of an index value—atypical
perhaps but illustrative of the mechanism in general:
>>> class Indexer:
        def __getitem__(self, index):
            return index ** 2
>>> X = Indexer()
```
[^582]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.1114)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1114, lines 1–8)*:
```
NOTE
The slots exception: In Chapter 32, you’ll learn about slots, an advanced class tool that stores
attributes in instances but not in their namespace dictionaries. It’s tempting to treat these as
class attributes, and indeed, they appear in class namespaces where they manage per-instance
values. As you’ll find, though, slots may prevent a __dict__ from being created in the
instance—a potential that generic tools must sometimes account for by using storage-neutral
built-ins like dir to list and getattr to fetch. The good news is that slots are used very rarely
—as they should be!
```
[^583]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 34 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.1113)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1113, lines 9–16)*:
```
namespace dictionary, which starts out empty and can record completely
different attributes than those recorded by the namespace dictionaries of other
instances of the same class.
Because instance attributes are actually dictionary keys inside Python, there are
really two ways to fetch and assign their values—by qualification or by key
indexing:
>>> X.data1, X.__dict__['data1']
('hack', 'hack')
```
[^584]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 10 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Boolean** *(p.1125)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1125, lines 31–38)*:
```
__bool__
Boolean tests
bool(X), truth tests
__lt__, __gt__,
__le__, __ge__,
__eq__, __ne__
Comparisons
X < Y, X > Y, 
```
[^585]
**Annotation:** This excerpt demonstrates 'boolean' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.1117)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1117, lines 7–14)*:
```
its __doc__ attribute to fetch its documentation (calling print on the result
interprets line breaks if it’s a multiline string):
$ python3
>>> import docstr
>>> docstr.__doc__
'I am: docstr.__doc__'
>>> docstr.func.__doc__
'I am: docstr.func.__doc__'
```
[^586]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 32: Advanced Class Topics** *(pp.1141–1180)*

This later chapter builds upon the concepts introduced here, particularly: None, __enter__, __eq__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^587]

**Annotation:** Forward reference: Chapter 32 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __enter__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 33: Exception Basics** *(pp.1181–1215)*

This later chapter builds upon the concepts introduced here, particularly: MRO, None, __init__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^588]

**Annotation:** Forward reference: Chapter 33 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts MRO, None appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 34: Exception Coding Details** *(pp.1216–1250)*

This later chapter builds upon the concepts introduced here, particularly: MRO, None, __init__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^589]

**Annotation:** Forward reference: Chapter 34 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts MRO, None appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 32: Advanced Class Topics

*Source: Learning Python, 6th Edition, pages 1141–1180*

### Chapter Summary
This chapter covers advanced class topics. Key topics include generator, closure, and decorators. Covers class, method, function. [^590]

### Concept-by-Concept Breakdown
#### **None** *(p.1150)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1150, lines 10–17)*:
```
>>> X[1:]                            # Slicing: __getitem__(slice(…))
@get[slice(1, None, None)] 'ack'
>>> X[:-1]
@get[slice(None, -1, None)] 'hac'
Iterations, though, are more selective—we get the first of the following if
__iter__ is still commented out and the second if it’s not (be sure to restart or
reload after the file mod either way):
>>> list(X) 
```
[^591]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Enter__** *(p.1178)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1178, lines 7–14)*:
```
book:
Chapter 34 uses __enter__ and __exit__ in with statement context
managers.
Chapter 38 uses the __get__ and __set__ class descriptor fetch/set
methods.
Chapter 40 uses the __new__ object creation method in the context of
metaclasses.
In addition, some of the methods we’ve studied here, such as __call__ and
```
[^592]
**Annotation:** This excerpt demonstrates '__enter__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Eq__** *(p.1173)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1173, lines 5–12)*:
```
The truth of == does not imply that != is false, for example, so both
__eq__ and __ne__ should be defined to ensure that both operators
behave correctly.
We don’t have space for an in-depth exploration of comparison methods, but as a
quick introduction, consider the following class and tests:
>>> class Vetter:
        data = 'hack'
        def __gt__(self, other):
```
[^593]
**Annotation:** This excerpt demonstrates '__eq__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Exit__** *(p.1178)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1178, lines 7–14)*:
```
book:
Chapter 34 uses __enter__ and __exit__ in with statement context
managers.
Chapter 38 uses the __get__ and __set__ class descriptor fetch/set
methods.
Chapter 40 uses the __new__ object creation method in the context of
metaclasses.
In addition, some of the methods we’ve studied here, such as __call__ and
```
[^594]
**Annotation:** This excerpt demonstrates '__exit__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Init__** *(p.1163)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1163, lines 7–14)*:
```
class Commuter2:
   def __init__(self, val):
       self.val = val
   def __add__(self, other):
       print('add', self.val, other)
       return self.val + other
   def __radd__(self, other):
       return self.__add__(other)              # Call __add__ explicitly
```
[^595]
**Annotation:** This excerpt demonstrates '__init__' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Main__** *(p.1173)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1173, lines 20–27)*:
```
>>> X > 'code', X < 'code'
gt: self=<__main__.Vetter object at 0x10898f650> other='code'
lt: self=<__main__.Vetter object at 0x10898f650> other='code'
(True, False)
>>> 'code' < X, 'code' > X
gt: self=<__main__.Vetter object at 0x10898f650> other='code'
lt: self=<__main__.Vetter object at 0x10898f650> other='code'
(True, False)
```
[^596]
**Annotation:** This excerpt demonstrates '__main__' as it appears in the primary text. The concept occurs 7 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Name__** *(p.1148)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1148, lines 29–36)*:
```
       print()
if __name__ == '__main__': self_test(Iters)            # Test Iters here
As is, the class in this file has an __iter__ that supports only a single active
scan at any point in time (e.g., nested loops won’t work) because each iteration
attempt resets the scan cursor to the front. Now that you know about yield in
iteration methods, you should be able to tell that Example 30-9 is equivalent but
allows multiple active scans—and judge for yourself whether its more implicit
nature is worth the nested-scan support (and 5 lines shaved).
```
[^597]
**Annotation:** This excerpt demonstrates '__name__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Repr__** *(p.1158)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1158, lines 1–8)*:
```
developers.
That is, __repr__ is used everywhere, except by print and str when a
__str__ is defined. This means you can code a __repr__ to define a single
display format used everywhere and may code a __str__ to either support
print and str exclusively or to provide an alternative display for them.
General tools may also prefer __str__ to leave other classes the option of
adding an alternative __repr__ display for use in other contexts, as long as
print and str displays suffice for the tool. Conversely, a general tool that codes
```
[^598]
**Annotation:** This excerpt demonstrates '__repr__' as it appears in the primary text. The concept occurs 12 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Str__** *(p.1158)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1158, lines 2–9)*:
```
That is, __repr__ is used everywhere, except by print and str when a
__str__ is defined. This means you can code a __repr__ to define a single
display format used everywhere and may code a __str__ to either support
print and str exclusively or to provide an alternative display for them.
General tools may also prefer __str__ to leave other classes the option of
adding an alternative __repr__ display for use in other contexts, as long as
print and str displays suffice for the tool. Conversely, a general tool that codes
a __repr__ still leaves clients the option of adding alternative displays with a
```
[^599]
**Annotation:** This excerpt demonstrates '__str__' as it appears in the primary text. The concept occurs 12 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Args** *(p.1168)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1168, lines 11–18)*:
```
>>> class Callee:
        def __call__(self, *pargs, **kargs):       # Intercept instance calls
            print(f'Called: {pargs=} {kargs=}')    # Accept arbitrary arguments
>>> C = Callee()
>>> C(1, 2, 3)                                     # C is a "callable" object
Called: pargs=(1, 2, 3) kargs={}
>>> C(1, 2, 3, x=4, y=5)
Called: pargs=(1, 2, 3) kargs={'x': 4, 'y': 5}
```
[^600]
**Annotation:** This excerpt demonstrates 'args' as it appears in the primary text. The concept occurs 12 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.1168)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1168, lines 8–15)*:
```
__call__ method for function-call expressions applied to your instances,
passing along whatever positional or keyword arguments were sent. This allows
instances to conform to a function-based API:
>>> class Callee:
        def __call__(self, *pargs, **kargs):       # Intercept instance calls
            print(f'Called: {pargs=} {kargs=}')    # Accept arbitrary arguments
>>> C = Callee()
>>> C(1, 2, 3)                                     # C is a "callable" object
```
[^601]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 6 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.1153)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1153, lines 1–8)*:
```
>>> X.age                     # Found in __dict__ as usual
50
>>> X.name = 'Pat'            # Unsupported attribute
…text omitted…
AttributeError: name not allowed
If you change the __dict__ assignment within this class to either of the
following, it triggers the infinite recursion loop and exception—both dot
notation and its setattr built-in function equivalent (the assignment analog of
```
[^602]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 21 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.1154)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1154, lines 1–8)*:
```
Attribute outliers: Preceding chapters mentioned that attributes coded with advanced class
tools such as slots and properties are not physically stored in the instance’s __dict__
namespace dictionary—and slots may even preclude a __dict__ altogether. As noted, dir and
getattr might be needed for listing and fetching attributes in classes using these tools, but
assignment is similarly impacted: to support such “virtual” attributes, __setattr__ may need
to use the object.__setattr__ scheme shown here, not self.__dict__ indexing. You’ll
learn much more about these attribute tools in upcoming chapters.
Other Attribute-Management Tools
```
[^603]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 16 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Await** *(p.1154)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1154, lines 29–30)*:
```
programmer, we’ll defer the details of other attribute-management techniques
until Chapter 32, and await their focused coverage in Chapter 38.
```
[^604]
**Annotation:** This excerpt demonstrates 'await' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Boolean** *(p.1174)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1174, lines 14–21)*:
```
roles).
Boolean Tests: __bool__ and __len__
The next set of methods is truly useful (pun intended). As you’ve learned, every
object is inherently true or false in Python. When you code classes, you can
define what this means for your objects by coding methods that give the True or
False values of instances on request.
In Boolean contexts, Python first tries __bool__ to obtain a direct Boolean
value; if that method is missing, Python tries __len__ to infer a truth value from
```
[^605]
**Annotation:** This excerpt demonstrates 'boolean' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 33: Exception Basics** *(pp.1181–1215)*

This later chapter builds upon the concepts introduced here, particularly: None, __init__, __main__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^606]

**Annotation:** Forward reference: Chapter 33 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __init__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 34: Exception Coding Details** *(pp.1216–1250)*

This later chapter builds upon the concepts introduced here, particularly: None, __init__, __main__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^607]

**Annotation:** Forward reference: Chapter 34 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __init__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 35: Exception Objects** *(pp.1251–1285)*

This later chapter builds upon the concepts introduced here, particularly: None, __init__, __main__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^608]

**Annotation:** Forward reference: Chapter 35 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __init__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 33: Exception Basics

*Source: Learning Python, 6th Edition, pages 1181–1215*

### Chapter Summary
Toward this end, this chapter codes common OOP design patterns
in Python, such as inheritance, composition, delegation, and factories Key topics include multiple inheritance, module, and design patterns. Covers class, method, function. [^609]

### Concept-by-Concept Breakdown
#### **Mro** *(p.1214)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1214, lines 1–8)*:
```
>>> from mro_diamond import *
C
>>> [c.__name__ for c in A.__mro__]
['A', 'B', 'C', 'D', 'object']
>>> [c.__name__ for c in C.__mro__]
['C', 'D', 'object']
The full __mro__ is the classes used by inheritance at a given class, and
__bases__ is just supers there:
```
[^610]
**Annotation:** This excerpt demonstrates 'MRO' as it appears in the primary text. The concept occurs 19 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **None** *(p.1206)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1206, lines 6–13)*:
```
class Person:
   def __init__(self, name, job=None):
       self.name = name
       self.job  = job
object1 = factory(Hack)                      # Make a Hack object
object2 = factory(Person, 'Sue', 'dev')      # Make a Person object
object3 = factory(Person, name='Bob')        # Ditto, with keywords and default
This code’s factory is passed a class object, along with zero or more arguments
```
[^611]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Init__** *(p.1185)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1185, lines 3–10)*:
```
class Server(Employee):
   def __init__(self, name):
       Employee.__init__(self, name, 40000)
   def work(self):
       print(self.name, 'interfaces with customer')
class PizzaRobot(Chef):
   def __init__(self, name):
       Chef.__init__(self, name)
```
[^612]
**Annotation:** This excerpt demonstrates '__init__' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Main__** *(p.1202)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1202, lines 3–10)*:
```
>>> meth
<bound method Hack.doit of <__main__.Hack object at 0x108f2e8a0>>
>>> meth.__self__
<__main__.Hack object at 0x108f2e8a0>
>>> meth.__func__
<function Hack.doit at 0x108f37ce0>
On the other hand, if we qualify the class to get to doit, we get back a plain
function object with no associated instance. To call this type of method, we
```
[^613]
**Annotation:** This excerpt demonstrates '__main__' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Name__** *(p.1185)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1185, lines 12–19)*:
```
       print(self.name, 'makes pizza')
if __name__ == '__main__':
   pat = PizzaRobot('pat')       # Make a robot named pat
   print(pat)                    # Run inherited __repr__
   pat.work()                    # Run type-specific action
   pat.giveRaise(0.20)           # Give pat a 20% raise
   print(pat); print()
   for klass in Employee, Chef, Server, PizzaRobot:
```
[^614]
**Annotation:** This excerpt demonstrates '__name__' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Repr__** *(p.1184)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1184, lines 16–23)*:
```
demo. It provides common behavior such as bumping up salaries (giveRaise)
and printing (__repr__). There are two kinds of employees, and so there are two
subclasses of Employee—Chef and Server. Both override the inherited work
method to print more specific messages. Finally, our pizza robot is modeled by
an even more specific class—PizzaRobot is a kind of Chef, which is a kind of
Employee. In OOP terms, we call these relationships “is-a” links: a robot is a
chef, which is an employee.
Example 31-1. employees.py
```
[^615]
**Annotation:** This excerpt demonstrates '__repr__' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Args** *(p.1206)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1206, lines 1–8)*:
```
def factory(aClass, *pargs, **kargs):        # Varargs tuple, dict
   return aClass(*pargs, **kargs)           # Call aClass
class Hack:
   def doit(self, message):
       print(message)
class Person:
   def __init__(self, name, job=None):
       self.name = name
```
[^616]
**Annotation:** This excerpt demonstrates 'args' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.1183)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1183, lines 8–15)*:
```
selections using the type-testing ideas we met in Chapters 4 and 9, or the
argument-list tools introduced in Chapter 18:
class C:
    def meth(self, *args):
        if len(args) == 1:              # Branch on number arguments
            …
        elif type(arg[0]) == int:       # Branch on argument types (or isinstance())
            …
```
[^617]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.1212)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1212, lines 1–8)*:
```
Formally speaking, the MRO inheritance search order works as if all classes are
listed per the DFLR, and then all but the rightmost duplicate of each class is
removed. In more detail, it’s computed as follows:
1. List all the classes from which an instance inherits using the DFLR
lookup order, and include a class multiple times if it’s visited more than
once.
2. Scan the resulting list for duplicate classes, removing all but the last
(rightmost) occurrence of duplicates in the list.
```
[^618]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 31 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Assert** *(p.1189)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1189, lines 16–23)*:
```
   def converter(self, data):
       assert False, 'converter must be defined'       # Or raise exception
This class defines a converter method that it expects subclasses to fill in; it’s an
example of the abstract superclass model we outlined in Chapter 29 (again,
more on assert in Part VII—it simply raises an exception if its test is false).
Coded this way, reader and writer objects are embedded within the class
instance (composition), and we supply the conversion logic in a subclass rather
than passing in a converter function (inheritance). The file in Example 31-4,
```
[^619]
**Annotation:** This excerpt demonstrates 'assert' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Async** *(p.1188)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1188, lines 6–13)*:
```
When we run this module, our pizza shop handles two orders—one from Sue
and then one from Bob (overlapping orders with the async coroutines of
Chapter 20 is explicitly out of scope here):
$ python3 pizzashop.py
Sue orders from <Server: name="Jan", salary=40,000.00>
Pat makes pizza
oven bakes
Sue pays for item to <Server: name="Jan", salary=40,000.00>
```
[^620]
**Annotation:** This excerpt demonstrates 'async' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.1196)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1196, lines 11–18)*:
```
code and then only for names that begin with two leading underscores. It works
for every name preceded with double underscores, though—both class attributes
(including method names) and instance attribute names assigned to self. For
example, in a class named Hack, a method named __meth is mangled to
_Hack__meth, and an instance attribute reference self.__X is transformed to
self._Hack__X.
Despite the mangling, as long as the class uses the double-underscore version
everywhere it refers to the name, all its references will still work. Because more
```
[^621]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 10 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.1188)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1188, lines 30–34)*:
```
        data = reader.read()
        if not data: break
        data = converter(data)
        writer.write(data)
Rather than using a simple function here, we might code this as a class that uses
```
[^622]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.1212)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1212, lines 1–8)*:
```
Formally speaking, the MRO inheritance search order works as if all classes are
listed per the DFLR, and then all but the rightmost duplicate of each class is
removed. In more detail, it’s computed as follows:
1. List all the classes from which an instance inherits using the DFLR
lookup order, and include a class multiple times if it’s visited more than
once.
2. Scan the resulting list for duplicate classes, removing all but the last
(rightmost) occurrence of duplicates in the list.
```
[^623]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 23 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class Method** *(p.1200)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1200, lines 23–29)*:
```
an instance, but plain functions do not. This is why we’ve had to pass in an
instance explicitly when calling superclass methods from subclass methods in
previous examples (including this chapter’s employees.py in Example 31-1);
technically, such calls produce plain functions along the way.
When calling a bound method object, though, Python provides the instance
argument for us—the instance that was used to create the bound method object.
This means that bound method objects are usually interchangeable with simple
```
[^624]
**Annotation:** This excerpt demonstrates 'class method' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 34: Exception Coding Details** *(pp.1216–1250)*

This later chapter builds upon the concepts introduced here, particularly: MRO, None, __init__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^625]

**Annotation:** Forward reference: Chapter 34 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts MRO, None appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 35: Exception Objects** *(pp.1251–1285)*

This later chapter builds upon the concepts introduced here, particularly: MRO, None, __init__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^626]

**Annotation:** Forward reference: Chapter 35 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts MRO, None appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 36: Designing with Exceptions** *(pp.1286–1320)*

This later chapter builds upon the concepts introduced here, particularly: MRO, None, __init__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^627]

**Annotation:** Forward reference: Chapter 36 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts MRO, None appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 34: Exception Coding Details

*Source: Learning Python, 6th Edition, pages 1216–1250*

### Chapter Summary
First, though, the
next section demonstrates a practical use case for the multiple-inheritance design
pattern Key topics include modules, multiple inheritance, and metaclasses. Covers class. [^628]

### Concept-by-Concept Breakdown
#### **Mro** *(p.1247)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1247, lines 5–12)*:
```
(<class '__main__.C'>, (<class 'object'>,), <class 'type'>, (<class 'object'>,))
But due to the way MROs are computed from __bases__ and scanned, it’s more
accurate to think of inheritance’s different search orders for nonclass instances
and classes as follows—where each __mro__ is a flattened tree:
>>> I, I.__class__.__mro__
(<__main__.C object at 0x101265d60>, (<class '__main__.C'>, <class 'object'>))
>>> C.__mro__, C.__class__.__mro__
((<class '__main__.C'>, <class 'object'>), (<class 'type'>, <class 'object'>))
```
[^629]
**Annotation:** This excerpt demonstrates 'MRO' as it appears in the primary text. The concept occurs 10 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **None** *(p.1242)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1242, lines 26–31)*:
```
class calls like list(), str(), and float(), but they are instances of a class,
nonetheless.
In fact, built-in types and user-defined classes are both classes and are both
themselves instances of the built-in type class. The type object generates
classes as its instances, classes generate instances of themselves, and classes are
really just user-defined types. And on top of all this, the built-in object class
```
[^630]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Init__** *(p.1221)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1221, lines 1–8)*:
```
def __init__(self):                 # Superclass __init__
           self.data1 = 'code'             # Create instance attrs
       def method1(self):
           pass
   class Sub(Super, listerclass):          # Mix in method1 and a __str__
       def __init__(self):                 # Listers have access to self
           Super.__init__(self)            # Or super().__init__()
           self.data2 = 'Python'           # More instance attrs
```
[^631]
**Annotation:** This excerpt demonstrates '__init__' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Main__** *(p.1232)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1232, lines 1–8)*:
```
<class '__main__.D'>,
 <class 'object'>)
ATTRIBUTES
{'__dict__': <class '__main__.D'>,
 '__doc__': <class '__main__.A'>,
 '__module__': <class '__main__.A'>,
 '__weakref__': <class '__main__.D'>,
 'attr0': <__main__.A object at 0x10cc33e00>,
```
[^632]
**Annotation:** This excerpt demonstrates '__main__' as it appears in the primary text. The concept occurs 14 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Name__** *(p.1218)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1218, lines 28–35)*:
```
   def __str__(self):
       return (f'<Instance of {self.__class__.__name__}, '     # My class's name
               f'address {id(self):#x}:'                       # My address (hex)
               f'{self.__attrnames()}>')                       # name=value list
if __name__ == '__main__':
   import testmixin
   testmixin.tester(ListInstance)      # Test class in this module
The __attrnames method here exhibits a classic comprehension pattern, and
```
[^633]
**Annotation:** This excerpt demonstrates '__name__' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Repr__** *(p.1224)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1224, lines 18–25)*:
```
NOTE
Looping in __repr__: Now that we’re displaying inherited methods too, we must use __str__
instead of __repr__ to overload printing. With __repr__, this code (and code like it) will fall
into recursive loops—its getattr returns a bound method; whose display includes the
instance; which triggers __repr__ again to display the instance; and so on, quickly triggering a
stack-overflow exception. Subtle, but true! Change __str__ to __repr__ to see this live. One
way to avoid such __repr__ loops is to skip getattr results for which isinstance
comparisons to the standard library’s types.MethodType are true. Using __str__ instead is
```
[^634]
**Annotation:** This excerpt demonstrates '__repr__' as it appears in the primary text. The concept occurs 6 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Str__** *(p.1218)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1218, lines 2–9)*:
```
deploy coding techniques that make classes better suited to use as generic tools.
Unlike Chapter 28, we’ll code this with a __str__ instead of a __repr__. This
is partially a style issue and limits their role to print and str, but the displays
we’ll be developing are meant to be user-friendly, not imitative of code. This
policy also leaves client classes the option of coding an alternative lower-level
display for interactive echoes and nested appearances with a __repr__ and has
built-in immunity from __repr__ looping perils covered ahead.
Listing instance attributes with __dict__
```
[^635]
**Annotation:** This excerpt demonstrates '__str__' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.1248)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1248, lines 18–25)*:
```
metaclasses that customize types (a.k.a. classes), which we’ll uncover later.
In fact, a reasonable argument can be made that the type/class dichotomy of
earlier Pythons may simply have morphed into one of metaclass/class—which
trades a straightforward distinction for all the seams just enumerated and
muddles inheritance and the fundamental meaning of names in Python
everywhere to support what in the end is a very rare use case. As usual, the net
merit of the morph is yours to weigh.
To be fair, some of the widespread confusion this model has spawned may stem
```
[^636]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.1247)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1247, lines 1–8)*:
```
(True, <class '__main__.C'>)
>>> I, I.__class__, I.__class__.__bases__
(<__main__.C object at 0x101265d60>, <class '__main__.C'>, (<class 'object'>,))
>>> C, C.__bases__, C.__class__, C.__class__.__bases__
(<class '__main__.C'>, (<class 'object'>,), <class 'type'>, (<class 'object'>,))
But due to the way MROs are computed from __bases__ and scanned, it’s more
accurate to think of inheritance’s different search orders for nonclass instances
and classes as follows—where each __mro__ is a flattened tree:
```
[^637]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 44 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.1219)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1219, lines 2–9)*:
```
suggested exercise. As coded, ListInstance uses some previously explored
techniques to extract the instance’s class name and attributes:
It uses a self.__class__.__name__ expression to fetch the name of an
instance’s class. Recall that each instance has a built-in __class__
attribute that references the class from which it was created, and each
class has a __name__ attribute that references the class’s name given in
its header line.
It does most of its work by simply scanning the instance’s attribute
```
[^638]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 10 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Await** *(p.1249)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1249, lines 1–8)*:
```
will have to await the metaclass preview later in this chapter and the extended
coverage in Chapter 40.
And One “object” to Rule Them All
To round out this topic, keep in mind that because topmost classes inherit from
the built-in class object, every object derives (i.e., inherits) from it, whether
directly or through a superclass—and whether you code object or not:
>>> class C: pass
>>> class D(object): pass
```
[^639]
**Annotation:** This excerpt demonstrates 'await' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.1224)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1224, lines 7–14)*:
```
The display of bound methods in this was truncated to fit this page; here’s what
the first two look like with an added line break (as usual, run on your own for the
full and up-to-date picture):
        _ListInherited__attrnames=<bound method ListInherited.__attrnames of
            <testmixin.tester.<locals>.Sub object at 0x101d76600>>
        method1=<bound method tester.<locals>.Super.method1 of 
            <testmixin.tester.<locals>.Sub object at 0x101d76600>>
Display formatting is an open-ended task (e.g., Python’s standard pprint “pretty
```
[^640]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.1247)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1247, lines 1–8)*:
```
(True, <class '__main__.C'>)
>>> I, I.__class__, I.__class__.__bases__
(<__main__.C object at 0x101265d60>, <class '__main__.C'>, (<class 'object'>,))
>>> C, C.__bases__, C.__class__, C.__class__.__bases__
(<class '__main__.C'>, (<class 'object'>,), <class 'type'>, (<class 'object'>,))
But due to the way MROs are computed from __bases__ and scanned, it’s more
accurate to think of inheritance’s different search orders for nonclass instances
and classes as follows—where each __mro__ is a flattened tree:
```
[^641]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 33 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class Method** *(p.1227)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1227, lines 33–35)*:
```
current tree object whose __dict__ is being scanned (getattr and
__dict__ indexing are equivalent in this context). Again, class methods
are just functions, which are bound only when fetched from an instance.
```
[^642]
**Annotation:** This excerpt demonstrates 'class method' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.1229)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1229, lines 6–13)*:
```
DFLR order and leaves it to readers to determine from which class a given
attribute is inherited. To do better, let’s move on to a final example to close out
this chapter.
Example: Mapping Attributes to Inheritance Sources
This section wraps up with an example that demos an application for the MRO
in programming tools. As coded, the preceding section’s tree lister gave the
physical locations of attributes in a class tree. However, by mapping the list of
inherited attributes in a dir result to the linear MRO sequence, such tools can
```
[^643]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 35: Exception Objects** *(pp.1251–1285)*

This later chapter builds upon the concepts introduced here, particularly: MRO, None, __init__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^644]

**Annotation:** Forward reference: Chapter 35 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts MRO, None appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 36: Designing with Exceptions** *(pp.1286–1320)*

This later chapter builds upon the concepts introduced here, particularly: MRO, None, __init__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^645]

**Annotation:** Forward reference: Chapter 36 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts MRO, None appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 37: Unicode and Byte Strings** *(pp.1321–1365)*

This later chapter builds upon the concepts introduced here, particularly: None, __main__, __name__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^646]

**Annotation:** Forward reference: Chapter 37 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __main__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 35: Exception Objects

*Source: Learning Python, 6th Edition, pages 1251–1285*

### Chapter Summary
This chapter covers exception objects. Key topics include decorator, properties, and descriptors. Covers class, method, function. [^647]

### Concept-by-Concept Breakdown
#### **Mro** *(p.1257)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1257, lines 19–26)*:
```
sources and filter them more selectively by source or type, if needed, by
scanning the MRO—as we did in the prior chapter’s mapattrs.py (Example 31-
14). As a bonus, such tools and policies for handling slots will potentially apply
automatically to properties and descriptors too, though these attributes are more
explicitly computed values, and less obviously instance-related data than slots.
Also keep in mind that this is not just a tools issue. Class-based instance
attributes like slots also impact the traditional coding of the __setattr__
operator-overloading method we met in Chapter 30. Because slots and some
```
[^648]
**Annotation:** This excerpt demonstrates 'MRO' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **None** *(p.1254)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1254, lines 29–34)*:
```
Since either can be omitted, we may more correctly code this as follows, using
getattr to allow for defaults—a noble but nonetheless inaccurate approach, as
the next section will explain:
>>> for attr in list(getattr(I, '__dict__', [])) + getattr(I, '__slots__', []):
        print(attr, '=>', getattr(I, attr))
d => 4
```
[^649]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Init__** *(p.1277)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1277, lines 18–25)*:
```
       cls.numInstances += 1          # cls is lowest class above instance
   def __init__(self):
       self.count()                   # Passes self.__class__ to count
   count = classmethod(count)
class Sub(Hack):
   numInstances = 0
   def __init__(self):                # Redefines __init__ (to demo)
       Hack.__init__(self)
```
[^650]
**Annotation:** This excerpt demonstrates '__init__' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Main__** *(p.1282)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1282, lines 28–34)*:
```
   return a + b + c
if __name__ == '__main__':
   print(hack(1, 2, 3))               # Really calls the tracer wrapper object
   print(hack('a', 'b', 'c'))         # Invokes __call__ in class
Because the hack function is run through the tracer decorator, when the
original hack name is called, it actually triggers the __call__ method in the
class. This method counts and logs the call and then dispatches it to the original
```
[^651]
**Annotation:** This excerpt demonstrates '__main__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Name__** *(p.1282)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1282, lines 23–30)*:
```
       self.calls += 1
       print(f'call {self.calls} to {self.func.__name__}')
       return self.func(*args)
@tracer                                # Same as hack = tracer(hack)
def hack(a, b, c):                     # Wrap hack in a decorator object
   return a + b + c
if __name__ == '__main__':
   print(hack(1, 2, 3))               # Really calls the tracer wrapper object
```
[^652]
**Annotation:** This excerpt demonstrates '__name__' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Annotation** *(p.1278)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1278, lines 21–28)*:
```
added to make the operation simpler. Python decorators—similar to the notion
and syntax of annotations in Java—both address this specific need and provide a
general tool for adding logic that manages functions and classes or later calls to
them.
This is called a “decoration,” but in more concrete terms is really just a way to
run extra processing steps at function and class definition time with explicit
syntax. It comes in two flavors:
Function decorators: The initial entry, augment function definitions at
```
[^653]
**Annotation:** This excerpt demonstrates 'annotation' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Args** *(p.1282)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1282, lines 21–28)*:
```
       self.func  = func
   def __call__(self, *args):         # On later calls: add logic, run original
       self.calls += 1
       print(f'call {self.calls} to {self.func.__name__}')
       return self.func(*args)
@tracer                                # Same as hack = tracer(hack)
def hack(a, b, c):                     # Wrap hack in a decorator object
   return a + b + c
```
[^654]
**Annotation:** This excerpt demonstrates 'args' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.1283)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1283, lines 1–8)*:
```
wrapped function. Note how the *name argument syntax is used to pack and
unpack the passed-in arguments; because of this, this decorator can be used to
wrap any function with any number of positional arguments.
The net effect, again, is to add a layer of logic to the original hack function.
When run, the first output line comes from the tracer class, and the second
gives the return value of the hack function itself:
$ python3 tracer1.py
call 1 to hack
```
[^655]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.1276)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1276, lines 1–8)*:
```
def printNumInstances(cls):              # Override a class method
       print('Extra stuff...', cls)         # But call back to original
       Hack.printNumInstances()
   printNumInstances = classmethod(printNumInstances)
class Other(Hack): pass                      # Inherit class method verbatim
Running this in a REPL reveals that the lowest class is passed in whenever a
class method is run—even for subclasses that have no class methods of their
own:
```
[^656]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 46 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.1256)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1256, lines 3–10)*:
```
[…names omitted…, 'a', 'b', 'c', 'd']
In other words, in terms of listing instance attributes generically, one __slots__
isn’t always enough—they are potentially subject to the full inheritance search
procedure. If multiple classes in a class tree may have their own __slots__
attributes, tools must develop other policies for listing attributes—as the next
section explains.
Handling slots and other “virtual” attributes generically
The prior chapter concluded with a brief summary of the slots policies of its
```
[^657]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 15 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.1260)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1260, lines 2–9)*:
```
>>> class D(C): __slots__ = ['b']
>>> I = D()                              # And may break code and tools you use
>>> I.a = 1; I.b = 2
>>> I.__dict__
AttributeError: 'D' object has no attribute '__dict__'. Did you mean: '__dir__'?
>>> C.__dict__.keys(), D.__dict__.keys()
(dict_keys([… '__slots__', 'a', …]), dict_keys([… '__slots__', 'b', …]))
Such rules—and others omitted here for space—are part of the reason slots are
```
[^658]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.1276)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1276, lines 1–8)*:
```
def printNumInstances(cls):              # Override a class method
       print('Extra stuff...', cls)         # But call back to original
       Hack.printNumInstances()
   printNumInstances = classmethod(printNumInstances)
class Other(Hack): pass                      # Inherit class method verbatim
Running this in a REPL reveals that the lowest class is passed in whenever a
class method is run—even for subclasses that have no class methods of their
own:
```
[^659]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 37 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class Method** *(p.1276)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1276, lines 1–8)*:
```
def printNumInstances(cls):              # Override a class method
       print('Extra stuff...', cls)         # But call back to original
       Hack.printNumInstances()
   printNumInstances = classmethod(printNumInstances)
class Other(Hack): pass                      # Inherit class method verbatim
Running this in a REPL reveals that the lowest class is passed in whenever a
class method is run—even for subclasses that have no class methods of their
own:
```
[^660]
**Annotation:** This excerpt demonstrates 'class method' as it appears in the primary text. The concept occurs 9 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.1274)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1274, lines 4–11)*:
```
scope (so it won’t clash with other names in the module); moves the function
code closer to where it is used (inside the class statement); and allows
subclasses to customize the static method with inheritance—a more convenient
and powerful approach than importing functions from the files in which
superclasses are coded. The following subclass illustrates (this continues the
prior session, so the count is already 3 at the start):
>>> class Sub(Hack):
        def printNumInstances():             # Override a static method
```
[^661]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Closure** *(p.1283)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1283, lines 21–28)*:
```
broadly applicable to class-level methods too. We’ll postpone the full details on
this, but Example 32-15 provides a brief look at this closure-based coding
model; it uses function attributes for counter state for portability but could also
leverage variables and nonlocal instead.
Example 32-15. tracer2.py
def tracer(func):                      # Remember original
   def oncall(*args):                 # On later calls
       oncall.calls += 1
```
[^662]
**Annotation:** This excerpt demonstrates 'closure' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 36: Designing with Exceptions** *(pp.1286–1320)*

This later chapter builds upon the concepts introduced here, particularly: MRO, None, __init__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^663]

**Annotation:** Forward reference: Chapter 36 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts MRO, None appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 37: Unicode and Byte Strings** *(pp.1321–1365)*

This later chapter builds upon the concepts introduced here, particularly: None, __main__, __name__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^664]

**Annotation:** Forward reference: Chapter 37 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __main__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 38: Managed Attributes** *(pp.1366–1410)*

This later chapter builds upon the concepts introduced here, particularly: None, __init__, __main__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^665]

**Annotation:** Forward reference: Chapter 38 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __init__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 36: Designing with Exceptions

*Source: Learning Python, 6th Edition, pages 1286–1320*

### Chapter Summary
Because
of this, this book defers additional coverage until its final and optional part:
Chapter 38 shows how to code properties using function decorator
syntax in more depth Key topics include decorators, multiple inheritance, and modules. Covers class, method. [^666]

### Concept-by-Concept Breakdown
#### **Legb Rule** *(p.1306)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1306, lines 15–22)*:
```
        def method(self):
            print(Hack.count)    # Visible in generate's scope, per LEGB rule (E)
    return Hack()
generate().method()
This example works because the local scopes of all enclosing function defs are
automatically visible to nested defs—including nested method defs, as in this
example.
Even so, keep in mind that method defs cannot see the local scope of the
```
[^667]
**Annotation:** This excerpt demonstrates 'LEGB rule' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Mro** *(p.1289)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1289, lines 8–15)*:
```
its superclass, and the self instance, even though none are present in its call.
The backstory involves MROs, a proxy, and an algorithm that are required
reading for super aspirants of all kinds.
A “magic” proxy
To understand how super works, you first need to be fluent in the MRO
algorithm covered in “Multiple Inheritance and the MRO”—and you should
review that now if you gave it a pass. The MRO is both a firm prerequisite and
nested component of super. Given the complexity and artificial nature of the
```
[^668]
**Annotation:** This excerpt demonstrates 'MRO' as it appears in the primary text. The concept occurs 9 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **None** *(p.1289)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1289, lines 7–14)*:
```
something odd going on here. The super call somehow knows about the class,
its superclass, and the self instance, even though none are present in its call.
The backstory involves MROs, a proxy, and an algorithm that are required
reading for super aspirants of all kinds.
A “magic” proxy
To understand how super works, you first need to be fluent in the MRO
algorithm covered in “Multiple Inheritance and the MRO”—and you should
review that now if you gave it a pass. The MRO is both a firm prerequisite and
```
[^669]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Init__** *(p.1297)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1297, lines 2–9)*:
```
>>> class A:
        def __init__(self):
            print('A')
            super().__init__()       # Propagate constructor calls
 
>>> class B:
        def __init__(self):
            print('B')
```
[^670]
**Annotation:** This excerpt demonstrates '__init__' as it appears in the primary text. The concept occurs 13 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Main__** *(p.1291)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1291, lines 20–27)*:
```
>>> E.__mro__
(<class '__main__.E'>, <class '__main__.C'>, <class 'object'>)
>>> E().__class__.__bases__[0]
<class '__main__.C'>
In the more complex class trees of multiple inheritance, though, you must
understand super’s full algorithm to know what it will choose in a given tree.
Here’s how this works. The proxy object that super returns—created
“magically” from runtime info as described in the prior section—uses its saved
```
[^671]
**Annotation:** This excerpt demonstrates '__main__' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Name__** *(p.1296)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1296, lines 1–8)*:
```
>>> [c.__name__ for c in C().__class__.__mro__]
['C', 'B', 'A', 'X', 'object']
This works because X precedes object on the MRO as shown, and hence stops
the act call chain. Adding the anchor class X as a common superclass to both A
and B in a diamond would work, too, because the resulting MRO is the same
(remember, the MRO removes all but the last [rightmost] appearance of a class
from the DFLR order):
>>> class X: …same…
```
[^672]
**Annotation:** This excerpt demonstrates '__name__' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Str__** *(p.1304)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1304, lines 12–19)*:
```
For instance, in the multiple inheritance example we studied in Chapter 31,
imagine that the Super class implemented a __str__ method, too:
class ListTree:
    def __str__(self): …
class Super:
    def __str__(self): …
class Sub(ListTree, Super):    # Get ListTree's __str__ by listing it first
x = Sub()                      # Inheritance searches ListTree before Super
```
[^673]
**Annotation:** This excerpt demonstrates '__str__' as it appears in the primary text. The concept occurs 6 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Abstraction** *(p.1308)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1308, lines 22–29)*:
```
Finally, when used well, the code reuse features of OOP make it excel at cutting
development time. Sometimes, though, OOP’s abstraction potential can be
abused to the point of making code difficult to understand. If classes are layered
too deeply, code can become obscure; you may have to search through many
classes to discover what an operation does.
Imagine, for example, a framework with hundreds of classes and a dozen levels
of inheritance (this is a true story, but details have been omitted to protect the
innocent). Deciphering method calls in such a complex system may be a
```
[^674]
**Annotation:** This excerpt demonstrates 'abstraction' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Args** *(p.1315)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1315, lines 1–8)*:
```
Now, extend your set by subclassing to handle arbitrarily many
operands using the *args argument form. (Hint: see the
function versions of these algorithms in Chapter 18.) Compute
intersections and unions of multiple operands with your set
subclass. How can you intersect three or more sets, given that &
has only two sides?
How would you go about emulating other list operations in the
set class? (Hint: __add__ can catch concatenation, and
```
[^675]
**Annotation:** This excerpt demonstrates 'args' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.1290)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1290, lines 2–9)*:
```
routes later attribute fetches to a superclass’s version of a name.
In fact, the common no-argument super form is equivalent to manually passing
in the class containing the super call, along with the self instance. That is,
within a class’s method function, the following forms work the same, though the
second can be used outside a method, too, and its first argument can be
__class__ inside a method:
super()
super(class-containing-the-super-call, method-self-argument)
```
[^676]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 6 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.1286)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1286, lines 1–8)*:
```
class Meta(type):
    def __new__(meta, classname, supers, classdict):
        …extra logic + class creation via type call…
class C(metaclass=Meta):
    …my creation routed to Meta…            # Like C = Meta('C', (), {…})
Python calls a class’s metaclass to create the new class object, passing in the data
defined during the class statement’s run; if omitted, the metaclass simply
defaults to the type class we explored earlier. Abstractly speaking, here’s what
```
[^677]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 42 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.1302)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1302, lines 1–8)*:
```
>>> class X:
        a = 1       # Class attribute
>>> I = X()
>>> I.a             # Inherited by instance
1
>>> X.a             # Accessible through class
1
So far, so good—this is the normal case. But notice what happens when we
```
[^678]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 7 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.1287)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1287, lines 25–29)*:
```
because of its similarity to a Java tool but are unaware of its much more subtle
implications in Python’s multiple inheritance—until adding superclasses breaks
their programs.
Nevertheless, this call has grown pervasive in Python code and merits further
elaboration, especially for those opting to use it naively. Hence, this section both
```
[^679]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.1286)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1286, lines 1–8)*:
```
class Meta(type):
    def __new__(meta, classname, supers, classdict):
        …extra logic + class creation via type call…
class C(metaclass=Meta):
    …my creation routed to Meta…            # Like C = Meta('C', (), {…})
Python calls a class’s metaclass to create the new class object, passing in the data
defined during the class statement’s run; if omitted, the metaclass simply
defaults to the type class we explored earlier. Abstractly speaking, here’s what
```
[^680]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 37 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class Method** *(p.1286)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1286, lines 23–30)*:
```
methods that process their instance classes rather than normal instances of them
—a technique that’s similar (if not redundant) to class methods and might be
emulated by methods and data in class decorator proxies, or even a class
decorator that returns a metaclass instance.
Such mind-bending concepts, however, require Chapter 40’s conceptual
groundwork (and quite possibly sedation).
For More Details
Naturally, there’s more to the decorator and metaclass stories than shown here.
```
[^681]
**Annotation:** This excerpt demonstrates 'class method' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 37: Unicode and Byte Strings** *(pp.1321–1365)*

This later chapter builds upon the concepts introduced here, particularly: None, __main__, __name__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^682]

**Annotation:** Forward reference: Chapter 37 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __main__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 38: Managed Attributes** *(pp.1366–1410)*

This later chapter builds upon the concepts introduced here, particularly: None, __init__, __main__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^683]

**Annotation:** Forward reference: Chapter 38 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __init__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 39: Decorators** *(pp.1411–1455)*

This later chapter builds upon the concepts introduced here, particularly: None, __main__, __name__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^684]

**Annotation:** Forward reference: Chapter 39 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __main__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 37: Unicode and Byte Strings

*Source: Learning Python, 6th Edition, pages 1321–1365*

### Chapter Summary
This chapter covers unicode and byte strings. Key topics include module, collection, and exception handling. Covers exception, statement, class. [^685]

### Concept-by-Concept Breakdown
#### **None** *(p.1364)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1364, lines 8–15)*:
```
except:
    open('nonesuch')
Exception chains impact error displays, but do not affect the way that exceptions
are named and caught in try statements: chains are simply recorded in
exception-object attributes which may be inspected as usual where useful.
Like the combined try, chained exceptions are similar to utility in other
languages (including Java and C#) though it’s not clear which languages were
borrowers. In Python, it’s not unusual to see exception chains in error messages,
```
[^686]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Main__** *(p.1336)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1336, lines 28–35)*:
```
    doLastThing()
if __name__ == '__main__':
    try:
        doStuff()       # This is where we care about results,
    except:             # so it's the only place we must check
        badEnding()
    else:               # See the next chapter for else
        goodEnding()
```
[^687]
**Annotation:** This excerpt demonstrates '__main__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Name__** *(p.1336)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1336, lines 28–35)*:
```
    doLastThing()
if __name__ == '__main__':
    try:
        doStuff()       # This is where we care about results,
    except:             # so it's the only place we must check
        badEnding()
    else:               # See the next chapter for else
        goodEnding()
```
[^688]
**Annotation:** This excerpt demonstrates '__name__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Str__** *(p.1330)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1330, lines 25–32)*:
```
>>> class Combust(Exception):
        def __str__(self): 
            return 'Call the fire department!...'
>>> raise Combust()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
Combust: Call the fire department!...
>>>
```
[^689]
**Annotation:** This excerpt demonstrates '__str__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Args** *(p.1359)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1359, lines 24–29)*:
```
try:
    raise MyExc('oops')      # Exception class with constructor args
except MyExc as X:           # Instance attributes available in handler
    print(X.args)            # Prints ('oops',)
Because this encroaches on the next chapter’s topic, though, we’ll defer further
details until then.
```
[^690]
**Annotation:** This excerpt demonstrates 'args' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.1358)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1358, lines 10–17)*:
```
either created before the raise or within the raise statement itself. If we pass a
class instead, Python calls the class with no constructor arguments, to create an
instance to be raised; this form is equivalent to adding parentheses after the class
reference. The last form reraises the most recently raised exception; it’s
commonly used in exception handlers to propagate exceptions that have been
caught.
NOTE
Blast from the past: Long ago and far away (well, before Python 2.6), exceptions could be
```
[^691]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.1358)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1358, lines 3–10)*:
```
simple—a raise statement consists of the word raise, optionally followed by
the class to be raised, or an instance of it:
raise instance           # Raise an instance of a class
raise class              # Make and raise an instance of a class
raise                    # Reraise the most recent exception
As mentioned earlier, exceptions are always instances of classes today. Hence,
the first raise form here is the most common—we provide an instance directly,
either created before the raise or within the raise statement itself. If we pass a
```
[^692]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 21 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Assert** *(p.1365)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1365, lines 2–9)*:
```
    if not test:
        raise AssertionError(data)
In other words, if the test evaluates to false, Python raises an exception: the
data item (if it’s provided) is used as the exception’s constructor argument. Like
all exceptions, the built-in AssertionError exception will kill your program if
it’s not caught with a try, and the data item shows up as part of the standard
error message:
>>> language = 'Java'
```
[^693]
**Annotation:** This excerpt demonstrates 'assert' as it appears in the primary text. The concept occurs 13 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Assertion** *(p.1365)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1365, lines 2–9)*:
```
    if not test:
        raise AssertionError(data)
In other words, if the test evaluates to false, Python raises an exception: the
data item (if it’s provided) is used as the exception’s constructor argument. Like
all exceptions, the built-in AssertionError exception will kill your program if
it’s not caught with a try, and the data item shows up as part of the standard
error message:
>>> language = 'Java'
```
[^694]
**Annotation:** This excerpt demonstrates 'assertion' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.1343)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1343, lines 7–14)*:
```
    …
except (AttributeError, TypeError, SyntaxError):
    …
If an exception is raised while this try block is running, Python returns to the
try and searches for the first except that names the exception raised. It inspects
clauses from top to bottom—and left to right along the way—and runs the
statements under the first clause that matches. If none match, the exception is
propagated past this try.
```
[^695]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Boolean** *(p.1345)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1345, lines 25–31)*:
```
# Did we get here because the try failed or not?
Of course, we could initialize, set, and check a Boolean flag to know what
happened, which adds lines of admin code. Much like the way else clauses in
loops make the exit cause more apparent (for exits sans break), the else clause
provides syntax in try that makes the outcome unambiguous with minimal extra
code:
try:
```
[^696]
**Annotation:** This excerpt demonstrates 'boolean' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.1325)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1325, lines 7–14)*:
```
roles; a raise, for instance, can be used to jump out of multiple loops in
ways that break cannot.
We saw some of these roles briefly earlier and will study typical exception use
cases in action later in this part of the book. For now, let’s get started with a look
at Python’s exception-processing tools.
Exceptions: The Short Story
Compared to some other core language topics we’ve explored in this book,
exceptions are a fairly lightweight tool in Python. Because they are so simple,
```
[^697]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Bytecode** *(p.1365)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1365, lines 12–19)*:
```
As an added feature, assert statements are removed from a compiled program’s
bytecode—and hence not run—if the -O Python command-line flag is used to
optimize the program. The __debug__ flag is a built-in and unchangeable name
that is automatically set to True unless the -O flag is used. When __debug__ is
False for -O, any code predicated on it being True is removed, including
asserts.
Hence, to disable (and omit) asserts, run code with a command line like python
–O file.py, or generate optimized bytecode before program runs with similar
```
[^698]
**Annotation:** This excerpt demonstrates 'bytecode' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.1358)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1358, lines 3–10)*:
```
simple—a raise statement consists of the word raise, optionally followed by
the class to be raised, or an instance of it:
raise instance           # Raise an instance of a class
raise class              # Make and raise an instance of a class
raise                    # Reraise the most recent exception
As mentioned earlier, exceptions are always instances of classes today. Hence,
the first raise form here is the most common—we provide an instance directly,
either created before the raise or within the raise statement itself. If we pass a
```
[^699]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 12 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.1351)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1351, lines 8–15)*:
```
3 lists a more tangible example that illustrates a typical role for this statement.
Example 34-3. closer.py
class MyError(Exception): pass
def stuff(file):
   file.write('Hello?')             # May be delayed in file buffer
   raise MyError()                  # <= Enable or disable me with a #
if __name__ == '__main__':
   file = open('temp.txt', 'w')     # Open an output file (this can fail too)
```
[^700]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 8 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 38: Managed Attributes** *(pp.1366–1410)*

This later chapter builds upon the concepts introduced here, particularly: None, __main__, __name__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^701]

**Annotation:** Forward reference: Chapter 38 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __main__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 39: Decorators** *(pp.1411–1455)*

This later chapter builds upon the concepts introduced here, particularly: None, __main__, __name__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^702]

**Annotation:** Forward reference: Chapter 39 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __main__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 40: Metaclasses** *(pp.1456–1500)*

This later chapter builds upon the concepts introduced here, particularly: None, args, argument.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^703]

**Annotation:** Forward reference: Chapter 40 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, args appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 38: Managed Attributes

*Source: Learning Python, 6th Edition, pages 1366–1410*

### Chapter Summary
This chapter covers managed attributes. Key topics include context managers, protocol, and module. Covers exception, class, statement. [^704]

### Concept-by-Concept Breakdown
#### **None** *(p.1371)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1371, lines 1–8)*:
```
passed in as None, and its return value is ignored.
Let’s look at a quick demo of the protocol in action. The file withas.py in
Example 34-6 defines a context-manager object that simply traces the entry and
exit of the with block in any with statement it is used for.
Example 34-6. withas.py
"A context manager that traces entry and exit of any with statement's block"
class TraceBlock:
   def message(self, arg):
```
[^705]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Enter__** *(p.1371)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1371, lines 9–16)*:
```
       print('running ' + arg)
   def __enter__(self):
       print('[starting with block]')
       return self
   def __exit__(self, exc_type, exc_value, exc_tb):
       if exc_type is None:
           print('[exited normally]\n')
       else:
```
[^706]
**Annotation:** This excerpt demonstrates '__enter__' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Exit__** *(p.1370)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1370, lines 15–22)*:
```
1. The expression is evaluated, resulting in an object known as a context
manager that must have __enter__ and __exit__ methods.
2. The context manager’s __enter__ method is called. The value it returns
is assigned to the variable in the as clause if present, or simply
discarded otherwise.
3. The code in the nested with block is executed.
4. If the with block raises an exception, the context manager’s
__exit__(type, value, traceback) method is called with the
```
[^707]
**Annotation:** This excerpt demonstrates '__exit__' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Init__** *(p.1390)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1390, lines 29–34)*:
```
specific display and state retention needs, you can always redefine inherited
methods such as __str__ and __init__ in Exception subclasses—as the next
section shows.
Custom Print Displays
As we saw in the preceding section, by default, instances of class-based
exceptions display whatever you passed to the class constructor when they are
```
[^708]
**Annotation:** This excerpt demonstrates '__init__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Main__** *(p.1380)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1380, lines 18–25)*:
```
$ python3 categoric.py
caught: <class '__main__.General'>
caught: <class '__main__.Specific1'>
caught: <class '__main__.Specific2'>
This code is mostly straightforward, but here are a few points to notice:
Exception superclass
Classes used to build exception category trees have very few requirements—
in fact, in this example, they are mostly empty, with bodies that do nothing
```
[^709]
**Annotation:** This excerpt demonstrates '__main__' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Name__** *(p.1371)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1371, lines 18–25)*:
```
           return False
if __name__ == '__main__':
   with TraceBlock() as action:
       action.message('test 1')
       print('reached')
   with TraceBlock() as action:
       action.message('test 2')
       raise TypeError
```
[^710]
**Annotation:** This excerpt demonstrates '__name__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Repr__** *(p.1392)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1392, lines 5–12)*:
```
display purposes because the built-in exception superclasses already have a
__str__ method, and __str__ is preferred to __repr__ in some contexts—
including error-message displays. If you define a __repr__, printing will
happily call the built-in superclass’s __str__ instead:
>>> class Oops(Exception):
        def __repr__(self): return 'Custom display not used'
>>> raise Oops("Nobody's perfect")
…
```
[^711]
**Annotation:** This excerpt demonstrates '__repr__' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Str__** *(p.1392)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1392, lines 3–10)*:
```
next section looks at state information options.
First, though, one fine point: you generally must redefine __str__ for exception
display purposes because the built-in exception superclasses already have a
__str__ method, and __str__ is preferred to __repr__ in some contexts—
including error-message displays. If you define a __repr__, printing will
happily call the built-in superclass’s __str__ instead:
>>> class Oops(Exception):
        def __repr__(self): return 'Custom display not used'
```
[^712]
**Annotation:** This excerpt demonstrates '__str__' as it appears in the primary text. The concept occurs 6 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Args** *(p.1390)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1390, lines 3–10)*:
```
>>> i = E('bad', 'stuff')
>>> i.args
('bad', 'stuff')
>>> print(i)
('bad', 'stuff')
>>> i
E('bad', 'stuff')
When intercepted in a try statement, the exception instance object gives access
```
[^713]
**Annotation:** This excerpt demonstrates 'args' as it appears in the primary text. The concept occurs 5 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.1389)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1389, lines 3–10)*:
```
is often as much logic as user-defined classes require. Unless you redefine the
constructors your classes inherit from built-ins, any constructor arguments you
pass to these classes are automatically saved in the instance’s args tuple
attribute and are automatically displayed when the instance is printed. An empty
tuple and display string are used if no constructor arguments are passed, and a
single argument displays as itself (not as a tuple) and serves as message details.
This explains why arguments passed to built-in exception classes show up in
error messages—any constructor arguments are attached to the instance and
```
[^714]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 7 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.1379)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1379, lines 2–9)*:
```
exceptions you define. Because Python largely requires user-defined exceptions
to inherit from built-in exception classes that provide useful defaults for printing
and state, the task of coding user-defined exceptions also involves understanding
the roles of these built-ins.
Exception Classes
Whether built-in or user-defined, exceptions work much of their magic by
superclass relationships: a raised exception matches an except clause if that
clause names the exception’s class or any superclass of it. Put another way, a try
```
[^715]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 32 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Assert** *(p.1366)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1366, lines 1–8)*:
```
Running this normally triggers the assertion error for positive numbers, but
running with -O does not:
$ python3
>>> import asserter
>>> asserter.f(-3)
9
>>> asserter.f(3)
Traceback (most recent call last):
```
[^716]
**Annotation:** This excerpt demonstrates 'assert' as it appears in the primary text. The concept occurs 16 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Assertion** *(p.1366)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1366, lines 1–8)*:
```
Running this normally triggers the assertion error for positive numbers, but
running with -O does not:
$ python3
>>> import asserter
>>> asserter.f(-3)
9
>>> asserter.f(3)
Traceback (most recent call last):
```
[^717]
**Annotation:** This excerpt demonstrates 'assertion' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Async** *(p.1367)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1367, lines 22–29)*:
```
automatically close themselves, thread locks that automatically lock and unlock,
and async-function tools that automatically await results per Chapter 20, but
programmers can code context managers of their own with classes, too. Let’s
take a brief look at the statement and its implicit protocol.
Basic with Usage
The basic format of the with statement looks like this, with an optional part in
square brackets here:
with expression [as variable]:
```
[^718]
**Annotation:** This excerpt demonstrates 'async' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.1387)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1387, lines 1–8)*:
```
args attribute as a tuple.
Exception: root of user-defined exceptions
The top-level root superclass of application-related exceptions. This is an
immediate subclass of BaseException and is a superclass to every other
built-in exception, except the system exit event classes (SystemExit,
KeyboardInterrupt, and GeneratorExit) and an exception-group class
we’ll ignore here. Nearly all user-defined classes should inherit from this
class, not BaseException. When this convention is followed, naming
```
[^719]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 39: Decorators** *(pp.1411–1455)*

This later chapter builds upon the concepts introduced here, particularly: None, __main__, __name__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^720]

**Annotation:** Forward reference: Chapter 39 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __main__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 40: Metaclasses** *(pp.1456–1500)*

This later chapter builds upon the concepts introduced here, particularly: None, args, argument.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^721]

**Annotation:** Forward reference: Chapter 40 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, args appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 41: All Good Things** *(pp.1501–1702)*

This later chapter builds upon the concepts introduced here, particularly: None, __init__, __main__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^722]

**Annotation:** Forward reference: Chapter 41 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, __init__ appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 39: Decorators

*Source: Learning Python, 6th Edition, pages 1411–1455*

### Chapter Summary
This chapter covers decorators. Key topics include unicode, module, and sequence. Covers exception. [^723]

### Concept-by-Concept Breakdown
#### **None** *(p.1421)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1421, lines 17–24)*:
```
except:
    x = None                     # Assume we got KeyError – only - here
…continue here with x…
The coder here assumes that the only sort of error that can happen when
indexing a dictionary is a missing key error. But because the name
myditctionary is misspelled, Python raises a NameError instead for the
undefined name reference, which the handler will silently catch and ignore.
Hence, the event handler will incorrectly fill in a None default for the dictionary
```
[^724]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Utf-8** *(p.1440)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1440, lines 1–8)*:
```
characters to be represented by employing a variable-number-of-bytes scheme
that’s both general and economical. In fact, because UTF-8 can handle any
Unicode code point, it’s become a de facto standard of sorts for text.
In UTF-8, character codes less than 128 are represented as a single byte; codes
between 128 and 0x7ff (2047) are turned into two bytes, where each byte has a
value between 128 and 255; and codes above 0x7ff are turned into three- or
four-byte sequences having values between 128 and 255. This keeps simple
ASCII strings compact, sidesteps byte ordering issues, and avoids null (zero)
```
[^725]
**Annotation:** This excerpt demonstrates 'UTF-8' as it appears in the primary text. The concept occurs 12 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Main__** *(p.1417)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1417, lines 6–13)*:
```
... 
(<class '__main__.E'>, E('info'))
(<class '__main__.E'>, E('info'))
(<class '__main__.E'>, E('info'))
When using sys.exception, the exception class is available from the instance
via __class__ or type (as shown), and the traceback is normally present in the
exception instance’s __traceback__ object. Though largely trivial, the new call
avoids an index or slice when only the instance is needed.
```
[^726]
**Annotation:** This excerpt demonstrates '__main__' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Name__** *(p.1426)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1426, lines 1–8)*:
```
In Chapter 25, we learned how to add self-test code to a Python file by using
the __name__ == '__main__' trick at the bottom of the file—a simple unit-
testing protocol. For more advanced testing purposes, Python comes with
two testing tools. The first, PyUnit (called unittest in the standard-library
manual), provides an object-oriented class framework for specifying and
customizing test cases and expected results. It mimics the JUnit framework
for Java and is a sophisticated class-based unit testing system.
The doctest standard-library module provides a second and simpler
```
[^727]
**Annotation:** This excerpt demonstrates '__name__' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Args** *(p.1432)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1432, lines 18–25)*:
```
to IndexError, and print the instance you catch.
3. Error handling: Write a function called safe(func, *pargs,
**kargs) that runs any function with any number of positional and/or
keyword arguments by using the * arbitrary arguments header and call
syntax, catches any exception raised while the function runs, and prints
the exception using the exc_info call in the sys module. Then use your
safe function to run your oops function from exercise 1 or 2. Put safe
in a module file called exctools.py, and pass it the oops function
```
[^728]
**Annotation:** This excerpt demonstrates 'args' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.1444)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1444, lines 25–30)*:
```
the encoding to use is either a platform default or a provided encoding
argument to open. Text mode files also support universal newline (a.k.a.
end-of-line) translation, BOMs, and other encoding arguments.
When a file is opened in binary mode by adding a b to the mode string
argument in the open call, reading its data does not decode it in any way
and simply returns its content raw and unchanged as a bytes object.
```
[^729]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Array** *(p.1444)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1444, lines 5–12)*:
```
distinction between text and binary data.
The bytearray Object
Though less commonly used, Python also comes with bytearray, a variant of
bytes that is mutable and so supports in-place changes. The bytearray type
provides the usual string operations that str and bytes do but also has many of
the same in-place change operations as lists (e.g., append and extend methods
and assignment to indexes). Assuming your strings can be treated as raw bytes,
bytearray adds direct in-place mutability for string data—something long
```
[^730]
**Annotation:** This excerpt demonstrates 'array' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.1440)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1440, lines 3–10)*:
```
Unicode code point, it’s become a de facto standard of sorts for text.
In UTF-8, character codes less than 128 are represented as a single byte; codes
between 128 and 0x7ff (2047) are turned into two bytes, where each byte has a
value between 128 and 255; and codes above 0x7ff are turned into three- or
four-byte sequences having values between 128 and 255. This keeps simple
ASCII strings compact, sidesteps byte ordering issues, and avoids null (zero)
bytes that can cause problems for C libraries and networking. In Python:
>>> len('a'.encode('UTF-8'))      # ASCII: encodes in 1 byte
```
[^731]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 20 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Assert** *(p.1428)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1428, lines 11–18)*:
```
Chapter 39) optimizes bytecode, it yields a very modest performance boost,
and is not commonly used except to remove debugging code and asserts.
Though a last resort, you can also move parts of your program to a compiled
language such as C to boost performance; see Python’s manuals for more on
C extensions. In addition, Python’s speed tends to improve over time, so
upgrading to later releases may boost speed too—once you verify that they
are faster for your code, that is (though long since fixed, Python 3.X’s early
releases were radically slower than 2.X in some roles).
```
[^732]
**Annotation:** This excerpt demonstrates 'assert' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.1416)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1416, lines 2–9)*:
```
superclasses. As we’ve also learned, though, because in this case you can also
get the exception type by fetching the __class__ attribute or type result of the
instance obtained with the as clause, sys.exc_info is rarely useful outside the
empty except:
try:
    …
except General as instance:
    # instance.__class__ or type(instance) is the exception class
```
[^733]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Binary Mode** *(p.1444)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1444, lines 27–30)*:
```
end-of-line) translation, BOMs, and other encoding arguments.
When a file is opened in binary mode by adding a b to the mode string
argument in the open call, reading its data does not decode it in any way
and simply returns its content raw and unchanged as a bytes object.
```
[^734]
**Annotation:** This excerpt demonstrates 'binary mode' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.1411)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1411, lines 16–23)*:
```
    except EOFError:
        break                    # Exit loop at end-of-file
    else:
        …process next line here…
Several other built-in exceptions are similarly signals, not errors—for example,
calling sys.exit() and pressing Ctrl+C on your keyboard raise SystemExit
and KeyboardInterrupt, respectively.
Python also has a set of built-in exceptions that represent warnings rather than
```
[^735]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Bytecode** *(p.1428)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1428, lines 1–8)*:
```
Python programs may be shipped in their source (.py) or bytecode (.pyc)
forms, and .zip files may act like package folders. When your code is ready
to go live as an open source tool, also see the web for resources on Python’s
pip installer system.
Optimization options
When speed counts, there are numerous ways to optimize your Python
programs, as enumerated in Chapter 2. For instance, the PyPy system
demoed in Chapter 21 provides an automatic speed boost today, and others
```
[^736]
**Annotation:** This excerpt demonstrates 'bytecode' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.1416)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1416, lines 1–8)*:
```
determine the specific exception type when catching exception category
superclasses. As we’ve also learned, though, because in this case you can also
get the exception type by fetching the __class__ attribute or type result of the
instance obtained with the as clause, sys.exc_info is rarely useful outside the
empty except:
try:
    …
except General as instance:
```
[^737]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 6 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.1413)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1413, lines 3–10)*:
```
finalized, regardless of whether an error occurs during processing or not.
For example, some servers require connections to be closed in order to terminate
a session. Similarly, output files may require close calls to flush their buffers to
disk for waiting consumers; input files may consume file descriptors if not
closed; and CPython closes open files when garbage-collecting them, but this
isn’t always predictable or reliable.
As we saw in Chapter 34, the most general and explicit way to guarantee
termination actions for a specific block of code is the try/finally combination:
```
[^738]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 6 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 40: Metaclasses** *(pp.1456–1500)*

This later chapter builds upon the concepts introduced here, particularly: None, UTF-8, args.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^739]

**Annotation:** Forward reference: Chapter 40 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, UTF-8 appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.


**Chapter 41: All Good Things** *(pp.1501–1702)*

This later chapter builds upon the concepts introduced here, particularly: None, UTF-8, __main__.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^740]

**Annotation:** Forward reference: Chapter 41 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, UTF-8 appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 40: Metaclasses

*Source: Learning Python, 6th Edition, pages 1456–1500*

### Chapter Summary
This chapter covers metaclasses. Key topics include unicode, sequence, and module. [^741]

### Concept-by-Concept Breakdown
#### **None** *(p.1480)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1480, lines 20–27)*:
```
>>> vals = ['code', {'app': ('
', None, 1.23, 99)}]
>>> json.dumps(vals)
'["code", {"app": ["\\ud83d\\ude42", null, 1.23, 99]}]'
>>> text = json.dumps(vals)                          # Save to/load from str
>>> anew = json.loads(text)
>>> anew
['code', {'app': ['
```
[^742]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Utf-8** *(p.1489)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1489, lines 1–8)*:
```
Notepad flux: Notepad recently changed its encoding options for saves. Today, it offers ANSI
(the host’s default), UTF-16 in little- and big-endian flavors, and UTF-8 with and without a
BOM, and defaults to UTF-8. When this book’s prior edition was penned, Notepad had UTF-8
with an implied BOM, and its “Unicode” meant UTF-16—which, of course, is just one of the
very many kinds of Unicode encoding. The narrative here has been updated to reflect the new
choices, but this naturally is just the story today. Because this book staunchly refuses to
become a Notepad doc, translate save options as needed to the Notepad on a PC near you.
Making BOMs in Python
```
[^743]
**Annotation:** This excerpt demonstrates 'UTF-8' as it appears in the primary text. The concept occurs 20 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Args** *(p.1466)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1466, lines 27–33)*:
```
>>> sorted(set(dir(b'abc')) - set(dir(bytearray(b'abc'))))
{'__bytes__', '__getnewargs__'}
 
>>> sorted(set(dir(bytearray(b'abc'))) - set(dir(b'abc')))
['__alloc__', '__delitem__', '__iadd__', '__imul__', '__release_buffer__',
'__setitem__', 'append', 'clear', 'copy', 'extend', 'insert', 'pop', 'remove', 
'reverse']
```
[^744]
**Annotation:** This excerpt demonstrates 'args' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.1469)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1469, lines 23–27)*:
```
newline translations.
In terms of code, the second positional argument to open (a.k.a. mode when
passed by keyword) determines whether you want text or binary processing and
types—adding a b to the mode string implies binary mode. The default mode is
rt, which is the same as r, and means text input. In addition, the mode argument
```
[^745]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Array** *(p.1466)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1466, lines 1–8)*:
```
quick tour here to sample their flavor. First off, you can call bytearray as a
function passing a bytes (not a str) to make a new mutable sequence of small
(0…255) integers:
>>> B = b'code'               # A str 'code' does not work: not bytes
>>> C = bytearray(B)
>>> C
bytearray(b'code')
>>> C[0], chr(C[0])           # ASCII code-point integer for 'c'
```
[^746]
**Annotation:** This excerpt demonstrates 'array' as it appears in the primary text. The concept occurs 10 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.1463)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1463, lines 1–8)*:
```
AttributeError: 'bytes' object has no attribute 'format'
>>> kind = 'fine'
>>> f'a {kind} string'                        # But f-strings only for str
'a fine string'
>>> bf'a {kind} string'
SyntaxError: invalid syntax
There are arguably sound reasons that formatting shouldn’t work on bytes—it’s
just raw bytes, after all, which happens to accept and print ASCII characters as
```
[^747]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 15 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Attribute** *(p.1499)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1499, lines 1–8)*:
```
Chapter 38. Managed Attributes
This chapter expands on the attribute interception techniques introduced earlier,
introduces another, and employs them in a handful of larger examples. Like
everything in this part of the book, this chapter is classified as an advanced topic
and optional reading, because most applications programmers don’t need to care
about the material discussed here—they can fetch and set attributes on objects
without concern for attribute implementations.
Especially for tools builders, though, managing attribute access can be an
```
[^748]
**Annotation:** This excerpt demonstrates 'attribute' as it appears in the primary text. The concept occurs 15 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Binary Mode** *(p.1471)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1471, lines 1–8)*:
```
Next, let’s write a text file and read it back in both text and binary modes. Notice
in the following how text mode requires us to provide a str for writing, rb
distinguishes binary-mode input, and reading gives us a str or bytes depending
on the mode (opens and transfer operations are strung together here into one-
liners just for brevity; again, remember to close explicitly in production code,
and possibly in some IDEs and outside CPython):
$ py -3                                      # Run on Windows (no \r on Unix) 
>>> open('temp.txt', 'w').write('abc\n')     # Text-mode output, provide a str
```
[^749]
**Annotation:** This excerpt demonstrates 'binary mode' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Break** *(p.1491)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1491, lines 14–21)*:
```
more details on the BOM. And if you really want to drop the bomb in Python
(and stretch this section’s silly bit to its breaking point), Unicode emoji
characters do the job:
>>> open('boms.txt', 'w', encoding='utf-8-sig').write('
' * 10)
10
>>> open('boms.txt', encoding='utf-8-sig').read()
'
```
[^750]
**Annotation:** This excerpt demonstrates 'break' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Class** *(p.1499)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1499, lines 3–10)*:
```
introduces another, and employs them in a handful of larger examples. Like
everything in this part of the book, this chapter is classified as an advanced topic
and optional reading, because most applications programmers don’t need to care
about the material discussed here—they can fetch and set attributes on objects
without concern for attribute implementations.
Especially for tools builders, though, managing attribute access can be an
important part of flexible APIs. Moreover, an understanding of the descriptor
model covered here can make related tools such as slots and properties more
```
[^751]
**Annotation:** This excerpt demonstrates 'class' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Close** *(p.1470)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1470, lines 12–19)*:
```
>>> size = file.write('abc\n')       # Returns number characters written
>>> file.close()                     # Manual close to flush output buffer
>>> file = open('temp.txt')          # Default mode is "r" == "rt": text input
>>> text = file.read()
>>> text
'abc\n'
As a refresher, the first argument to open is the file’s pathname—the address of
a file in the host’s folder hierarchy that’s either absolute or relative to the current
```
[^752]
**Annotation:** This excerpt demonstrates 'close' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Closure** *(p.1476)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1476, lines 15–22)*:
```
files and strings, content possibilities are largely endless.
In the interest of full disclosure, Python’s open accepts additional arguments that
modify its behavior. Among them, newline changes newline mapping; errors
specifies handling of encoding and decoding errors (e.g., 'surrogateescape'
replaces failing bytes with sequences that can be used to restore them on output);
and buffering alters, well, buffering. Because their defaults are generally what
you’ll use, we’ll defer to the Python standard-library manual for the fine print on
these and other advanced file options.
```
[^753]
**Annotation:** This excerpt demonstrates 'closure' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Constructor** *(p.1463)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1463, lines 26–31)*:
```
So far in this section, we’ve been making bytes objects with the b'…' literal
syntax, but they can also be created by calling the bytes constructor with a str
and an encoding name, by calling bytes with an iterable of integers representing
byte values, or by encoding a str object per the default (or passed-in) encoding.
We met some of these earlier in the guise of conversions, but they’re more
general than previously told.
```
[^754]
**Annotation:** This excerpt demonstrates 'constructor' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Debugging** *(p.1498)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1498, lines 18–20)*:
```
file extensions (e.g., .txt) don’t mean anything to Python and are technically optional; some IDEs
that hang on to objects for debugging may require manual close calls to flush changes too; and
purists take note that file is no longer a built-in name in Python and OK to use as a variable here!
```
[^755]
**Annotation:** This excerpt demonstrates 'debugging' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Def** *(p.1458)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1458, lines 1–8)*:
```
# A UTF-8 line works if this file is also saved as UTF-8 to make its mystr1 
# text match.  Because UTF-8 is the default for source, the line above is 
# optional if the file is saved as UTF-8 or its text is all UTF-8 compatible
# (e.g., ASCII, which is a subset of both the Latin-1 and UTF-8 encodings).
#----------------------------------------------------------------------------
myStr1 = 'AÄBèC'                                      # Raw, per source encoding
myStr2 = 'A\xc4B\xe8C'                                # Hex code-point escapes
myStr3 = 'A\u00c4B\U000000e8C'                        # Unicode short/long escapes
```
[^756]
**Annotation:** This excerpt demonstrates 'def' as it appears in the primary text. The concept occurs 10 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


#### **Later Chapters in This Book**


**Chapter 41: All Good Things** *(pp.1501–1702)*

This later chapter builds upon the concepts introduced here, particularly: None, UTF-8, args.... The material extends the foundational understanding established in this chapter by exploring more advanced applications, deeper implementation details, or integration with other Python features. Readers seeking to deepen their mastery of these topics should plan to revisit this chapter after completing the current material.
[^757]

**Annotation:** Forward reference: Chapter 41 shares 5 concept(s) with this chapter, indicating topical continuity and progressive skill development. The concepts None, UTF-8 appear in both contexts, suggesting that understanding from this chapter will directly transfer to and be expanded upon in the later material.



---

## Chapter 41: All Good Things

*Source: Learning Python, 6th Edition, pages 1501–1702*

### Chapter Summary
Besides studying the specifics behind these four attribute interception
techniques, this chapter also presents an opportunity to explore programs larger
than most we’ve seen elsewhere in this book Key topics include decorators, descriptor, and metaclasses. Covers class, decorator, method. [^758]

### Concept-by-Concept Breakdown
#### **Mro** *(p.1679)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1679, lines 1–8)*:
```
tree as follows:
a. Search the __dict__ of all metaclasses on the __mro__ found
at C’s __class__
b. If a data descriptor was found in step a, call its __get__ and
exit
c. Else, call any descriptor or return a value in the __dict__ of a
class on C’s own __mro__
d. Else, call a nondata descriptor or return a value found in step a
```
[^759]
**Annotation:** This excerpt demonstrates 'MRO' as it appears in the primary text. The concept occurs 8 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **None** *(p.1520)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1520, lines 22–29)*:
```
class Property:
   def __init__(self, fget=None, fset=None, fdel=None, doc=None):
       self.fget = fget
       self.fset = fset
       self.fdel = fdel                                  # Save unbound methods
       self.__doc__ = doc                                # or other callables
   def __get__(self, instance, instancetype=None):
       if instance is None:
```
[^760]
**Annotation:** This excerpt demonstrates 'None' as it appears in the primary text. The concept occurs 7 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Pythonpath** *(p.1591)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1591, lines 18–25)*:
```
of the decorator’s test code, though incurring extra admin costs that skew results
slightly (add Chapter 21’s folder to your PYTHONPATH or sys.path, or go there
to run this):
>>> def listcomp(N): [x * 2 for x in range(N)]
>>> import timer                                    # Chapter 21 techniques
>>> timer.total(1, listcomp, 1_000_000)
(0.08150088600814342, None)
>>> timer.bestoftotal(5, 1, listcomp, 1_000_000)
```
[^761]
**Annotation:** This excerpt demonstrates 'PYTHONPATH' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Utf-8** *(p.1700)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1700, lines 25–32)*:
```
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" type="image/x-icon" href="{SITE}/favicon.ico">
<style> 
body  {{font-family: Arial, Helvetica, sans-serif;}} 
.cert {{background-color: cornsilk; padding: 16px; border: medium solid black;}}
</style>
```
[^762]
**Annotation:** This excerpt demonstrates 'UTF-8' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Init__** *(p.1569)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1569, lines 8–15)*:
```
    class Wrapper:
        def __init__(self, *args):              # On instance creation
            self.wrapped = cls(*args)
        def __getattr__(self, name):            # On attribute fetch
            return getattr(self.wrapped, name)
    return Wrapper
@decorator
class C:                             # C = decorator(C)
```
[^763]
**Annotation:** This excerpt demonstrates '__init__' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Main__** *(p.1656)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1656, lines 29–36)*:
```
In MetaTwo.new:
...<class '__main__.MetaTwo'>
...Hack
...(<class '__main__.Super'>,)
...{'__module__': '__main__', 'data': 1, 'meth': <function Hack.meth at 0x…>}
In MetaTwo.init:
...<class '__main__.Hack'>
...Hack
```
[^764]
**Annotation:** This excerpt demonstrates '__main__' as it appears in the primary text. The concept occurs 6 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Name__** *(p.1578)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1578, lines 9–16)*:
```
       self.calls += 1
       print(f'call {self.calls} to {self.func.__name__}')
       return self.func(*args, **kwargs)
@tracer
def hack(a, b, c):           # Same as: hack = tracer(hack)
   print(a + b + c)         # Triggers tracer.__init__
@tracer
def code(x, y):              # Same as: code = tracer(code)
```
[^765]
**Annotation:** This excerpt demonstrates '__name__' as it appears in the primary text. The concept occurs 2 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Repr__** *(p.1540)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1540, lines 24–30)*:
```
As a coda, you should also now be able to work out why the Manager class
coded in Example 28-11 of Chapter 28 had to code a __repr__ to route printing
requests to its wrapped object. Just like __str__ in our demo, object provides a
default __repr__, which would prevent print operations from invoking a
__getattr__. Technically speaking, object defines both __str__ and
__repr__, but its __str__ simply calls __repr__.
That said, object’s defaults are largely a moot point: like all built-in operations,
```
[^766]
**Annotation:** This excerpt demonstrates '__repr__' as it appears in the primary text. The concept occurs 4 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **__Str__** *(p.1682)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1682, lines 1–8)*:
```
>>> class D(type):
        def __str__(self): return('D class')
>>> class C(D):
        pass
>>> C.__str__(C), str(C)                  # Explicit=>super, built-in=>metaclass!
('D class', "<class '__main__.C'>")
>>> class C(D):
        def __str__(self): return('C class')
```
[^767]
**Annotation:** This excerpt demonstrates '__str__' as it appears in the primary text. The concept occurs 10 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Annotation** *(p.1636)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1636, lines 3–10)*:
```
func(1, 2, c=3)                              # Runs onCall, argchecks in scope
# Using function annotations
def rangetest(func):
   def onCall(*pargs, **kargs):
       argchecks = func.__annotations__
       print(argchecks)
       for check in argchecks:
           pass                             # Add validation code here
```
[^768]
**Annotation:** This excerpt demonstrates 'annotation' as it appears in the primary text. The concept occurs 8 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Args** *(p.1627)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1627, lines 24–31)*:
```
@rangetest(a=(1, 10), b=(1, 10), c=(1, 10), d=(1, 10))
def omitargs(a, b=7, c=8, d=9):
   print(a, b, c, d)
omitargs(1, 2, 3, 4)           # Positionals
omitargs(1, 2, 3)              # Default d
omitargs(1, 2, 3, d=4)         # Keyword d
omitargs(1, d=4)               # Default b and c
omitargs(d=4, a=1)             # Ditto
```
[^769]
**Annotation:** This excerpt demonstrates 'args' as it appears in the primary text. The concept occurs 15 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Argument** *(p.1630)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1630, lines 1–8)*:
```
Run a dir call on function and code objects for more details.
Argument assumptions
Given the decorated function’s set of expected argument names, the solution
relies upon two constraints on argument passing order imposed by Python and
covered in Chapter 18:
At the call, all positional arguments appear before all keyword
arguments.
In the def, all nondefault arguments appear before all default
```
[^770]
**Annotation:** This excerpt demonstrates 'argument' as it appears in the primary text. The concept occurs 19 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **As** *(p.1669)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1669, lines 1–8)*:
```
By contrast, classes do acquire methods of their metaclasses by virtue of the
instance relationship. Metaclasses define a separate inheritance tree, which is
a source of class behavior that processes classes themselves. For classes only,
inheritance first searches the primary tree formed by the class and its
superclasses and then falls back on the secondary tree formed by the class’s
metaclass and its superclasses as a separate search. When a name is available
to a class in both a metaclass and a superclass, the superclass version is used.
Metaclass declarations are also inherited by subclasses
```
[^771]
**Annotation:** This excerpt demonstrates 'as' as it appears in the primary text. The concept occurs 51 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Assert** *(p.1621)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1621, lines 8–15)*:
```
to check the percentage to make sure it’s not too large or too small. We could
implement such a check with either if or assert statements in the method itself,
using inline tests:
class Person:
    def giveRaise(self, percent):                # Validate with inline code
        if percent < 0.0 or percent > 1.0:
            raise TypeError, 'percent invalid'
        self.pay = int(self.pay * (1 + percent))
```
[^772]
**Annotation:** This excerpt demonstrates 'assert' as it appears in the primary text. The concept occurs 3 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.


#### **Async** *(p.1692)*

**Verbatim Educational Excerpt** *(Learning Python Ed.6, p.1692, lines 19–26)*:
```
hosted the rise of f-string literals, named-assignment expressions, match
statements, type hinting, async coroutines, dictionary union, star-unpacking
proliferation, underscore digit separators, module attribute hooks, exception
groups, dictionary-key insertion order, positional-only function arguments, hash-
based bytecode files, the sys.executable snub, and other superfluous
additions, opinionated deprecations, and tangled mutations we’ve met along the
way.
Moreover, this tsunami of mods simply added to the flood of complexity and
```
[^773]
**Annotation:** This excerpt demonstrates 'async' as it appears in the primary text. The concept occurs 1 time(s) on this page, making it a key anchor point for understanding how the text introduces and develops this topic. Use this passage to verify precise terminology, definitions, and contextual usage patterns.



### **TPM Implementation Section** *(ORIGINAL)*

_Not enough source material found to derive implementation._


### **See Also: Cross-Book References & Forward Connections**


---


---

### **Footnotes**

[^1]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 16, lines 1–25).
[^2]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 24, lines 29–30).
[^3]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 17, lines 18–25).
[^4]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 33, lines 2–9).
[^5]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 40, lines 1–8).
[^6]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 29, lines 2–9).
[^7]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 18, lines 17–24).
[^8]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 29, lines 16–23).
[^9]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 32, lines 2–9).
[^10]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 22, lines 3–10).
[^11]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 29, lines 16–23).
[^12]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 24, lines 24–30).
[^13]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 25, lines 1–8).
[^14]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 29, lines 16–23).
[^15]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 16, lines 6–13).
[^16]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 33, lines 1–8).
[^17]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 45, lines 1–1).
[^18]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 77, lines 1–1).
[^19]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 109, lines 1–1).
[^20]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 45, lines 1–25).
[^21]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 60, lines 16–23).
[^22]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 56, lines 7–14).
[^23]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 47, lines 20–26).
[^24]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 75, lines 1–8).
[^25]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 46, lines 24–25).
[^26]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 48, lines 17–24).
[^27]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 51, lines 2–9).
[^28]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 74, lines 3–10).
[^29]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 50, lines 1–8).
[^30]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 65, lines 9–16).
[^31]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 71, lines 1–8).
[^32]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 48, lines 1–8).
[^33]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 64, lines 24–31).
[^34]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 46, lines 24–25).
[^35]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 64, lines 26–32).
[^36]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 77, lines 1–1).
[^37]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 109, lines 1–1).
[^38]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 141, lines 1–1).
[^39]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 77, lines 1–25).
[^40]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 91, lines 23–30).
[^41]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 78, lines 2–9).
[^42]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 93, lines 12–19).
[^43]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 106, lines 14–21).
[^44]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 82, lines 1–8).
[^45]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 80, lines 1–8).
[^46]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 98, lines 34–35).
[^47]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 93, lines 4–11).
[^48]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 93, lines 4–11).
[^49]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 78, lines 13–20).
[^50]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 99, lines 1–8).
[^51]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 87, lines 28–33).
[^52]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 98, lines 10–17).
[^53]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 99, lines 3–10).
[^54]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 96, lines 15–22).
[^55]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 109, lines 1–1).
[^56]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 141, lines 1–1).
[^57]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 176, lines 1–1).
[^58]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 109, lines 1–25).
[^59]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 134, lines 1–8).
[^60]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 132, lines 1–8).
[^61]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 109, lines 20–27).
[^62]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 135, lines 19–26).
[^63]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 109, lines 14–21).
[^64]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 112, lines 4–11).
[^65]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 136, lines 1–8).
[^66]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 109, lines 15–22).
[^67]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 116, lines 8–15).
[^68]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 133, lines 28–30).
[^69]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 111, lines 16–23).
[^70]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 137, lines 1–8).
[^71]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 111, lines 10–17).
[^72]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 137, lines 9–16).
[^73]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 114, lines 2–9).
[^74]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 141, lines 1–1).
[^75]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 176, lines 1–1).
[^76]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 211, lines 1–1).
[^77]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 141, lines 1–25).
[^78]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 146, lines 9–16).
[^79]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 163, lines 26–32).
[^80]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 171, lines 9–16).
[^81]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 143, lines 13–20).
[^82]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 147, lines 10–17).
[^83]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 162, lines 17–24).
[^84]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 147, lines 9–16).
[^85]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 156, lines 4–11).
[^86]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 151, lines 2–9).
[^87]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 158, lines 6–13).
[^88]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 147, lines 31–38).
[^89]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 147, lines 23–30).
[^90]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 142, lines 22–29).
[^91]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 158, lines 17–24).
[^92]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 148, lines 9–16).
[^93]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 176, lines 1–1).
[^94]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 211, lines 1–1).
[^95]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 266, lines 1–1).
[^96]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 176, lines 1–25).
[^97]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 204, lines 13–20).
[^98]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 207, lines 17–24).
[^99]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 177, lines 14–21).
[^100]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 197, lines 1–8).
[^101]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 197, lines 31–32).
[^102]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 185, lines 19–26).
[^103]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 208, lines 20–21).
[^104]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 197, lines 25–32).
[^105]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 207, lines 15–22).
[^106]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 176, lines 19–26).
[^107]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 203, lines 18–25).
[^108]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 177, lines 22–29).
[^109]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 182, lines 7–14).
[^110]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 188, lines 7–14).
[^111]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 203, lines 10–17).
[^112]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 211, lines 1–1).
[^113]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 266, lines 1–1).
[^114]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 316, lines 1–1).
[^115]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 211, lines 1–25).
[^116]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 232, lines 12–19).
[^117]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 241, lines 24–31).
[^118]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 257, lines 9–16).
[^119]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 239, lines 5–12).
[^120]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 213, lines 1–8).
[^121]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 239, lines 22–28).
[^122]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 221, lines 26–33).
[^123]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 228, lines 5–12).
[^124]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 222, lines 1–8).
[^125]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 213, lines 14–21).
[^126]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 216, lines 6–13).
[^127]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 228, lines 26–33).
[^128]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 247, lines 5–12).
[^129]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 254, lines 7–14).
[^130]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 255, lines 16–23).
[^131]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 266, lines 1–1).
[^132]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 316, lines 1–1).
[^133]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 361, lines 1–1).
[^134]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 266, lines 1–25).
[^135]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 309, lines 5–12).
[^136]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 289, lines 19–26).
[^137]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 281, lines 16–23).
[^138]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 315, lines 6–13).
[^139]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 288, lines 32–36).
[^140]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 276, lines 10–17).
[^141]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 276, lines 6–13).
[^142]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 309, lines 13–20).
[^143]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 272, lines 28–30).
[^144]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 297, lines 3–10).
[^145]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 307, lines 8–15).
[^146]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 305, lines 5–12).
[^147]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 277, lines 9–16).
[^148]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 270, lines 16–23).
[^149]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 300, lines 1–8).
[^150]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 316, lines 1–1).
[^151]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 361, lines 1–1).
[^152]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 396, lines 1–1).
[^153]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 316, lines 1–25).
[^154]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 317, lines 17–24).
[^155]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 342, lines 12–19).
[^156]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 343, lines 7–14).
[^157]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 317, lines 4–11).
[^158]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 329, lines 1–8).
[^159]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 321, lines 11–18).
[^160]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 352, lines 27–34).
[^161]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 340, lines 11–18).
[^162]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 345, lines 3–10).
[^163]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 329, lines 4–11).
[^164]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 337, lines 5–12).
[^165]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 356, lines 11–18).
[^166]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 356, lines 1–8).
[^167]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 360, lines 16–23).
[^168]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 357, lines 24–28).
[^169]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 361, lines 1–1).
[^170]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 396, lines 1–1).
[^171]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 436, lines 1–1).
[^172]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 361, lines 1–25).
[^173]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 371, lines 2–9).
[^174]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 380, lines 27–28).
[^175]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 392, lines 1–8).
[^176]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 392, lines 1–8).
[^177]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 391, lines 36–43).
[^178]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 391, lines 42–49).
[^179]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 385, lines 12–19).
[^180]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 391, lines 38–45).
[^181]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 372, lines 9–16).
[^182]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 391, lines 12–19).
[^183]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 391, lines 49–56).
[^184]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 394, lines 25–28).
[^185]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 368, lines 6–13).
[^186]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 373, lines 1–8).
[^187]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 373, lines 20–27).
[^188]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 396, lines 1–1).
[^189]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 436, lines 1–1).
[^190]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 466, lines 1–1).
[^191]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 396, lines 1–25).
[^192]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 413, lines 2–9).
[^193]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 419, lines 1–8).
[^194]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 429, lines 21–28).
[^195]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 415, lines 1–8).
[^196]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 418, lines 14–21).
[^197]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 404, lines 7–14).
[^198]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 410, lines 33–36).
[^199]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 398, lines 27–33).
[^200]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 401, lines 10–17).
[^201]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 420, lines 18–25).
[^202]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 401, lines 20–27).
[^203]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 401, lines 13–20).
[^204]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 415, lines 3–10).
[^205]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 401, lines 19–26).
[^206]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 407, lines 18–25).
[^207]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 436, lines 1–1).
[^208]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 466, lines 1–1).
[^209]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 501, lines 1–1).
[^210]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 436, lines 1–25).
[^211]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 446, lines 19–26).
[^212]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 442, lines 25–31).
[^213]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 448, lines 12–19).
[^214]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 443, lines 2–9).
[^215]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 441, lines 1–8).
[^216]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 441, lines 5–12).
[^217]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 460, lines 9–16).
[^218]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 445, lines 14–21).
[^219]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 456, lines 15–22).
[^220]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 457, lines 11–18).
[^221]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 450, lines 12–19).
[^222]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 443, lines 2–9).
[^223]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 454, lines 25–32).
[^224]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 438, lines 27–30).
[^225]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 440, lines 35–42).
[^226]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 466, lines 1–1).
[^227]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 501, lines 1–1).
[^228]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 541, lines 1–1).
[^229]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 466, lines 1–25).
[^230]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 489, lines 1–8).
[^231]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 472, lines 10–17).
[^232]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 479, lines 12–19).
[^233]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 472, lines 2–9).
[^234]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 472, lines 4–11).
[^235]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 481, lines 13–20).
[^236]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 494, lines 1–8).
[^237]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 472, lines 9–16).
[^238]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 479, lines 11–18).
[^239]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 479, lines 11–18).
[^240]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 494, lines 1–8).
[^241]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 466, lines 1–8).
[^242]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 466, lines 1–8).
[^243]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 474, lines 18–25).
[^244]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 467, lines 18–25).
[^245]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 501, lines 1–1).
[^246]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 541, lines 1–1).
[^247]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 566, lines 1–1).
[^248]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 501, lines 1–25).
[^249]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 537, lines 1–8).
[^250]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 519, lines 13–20).
[^251]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 519, lines 7–14).
[^252]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 504, lines 1–8).
[^253]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 502, lines 10–17).
[^254]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 532, lines 1–8).
[^255]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 501, lines 18–25).
[^256]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 518, lines 31–32).
[^257]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 510, lines 6–13).
[^258]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 517, lines 9–16).
[^259]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 520, lines 26–30).
[^260]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 523, lines 3–10).
[^261]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 536, lines 19–26).
[^262]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 536, lines 24–31).
[^263]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 520, lines 2–9).
[^264]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 541, lines 1–1).
[^265]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 566, lines 1–1).
[^266]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 601, lines 1–1).
[^267]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 541, lines 1–25).
[^268]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 541, lines 32–35).
[^269]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 556, lines 10–17).
[^270]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 551, lines 3–10).
[^271]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 563, lines 1–8).
[^272]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 542, lines 10–17).
[^273]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 565, lines 28–35).
[^274]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 564, lines 2–9).
[^275]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 548, lines 16–23).
[^276]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 546, lines 16–23).
[^277]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 551, lines 1–8).
[^278]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 564, lines 1–8).
[^279]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 549, lines 11–18).
[^280]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 557, lines 16–23).
[^281]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 551, lines 12–19).
[^282]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 564, lines 13–20).
[^283]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 566, lines 1–1).
[^284]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 601, lines 1–1).
[^285]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 636, lines 1–1).
[^286]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 566, lines 1–25).
[^287]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 582, lines 8–15).
[^288]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 576, lines 29–32).
[^289]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 576, lines 8–15).
[^290]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 577, lines 14–21).
[^291]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 577, lines 14–21).
[^292]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 597, lines 7–14).
[^293]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 596, lines 26–31).
[^294]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 596, lines 14–21).
[^295]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 596, lines 1–8).
[^296]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 592, lines 17–24).
[^297]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 566, lines 1–8).
[^298]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 592, lines 17–24).
[^299]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 570, lines 20–27).
[^300]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 570, lines 20–27).
[^301]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 567, lines 10–17).
[^302]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 601, lines 1–1).
[^303]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 636, lines 1–1).
[^304]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 681, lines 1–1).
[^305]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 601, lines 1–25).
[^306]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 616, lines 4–11).
[^307]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 610, lines 8–15).
[^308]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 613, lines 13–20).
[^309]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 630, lines 3–10).
[^310]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 602, lines 4–11).
[^311]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 610, lines 21–28).
[^312]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 615, lines 1–8).
[^313]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 621, lines 15–22).
[^314]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 621, lines 15–22).
[^315]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 619, lines 4–11).
[^316]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 604, lines 7–14).
[^317]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 618, lines 26–32).
[^318]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 630, lines 22–29).
[^319]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 635, lines 1–8).
[^320]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 601, lines 7–14).
[^321]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 636, lines 1–1).
[^322]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 681, lines 1–1).
[^323]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 721, lines 1–1).
[^324]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 636, lines 1–25).
[^325]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 648, lines 9–16).
[^326]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 679, lines 14–21).
[^327]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 671, lines 1–8).
[^328]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 675, lines 1–8).
[^329]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 666, lines 1–8).
[^330]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 659, lines 25–31).
[^331]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 659, lines 1–8).
[^332]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 657, lines 15–18).
[^333]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 643, lines 8–15).
[^334]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 668, lines 15–22).
[^335]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 645, lines 15–22).
[^336]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 640, lines 34–35).
[^337]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 636, lines 7–14).
[^338]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 666, lines 17–24).
[^339]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 649, lines 23–30).
[^340]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 681, lines 1–1).
[^341]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 721, lines 1–1).
[^342]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 756, lines 1–1).
[^343]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 681, lines 1–25).
[^344]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 692, lines 7–14).
[^345]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 691, lines 25–32).
[^346]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 720, lines 2–9).
[^347]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 720, lines 5–12).
[^348]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 699, lines 2–9).
[^349]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 682, lines 2–9).
[^350]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 708, lines 9–16).
[^351]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 684, lines 1–8).
[^352]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 720, lines 1–8).
[^353]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 694, lines 22–29).
[^354]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 719, lines 13–20).
[^355]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 685, lines 11–18).
[^356]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 706, lines 13–20).
[^357]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 694, lines 20–27).
[^358]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 687, lines 15–22).
[^359]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 721, lines 1–1).
[^360]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 756, lines 1–1).
[^361]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 786, lines 1–1).
[^362]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 721, lines 1–25).
[^363]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 731, lines 1–8).
[^364]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 724, lines 8–15).
[^365]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 723, lines 3–10).
[^366]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 722, lines 22–29).
[^367]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 722, lines 27–32).
[^368]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 726, lines 1–8).
[^369]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 728, lines 1–8).
[^370]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 725, lines 8–15).
[^371]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 752, lines 4–11).
[^372]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 721, lines 1–8).
[^373]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 747, lines 10–17).
[^374]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 724, lines 5–12).
[^375]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 740, lines 4–11).
[^376]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 726, lines 3–10).
[^377]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 746, lines 1–8).
[^378]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 756, lines 1–1).
[^379]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 786, lines 1–1).
[^380]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 821, lines 1–1).
[^381]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 756, lines 1–25).
[^382]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 780, lines 31–33).
[^383]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 764, lines 16–23).
[^384]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 782, lines 22–29).
[^385]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 785, lines 12–19).
[^386]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 765, lines 7–14).
[^387]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 760, lines 17–24).
[^388]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 767, lines 3–10).
[^389]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 757, lines 15–22).
[^390]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 779, lines 1–8).
[^391]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 767, lines 5–12).
[^392]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 779, lines 20–27).
[^393]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 757, lines 14–21).
[^394]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 757, lines 1–8).
[^395]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 759, lines 24–31).
[^396]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 765, lines 6–13).
[^397]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 786, lines 1–1).
[^398]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 821, lines 1–1).
[^399]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 851, lines 1–1).
[^400]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 786, lines 1–25).
[^401]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 796, lines 6–13).
[^402]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 787, lines 16–23).
[^403]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 807, lines 18–25).
[^404]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 807, lines 18–25).
[^405]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 819, lines 7–14).
[^406]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 820, lines 3–10).
[^407]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 802, lines 1–8).
[^408]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 808, lines 1–8).
[^409]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 802, lines 12–19).
[^410]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 802, lines 1–8).
[^411]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 815, lines 8–9).
[^412]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 792, lines 24–31).
[^413]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 816, lines 3–10).
[^414]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 820, lines 11–18).
[^415]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 800, lines 5–12).
[^416]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 821, lines 1–1).
[^417]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 851, lines 1–1).
[^418]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 886, lines 1–1).
[^419]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 821, lines 1–25).
[^420]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 849, lines 1–8).
[^421]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 845, lines 29–33).
[^422]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 822, lines 23–30).
[^423]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 829, lines 20–27).
[^424]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 829, lines 6–13).
[^425]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 845, lines 1–8).
[^426]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 822, lines 31–33).
[^427]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 832, lines 15–22).
[^428]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 844, lines 9–16).
[^429]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 833, lines 29–33).
[^430]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 847, lines 7–14).
[^431]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 825, lines 11–18).
[^432]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 824, lines 22–29).
[^433]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 831, lines 23–30).
[^434]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 846, lines 10–17).
[^435]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 851, lines 1–1).
[^436]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 886, lines 1–1).
[^437]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 921, lines 1–1).
[^438]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 851, lines 1–25).
[^439]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 857, lines 8–15).
[^440]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 873, lines 24–31).
[^441]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 859, lines 13–20).
[^442]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 859, lines 12–19).
[^443]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 854, lines 30–31).
[^444]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 853, lines 6–13).
[^445]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 852, lines 4–11).
[^446]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 864, lines 6–13).
[^447]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 856, lines 1–8).
[^448]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 868, lines 1–8).
[^449]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 851, lines 10–17).
[^450]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 851, lines 14–21).
[^451]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 861, lines 19–24).
[^452]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 879, lines 8–15).
[^453]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 851, lines 24–27).
[^454]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 886, lines 1–1).
[^455]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 921, lines 1–1).
[^456]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 946, lines 1–1).
[^457]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 886, lines 1–25).
[^458]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 912, lines 4–11).
[^459]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 911, lines 22–29).
[^460]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 916, lines 1–8).
[^461]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 918, lines 1–8).
[^462]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 896, lines 12–19).
[^463]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 889, lines 9–16).
[^464]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 892, lines 2–9).
[^465]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 897, lines 13–20).
[^466]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 907, lines 12–19).
[^467]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 891, lines 16–23).
[^468]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 894, lines 5–12).
[^469]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 909, lines 5–12).
[^470]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 902, lines 20–27).
[^471]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 902, lines 12–19).
[^472]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 892, lines 12–19).
[^473]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 921, lines 1–1).
[^474]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 946, lines 1–1).
[^475]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 986, lines 1–1).
[^476]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 921, lines 1–25).
[^477]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 934, lines 26–29).
[^478]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 921, lines 9–16).
[^479]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 923, lines 3–10).
[^480]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 929, lines 2–9).
[^481]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 944, lines 3–10).
[^482]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 945, lines 16–23).
[^483]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 926, lines 1–8).
[^484]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 936, lines 9–16).
[^485]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 927, lines 12–19).
[^486]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 945, lines 3–10).
[^487]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 941, lines 18–25).
[^488]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 925, lines 13–20).
[^489]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 936, lines 1–8).
[^490]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 945, lines 5–12).
[^491]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 921, lines 26–33).
[^492]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 946, lines 1–1).
[^493]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 986, lines 1–1).
[^494]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1021, lines 1–1).
[^495]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 946, lines 1–25).
[^496]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 949, lines 33–37).
[^497]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 967, lines 1–8).
[^498]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 968, lines 26–33).
[^499]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 955, lines 1–8).
[^500]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 953, lines 2–9).
[^501]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 954, lines 1–8).
[^502]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 966, lines 3–10).
[^503]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 976, lines 1–8).
[^504]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 958, lines 1–8).
[^505]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 946, lines 7–14).
[^506]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 962, lines 11–18).
[^507]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 949, lines 3–10).
[^508]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 963, lines 25–31).
[^509]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 972, lines 16–23).
[^510]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 976, lines 2–9).
[^511]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 986, lines 1–1).
[^512]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1021, lines 1–1).
[^513]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1061, lines 1–1).
[^514]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 986, lines 1–25).
[^515]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1015, lines 18–25).
[^516]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1020, lines 1–8).
[^517]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 999, lines 21–28).
[^518]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 986, lines 2–9).
[^519]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 991, lines 10–17).
[^520]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 998, lines 6–13).
[^521]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1014, lines 2–9).
[^522]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1013, lines 6–13).
[^523]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1003, lines 3–10).
[^524]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1014, lines 2–9).
[^525]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 996, lines 16–23).
[^526]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 990, lines 16–23).
[^527]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 989, lines 18–25).
[^528]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1006, lines 22–29).
[^529]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1001, lines 4–11).
[^530]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1021, lines 1–1).
[^531]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1061, lines 1–1).
[^532]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1101, lines 1–1).
[^533]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1021, lines 1–25).
[^534]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1053, lines 11–18).
[^535]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1038, lines 1–8).
[^536]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1057, lines 3–10).
[^537]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1040, lines 24–31).
[^538]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1040, lines 15–22).
[^539]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1047, lines 1–8).
[^540]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1022, lines 1–8).
[^541]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1050, lines 20–27).
[^542]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1037, lines 6–13).
[^543]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1032, lines 1–8).
[^544]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1045, lines 27–31).
[^545]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1032, lines 1–8).
[^546]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1056, lines 9–16).
[^547]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1032, lines 1–8).
[^548]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1021, lines 30–31).
[^549]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1061, lines 1–1).
[^550]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1101, lines 1–1).
[^551]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1141, lines 1–1).
[^552]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1061, lines 1–25).
[^553]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1094, lines 17–18).
[^554]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1079, lines 9–16).
[^555]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1096, lines 7–14).
[^556]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1062, lines 12–19).
[^557]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1067, lines 27–34).
[^558]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1063, lines 8–15).
[^559]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1068, lines 15–22).
[^560]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1062, lines 2–9).
[^561]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1091, lines 18–25).
[^562]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1088, lines 1–8).
[^563]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1100, lines 12–19).
[^564]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1100, lines 23–30).
[^565]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1088, lines 4–11).
[^566]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1070, lines 2–9).
[^567]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1069, lines 1–8).
[^568]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1101, lines 1–1).
[^569]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1141, lines 1–1).
[^570]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1181, lines 1–1).
[^571]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1101, lines 1–25).
[^572]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1103, lines 20–25).
[^573]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1116, lines 7–14).
[^574]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1129, lines 18–25).
[^575]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1126, lines 1–8).
[^576]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1125, lines 35–42).
[^577]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1123, lines 6–13).
[^578]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1112, lines 13–20).
[^579]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1114, lines 20–27).
[^580]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1124, lines 33–40).
[^581]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1124, lines 21–28).
[^582]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1127, lines 17–24).
[^583]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1114, lines 1–8).
[^584]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1113, lines 9–16).
[^585]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1125, lines 31–38).
[^586]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1117, lines 7–14).
[^587]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1141, lines 1–1).
[^588]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1181, lines 1–1).
[^589]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1216, lines 1–1).
[^590]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1141, lines 1–25).
[^591]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1150, lines 10–17).
[^592]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1178, lines 7–14).
[^593]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1173, lines 5–12).
[^594]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1178, lines 7–14).
[^595]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1163, lines 7–14).
[^596]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1173, lines 20–27).
[^597]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1148, lines 29–36).
[^598]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1158, lines 1–8).
[^599]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1158, lines 2–9).
[^600]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1168, lines 11–18).
[^601]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1168, lines 8–15).
[^602]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1153, lines 1–8).
[^603]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1154, lines 1–8).
[^604]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1154, lines 29–30).
[^605]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1174, lines 14–21).
[^606]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1181, lines 1–1).
[^607]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1216, lines 1–1).
[^608]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1251, lines 1–1).
[^609]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1181, lines 1–25).
[^610]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1214, lines 1–8).
[^611]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1206, lines 6–13).
[^612]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1185, lines 3–10).
[^613]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1202, lines 3–10).
[^614]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1185, lines 12–19).
[^615]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1184, lines 16–23).
[^616]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1206, lines 1–8).
[^617]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1183, lines 8–15).
[^618]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1212, lines 1–8).
[^619]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1189, lines 16–23).
[^620]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1188, lines 6–13).
[^621]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1196, lines 11–18).
[^622]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1188, lines 30–34).
[^623]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1212, lines 1–8).
[^624]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1200, lines 23–29).
[^625]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1216, lines 1–1).
[^626]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1251, lines 1–1).
[^627]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1286, lines 1–1).
[^628]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1216, lines 1–25).
[^629]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1247, lines 5–12).
[^630]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1242, lines 26–31).
[^631]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1221, lines 1–8).
[^632]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1232, lines 1–8).
[^633]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1218, lines 28–35).
[^634]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1224, lines 18–25).
[^635]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1218, lines 2–9).
[^636]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1248, lines 18–25).
[^637]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1247, lines 1–8).
[^638]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1219, lines 2–9).
[^639]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1249, lines 1–8).
[^640]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1224, lines 7–14).
[^641]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1247, lines 1–8).
[^642]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1227, lines 33–35).
[^643]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1229, lines 6–13).
[^644]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1251, lines 1–1).
[^645]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1286, lines 1–1).
[^646]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1321, lines 1–1).
[^647]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1251, lines 1–25).
[^648]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1257, lines 19–26).
[^649]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1254, lines 29–34).
[^650]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1277, lines 18–25).
[^651]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1282, lines 28–34).
[^652]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1282, lines 23–30).
[^653]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1278, lines 21–28).
[^654]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1282, lines 21–28).
[^655]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1283, lines 1–8).
[^656]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1276, lines 1–8).
[^657]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1256, lines 3–10).
[^658]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1260, lines 2–9).
[^659]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1276, lines 1–8).
[^660]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1276, lines 1–8).
[^661]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1274, lines 4–11).
[^662]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1283, lines 21–28).
[^663]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1286, lines 1–1).
[^664]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1321, lines 1–1).
[^665]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1366, lines 1–1).
[^666]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1286, lines 1–25).
[^667]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1306, lines 15–22).
[^668]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1289, lines 8–15).
[^669]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1289, lines 7–14).
[^670]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1297, lines 2–9).
[^671]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1291, lines 20–27).
[^672]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1296, lines 1–8).
[^673]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1304, lines 12–19).
[^674]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1308, lines 22–29).
[^675]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1315, lines 1–8).
[^676]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1290, lines 2–9).
[^677]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1286, lines 1–8).
[^678]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1302, lines 1–8).
[^679]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1287, lines 25–29).
[^680]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1286, lines 1–8).
[^681]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1286, lines 23–30).
[^682]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1321, lines 1–1).
[^683]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1366, lines 1–1).
[^684]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1411, lines 1–1).
[^685]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1321, lines 1–25).
[^686]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1364, lines 8–15).
[^687]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1336, lines 28–35).
[^688]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1336, lines 28–35).
[^689]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1330, lines 25–32).
[^690]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1359, lines 24–29).
[^691]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1358, lines 10–17).
[^692]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1358, lines 3–10).
[^693]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1365, lines 2–9).
[^694]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1365, lines 2–9).
[^695]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1343, lines 7–14).
[^696]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1345, lines 25–31).
[^697]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1325, lines 7–14).
[^698]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1365, lines 12–19).
[^699]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1358, lines 3–10).
[^700]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1351, lines 8–15).
[^701]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1366, lines 1–1).
[^702]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1411, lines 1–1).
[^703]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1456, lines 1–1).
[^704]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1366, lines 1–25).
[^705]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1371, lines 1–8).
[^706]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1371, lines 9–16).
[^707]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1370, lines 15–22).
[^708]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1390, lines 29–34).
[^709]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1380, lines 18–25).
[^710]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1371, lines 18–25).
[^711]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1392, lines 5–12).
[^712]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1392, lines 3–10).
[^713]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1390, lines 3–10).
[^714]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1389, lines 3–10).
[^715]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1379, lines 2–9).
[^716]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1366, lines 1–8).
[^717]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1366, lines 1–8).
[^718]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1367, lines 22–29).
[^719]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1387, lines 1–8).
[^720]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1411, lines 1–1).
[^721]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1456, lines 1–1).
[^722]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1501, lines 1–1).
[^723]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1411, lines 1–25).
[^724]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1421, lines 17–24).
[^725]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1440, lines 1–8).
[^726]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1417, lines 6–13).
[^727]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1426, lines 1–8).
[^728]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1432, lines 18–25).
[^729]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1444, lines 25–30).
[^730]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1444, lines 5–12).
[^731]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1440, lines 3–10).
[^732]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1428, lines 11–18).
[^733]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1416, lines 2–9).
[^734]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1444, lines 27–30).
[^735]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1411, lines 16–23).
[^736]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1428, lines 1–8).
[^737]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1416, lines 1–8).
[^738]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1413, lines 3–10).
[^739]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1456, lines 1–1).
[^740]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1501, lines 1–1).
[^741]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1456, lines 1–25).
[^742]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1480, lines 20–27).
[^743]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1489, lines 1–8).
[^744]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1466, lines 27–33).
[^745]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1469, lines 23–27).
[^746]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1466, lines 1–8).
[^747]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1463, lines 1–8).
[^748]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1499, lines 1–8).
[^749]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1471, lines 1–8).
[^750]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1491, lines 14–21).
[^751]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1499, lines 3–10).
[^752]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1470, lines 12–19).
[^753]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1476, lines 15–22).
[^754]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1463, lines 26–31).
[^755]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1498, lines 18–20).
[^756]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1458, lines 1–8).
[^757]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1501, lines 1–1).
[^758]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1501, lines 1–25).
[^759]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1679, lines 1–8).
[^760]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1520, lines 22–29).
[^761]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1591, lines 18–25).
[^762]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1700, lines 25–32).
[^763]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1569, lines 8–15).
[^764]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1656, lines 29–36).
[^765]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1578, lines 9–16).
[^766]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1540, lines 24–30).
[^767]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1682, lines 1–8).
[^768]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1636, lines 3–10).
[^769]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1627, lines 24–31).
[^770]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1630, lines 1–8).
[^771]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1669, lines 1–8).
[^772]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1621, lines 8–15).
[^773]: Lutz, Mark. *Learning Python, 6th Edition*. (JSON `Learning Python Ed6.json`, p. 1692, lines 19–26).
